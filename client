! function(b, c) {
    function d(a, b) {
        a = a.substring(0, 150), "string" == typeof a && "" != a && Pc.emit("c", {
            m: a,
            i: b
        })
    }

    function f(a, b) {
        if (void 0 !== va && (va.dispose(), delete va, va = void 0), void 0 !== wa && (X(wa), Rb.remove(wa), delete wa, wa = void 0), "0" != sa.get("grass")) {
            va = new THREE.InstancedBufferGeometry, va.copy(new THREE.PlaneBufferGeometry(2, 2)), Pb = a;
            var c = 5e3;
            switch (parseInt(sa.get("grass"))) {
                default:
                    case 1:
                    c = 1e3;
                break;
                case 2:
                        c = 15e3;
                    break;
                case 3:
                        c = 3e4;
                    break;
                case 4:
                        c = 6e4;
                    break;
                case 5:
                        c = 15e4
            }
            for (var d = new Float32Array(3 * c), e = new Float32Array(c), f = new Float32Array(3 * c), g = new Float32Array(3 * c), h = 0, i = 0; h < c;) {
                var j = Math.random(),
                    k = Math.random(),
                    l = V(Math.round(j * a.width), Math.round(k * a.height)),
                    m = l.a / 255;
                if (!(l.a <= 5 || Math.random() > m)) {
                    var n = Math.floor(k * (Mb / bc)) * Nb + 3 * Math.floor(j * (Mb / bc));
                    d[i + 0] = j * Mb, d[i + 1] = hc(Mb * j, Mb * k) + .6, d[i + 2] = k * Mb, e[h] = m * (Math.random() + .1) * 3 + .5, Math.random() < 1e3 / c && (e[h] += 1.5 * Math.random(), l.r *= .3 * Math.random() + .7, l.g *= .3 * Math.random() + .7, l.b *= .3 * Math.random() + .7), f[i + 0] = .1 * Math.random() - .05 + l.r / 255, f[i + 1] = .1 * Math.random() - .05 + l.g / 255, f[i + 2] = .1 * Math.random() - .05 + l.b / 255, g[i + 0] = b.attributes.normal.array[n], g[i + 1] = b.attributes.normal.array[n + 1], g[i + 2] = b.attributes.normal.array[n + 2], h++, i += 3
                }
            }
            va.addAttribute("translate", new THREE.InstancedBufferAttribute(d, 3, 1)), va.addAttribute("color", new THREE.InstancedBufferAttribute(f, 3, 1)), va.addAttribute("scale", new THREE.InstancedBufferAttribute(e, 1, 1)), va.addAttribute("groundNormal", new THREE.InstancedBufferAttribute(g, 3, 1)), mc.foliage || (mc.foliage = new THREE.RawShaderMaterial({
                uniforms: {
                    map: {
                        value: cb.grass
                    },
                    shadow: {
                        value: Vb.shadow.map
                    },
                    time: {
                        value: 0
                    },
                    camXRot: {
                        value: 0
                    },
                    camYRot: {
                        value: 0
                    },
                    ambient: {
                        value: Ub.color
                    },
                    directional: {
                        value: Vb.color
                    },
                    directionalDir: {
                        value: Vb.position
                    },
                    directionalMVP: {
                        value: new THREE.Matrix4
                    },
                    maxDrawDistance: {
                        value: 150
                    },
                    fogColor: {
                        value: Rb.fog.color
                    },
                    fogDensity: {
                        value: Rb.fog.density
                    },
                    targetCircle: {
                        value: new THREE.Vector4(0, 0, 0, 2)
                    },
                    targetCirclePos: {
                        value: new THREE.Vector2(0, 0)
                    },
                    shadowSize: {
                        value: 0
                    },
                    playerscale: {
                        value: 1
                    }
                },
                vertexShader: db["grass.vert"],
                fragmentShader: db["grass.frag"],
                depthTest: !0,
                depthWrite: !0
            })), wa = new THREE.Mesh(va, mc.foliage), wa.frustumCulled = !1, Rb.add(wa)
        }
    }

    function g() {
        if (void 0 !== va) {
            var a = 5e-4 * performance.now();
            mc.foliage.uniforms.time.value = a;
            var b = Wb.getWorldRotation();
            mc.foliage.uniforms.camXRot.value = b.x, mc.foliage.uniforms.camYRot.value = b.y, mc.foliage.uniforms.directionalMVP.value = Vb.shadow.matrix, Vb.shadow.map && mc.foliage.uniforms.shadow.value != Vb.shadow.map.texture && (mc.foliage.uniforms.shadow.value = Vb.shadow.map.texture), Zb ? (void 0 !== Zb.stats.scale && (mc.foliage.uniforms.playerscale.value = Zb.stats.scale), Zb.target ? (mc.foliage.uniforms.targetCirclePos.value = new THREE.Vector2(Zb.target.visualPosition.x, Zb.target.visualPosition.z), mc.foliage.uniforms.targetCircle.value.w = Zb.target.stats.scale + .5, mc.foliage.uniforms.targetCircle.value.x = Zb.target.faction == Zb.faction ? 0 : 1, mc.foliage.uniforms.targetCircle.value.y = Zb.target.faction == Zb.faction ? 1 : 0) : mc.foliage.uniforms.targetCirclePos.value = new THREE.Vector2(0, 0)) : mc.foliage.uniforms.playerscale.value = 1
        }
    }

    function h(a, b) {
        this.position = new THREE.Vector3(0, 0, 0), this.velocity = new THREE.Vector3, this.walkForward = 0, this.walkSideward = 0, this.rotation = 0, this.state = new u, this.name = "", this.id = "", this.faction = a, this.stats = new r(this), this.class = new E, this.class.stats = this.stats, this.target = void 0, this.combat = !1, this.gold = 0, this.fame = 0, this.last = {}, this.last.gold = 0, this.last.faction = -1, this.last.name = "", this.last.id = "", this.last.position = new THREE.Vector3, this.last.walkForward = 0, this.last.walkSideward = 0, this.last.rotation = 0, this.last.updateTime = Date.now(), this.last.state = {}, this.last.class = {}, this.last.class.ai = {}, this.last.class.ai.isresetting = 0, this.last.state.id = 0, this.last.target = {}, this.last.target.id = void 0, this.last.stats = {}, this.last.isAi = !1, this.last.combat = !1, this.visuals = {
            h: 0
        }, this.last.visuals = {
            h: 0
        }, this.serverMsgQueue = {}, ya ? (this.lastDmgTakenTime = 0, this.class = b, this.class.stats = this.stats, this.class.parent = this, this.respawn = !1, this.pickup = void 0, this.fullrequests = [], this.class.ai ? (this.class.ai.class = this.class, this.class.ai.parent = this, this.isAi = !0) : this.lastPositionUpdate = new THREE.Vector3, this.ignoreMovement = 0, this.class.update(), this.stats.spawn(), this.class.skills[1].setLevel(1), this.personalMessages = {}) : (this.dmgShake = 0, this.class.ai = void 0, this.class.color = mc.monster, this.next = {}, this.next.position = new THREE.Vector3, this.animationQueue = [])
    }

    function j(a) {
        for (var b in a) return !1;
        return !0
    }

    function l(a, b) {
        var c = b.x - a.x,
            d = b.z - a.z;
        return Math.sqrt(c * c + d * d)
    }

    function n(a) {
        ya ? this.serverInit(a) : this.clientInit(a)
    }

    function o(a, b) {
        this.a = a, this.b = b, this.aggroA = 0, this.aggroB = 0, this.expShareA = 0, this.expShareB = 0, this.distance = function() {
            return void 0 === this._distance ? (this._distance = Math.max(0, D(a, b) - (a.stats.scale + b.stats.scale)), this._distance) : this._distance
        }, this.aggro = function(a) {
            return a == this.a ? this.aggroA : a == this.b ? this.aggroB : void 0
        }, this.modifyAggro = function(a, b) {
            a == this.a && (this.aggroA += b), a == this.b && (this.aggroB += b)
        }, this.resetAggro = function(a) {
            a == this.a && (this.aggroA = 0), a == this.b && (this.aggroB = 0)
        }, this.canFight = function() {
            return void 0 !== this._canFight ? this._canFight : (this._canFight = !0, ya && (this.a.isAi && 1 == this.a.class.ai.isresetting && (this._canFight = !1), this.b.isAi && 1 == this.b.class.ai.isresetting && (this._canFight = !1)), this.a.isAi || this.b.isAi || (this.a.class.level < 8 && this.b.class.level >= 8 || this.b.class.level < 8 && this.a.class.level >= 8) && (this._canFight = !1), this._canFight)
        }, this.expShare = function(a) {
            return a == this.a ? this.expShareA : a == this.b ? this.expShareB : void 0
        }, this.modifyExpShare = function(a, b) {
            a == this.a && (this.expShareA += b), a == this.b && (this.expShareB += b)
        }, this.clearIntervalData = function() {
            this._distance = void 0, this._canFight = void 0
        }
    }

    function p(a) {
        if (this.name = a.name || "", this.target = a.target || void 0, this.source = a.source || void 0, this.ribbon = a.ribbon || void 0, this.effectCallback = a.effect || void 0, this.effectInterval = a.effectInterval || -1, this.effectTimer = this.effectInterval, this.timeout = a.timeout || 30, this.mode = a.mode || "follow", this.movespeed = a.movespeed || 10, this.movedir = a.movedir || void 0, this.position = new THREE.Vector3, this.visualtick = a.tick || function(a) {
                this.geometry.position.copy(this.position), this.target && this.target.geometry && this.geometry.lookAt(this.target.chest.getWorldPosition())
            }, a.startposition) this.position.copy(a.startposition);
        else if (this.source) {
            if (this.position.copy(this.source.position), this.source) {
                var b = z(this.source.rotation);
                b.multiplyScalar(1.2 * this.source.stats.scale)
            }
            if (this.position.x += b.x, this.position.z += b.y, !ya) {
                var c = this.source.chest.getWorldPosition();
                this.position.y = c.y
            }
        } else this.deleteMe = !0;
        ya || (this.geometry = a.geometry || new THREE.Mesh(new THREE.BoxGeometry(.3, .3, .3), new THREE.MeshBasicMaterial({
            color: 255
        })), this.geometry.position.copy(this.position), Rb.add(this.geometry), this.ribbon && (this.ribbonObject = Fc(this.ribbon)))
    }

    function q(a, b, c) {
        this.slot = a, this.class = b, this.predict = void 0 === c.predict || c.predict, this.ignoreEc = void 0 !== c.ignoreEc && c.ignoreEc, this.simulate = void 0 !== c.simulate && c.simulate, this.allowDeadTarget = void 0 !== c.allowDeadTarget && c.allowDeadTarget, this.description = c.description || "missing description", this.level = 0, this.nextLevelCost = 0, this.abilitypower = 0, this.setLevel(c.baselevel || 0), this.name = c.name || "Error: no skill id", this.icon = c.icon || "hpbarbg", this.targettype = c.targettype || "enemy", this.unique = c.unique || !1, this.casttype = c.casttype || "instant", this.casttime = c.casttime || 0, this.casttimer = 0, this.casttarget = void 0, this.cooldown = void 0 !== c.cooldown ? c.cooldown : 0, this.cooldowntimer = 0, this.causeGlobalCooldown = void 0 === c.causeGlobalCD || c.causeGlobalCD, this.maxrange = c.maxrange || 1e3, this.spell = c.spell || void 0, this.hasChanneledSpell = c.spellchannel || void 0, this.effect = c.effect || function() {
            console.log("error, missing skill effect: " + this.name)
        }, this.effecttype = c.effecttype || "instant", this.channelInterval = c.channelInterval || ("channel" == this.effecttype ? 1 : void 0), this.channelDuration = c.channelDuration || ("channel" == this.effecttype ? 2 : void 0), this.channelMoveInterrupt = void 0 === c.channelMoveInterrupt || c.channelMoveInterrupt, this.channelInstantFirstTick = void 0 !== c.channelInstantFirstTick && c.channelInstantFirstTick, this.channelDuration && (this.channelTimer = -1), this.channelInterval && (this.channelIntervalTimer = -1), this.onCastFun = c.onCastFun || void 0;
        var d = this;
        this.effectWrapper = function(a) {
            d.effect && (a.source = a.source || d.parent, a.target = a.target || d.casttarget, d.effect(a))
        }, ya || (this.getCharacterAnim = c.characterAnim || function() {
            return new M({
                id: "release_spell",
                duration: .5
            })
        }), ya || ("timed" == this.casttype && (this.castAnimation = c.castAnim || new M({
            id: "cast",
            duration: .8,
            type: "loop"
        })), "channel" == this.effecttype && (this.channelAnimation = c.channelAnim || new M({
            id: "channel",
            duration: .5,
            type: "loop"
        })))
    }

    function r(a) {
        this.scale = 1, this.currenthp = 1, this.maxhp = 1, this.currentdmg = 1, this.hpregen = 0, this.movespeed = 10, this.healmod = 1, this.defense = 1, this.parent = a, this.incapacitated = !1, this.stunned = !1, this.periodicTickTimer = 0, this.mods = []
    }

    function s(a, b, c) {
        this.id = c.id || void 0, this.duration = c.duration || 1, this.effectinterval = c.interval || -1, this.effectfunction = c.effect || void 0, this.name = c.name || "Error: no name", this.overwrite = c.overwrite || !1, this.unique = c.unique || !1, this.invincible = c.invincible || !1, this.incapacitate = c.incapacitate || !1, this.stun = c.stun || !1, this.movespeed = c.movespeed || void 0, this.healmod = c.healmod || void 0, this.target = a, this.source = b, this.timer = this.duration, this.effecttimer = this.effectinterval, this.deleteMe = !1
    }

    function t() {
        this.id = 0, this.timer = 0, this.duration = 0, this.tick = function(a, b) {}
    }

    function u() {
        this.id = 0, this.duration = 0, this.tick = function(a, b) {
            if (ya && void 0 !== b.queuedSkill) 0 !== b.walkForward || 0 !== b.walkSideward ? b.queuedSkill = void 0 : (b.useSkill(b.queuedSkill, !0), b.queuedSkill = void 0);
            else if (!ya && b.animationQueue && b.animationQueue[0]) switch (b.animationQueue[0].id) {
                case "cast":
                case "dead":
                    b.animationQueue[0].deleteMe = !0
            }
        }
    }

    function v(a) {
        this.id = 1, this.skill = a.skill, this.duration = a.casttime || 1, ya || (this.duration += Tc / 1e3), this.maxduration = this.duration, this.active = a.activeCheck, this.interrupt = a.interrupt, this.tick = function(a, b) {
            !this.active.call(this.skill) || this.skill.channelMoveInterrupt && (b.walkForward || b.walkSideward) ? (this.skill.channelMoveInterrupt && (b.walkForward || b.walkSideward) && this.interrupt.call(this.skill), b.state = new u) : (this.duration -= a, this.duration < 0 && ya && (b.state = new u))
        }
    }

    function w() {
        this.id = 2, this.duration = 5, this.tick = function(a, b) {
            this.timer += a
        }
    }

    function x(a) {
        var b = a.angle() + .5 * Math.PI;
        return b > 2 * Math.PI && (b -= 2 * Math.PI), b = 2 * Math.PI - b
    }

    function y(a, b) {
        for (var c = b - a; c < -Math.PI;) c += 2 * Math.PI;
        for (; c > Math.PI;) c -= 2 * Math.PI;
        return c
    }

    function z(a) {
        return new THREE.Vector2(-Math.sin(a), -Math.cos(a))
    }

    function A(a, b) {
        return x(new THREE.Vector2(b.x - a.x, b.z - a.z))
    }

    function B(a, b) {
        return x(new THREE.Vector2(b.position.x - a.position.x, b.position.z - a.position.z))
    }

    function C(a, b) {
        return a.position.distanceTo(b)
    }

    function D(a, b) {
        return a.position.distanceTo(b.position)
    }

    function E() {
        this.level = 1, this.nextLevelExp = 1, this.sumexp = 0, this.exp = 0, this.dmg = 1, this.maxhp = 5, this.scale = 1
    }

    function F(a) {
        this.level = a, this.ai = new Z, this.type = "monster", this.exp = 0, ya || (this.color = mc.monster), this.skills = {
            1: new q(1, this, {
                name: "Melee Attack",
                targettype: "enemy",
                casttype: "instant",
                baselevel: 3,
                cooldown: 1,
                maxrange: 1.5,
                simulate: !0,
                effect: function() {
                    Xa.damage({
                        spread: .2,
                        attacker: this.parent,
                        target: this.casttarget
                    })
                },
                characterAnim: function() {
                    return new M({
                        id: "swing_melee",
                        duration: .5
                    })
                }
            })
        }, this.getMovespeed = function() {
            return 1 == this.ai.isresetting ? 10 : 5
        }, this.getScale = function() {
            return .5 + .07 * this.level
        }, this.getDmg = function() {
            return .3 * parseInt(Math.pow(1.2 + 1.2 * this.level, 1.5))
        }
    }

    function G() {
        var a = new I(100);
        return a.skills[1].setLevel(1), a.skills[2].setLevel(1), a.exp = 0, a.fame = 5e3, a.gold = 1e4, a.type = "king", a.ai = new Z, ya && (a.ai.protect = !0, a.ai.idleinterval = 20, a.ai.idleradius = 2, a.ai.aggrodistance = 45, a.ai.idlewalkduration = .02, a.ai.hardResetDistanceSqr = 6e3), ya || (a.color = mc.warden), a.getMaxHp = function() {
            return 1e5
        }, a.getDmg = function() {
            return 2e3
        }, a.getMovespeed = function() {
            return 1 == this.ai.isresetting ? 25 : 15
        }, a.getScale = function() {
            return 6
        }, a
    }

    function H() {
        var a = new I(100);
        return a.skills[1].setLevel(1), a.skills[2].setLevel(1), a.skills[3].setLevel(1), a.skills[4].setLevel(1), a.fame = 300, a.gold = 1e3, a.ai = new Z, ya && (a.ai.protect = !0, a.ai.idleinterval = 20, a.ai.idleradius = 2, a.ai.aggrodistance = 45, a.ai.idlewalkduration = .02, a.ai.hardResetDistanceSqr = 6e3), a.type = "warden", ya || (a.color = mc.warden), a.getMaxHp = function() {
            return 5e4
        }, a.getDmg = function() {
            return 1600
        }, this.getHpRegen = function() {
            return 350
        }, a.getMovespeed = function() {
            return 1 == this.ai.isresetting ? 25 : 15
        }, a.getScale = function() {
            return 1.8
        }, a
    }

    function I(a) {
        this.level = a, this.type = "warrior", ya || (this.color = mc.warrior), this.getDefense = function() {
            return .6
        }, this.getMaxHp = function() {
            return parseInt(1.4 * Math.pow(12 + 1.5 * this.level, 1.9))
        }, this.skills = {
            1: new q(1, this, {
                name: "Deep Cut",
                description: "Slash your enemies arteries, causing them to bleed over a period of time. Heals you for a percentage of your missing health.",
                icon: "data/skill/warrior_rend.jpg",
                targettype: "enemy",
                casttype: "instant",
                baselevel: 1,
                maxrange: 1.5,
                simulate: !0,
                effect: function() {
                    var a = this.abilitypower;
                    this.parent.takeHealing(.1 * (this.parent.stats.maxhp - this.parent.stats.currenthp), this.parent), Xa.damage({
                        spread: .2,
                        basedmg: 25,
                        scaledmg: .5 + .4 * this.abilitypower,
                        attacker: this.parent,
                        target: this.casttarget,
                        mod: {
                            id: "deepcut",
                            overwrite: !0,
                            duration: 5,
                            interval: 1,
                            movespeed: function(a) {
                                return .65 * a
                            },
                            effect: function() {
                                Xa.damage({
                                    attacker: this.source,
                                    target: this.target,
                                    spread: .1,
                                    basedmg: 10,
                                    scaledmg: .2 + .1 * a
                                })
                            }
                        }
                    })
                },
                characterAnim: function() {
                    return Fc({
                        parent: this.parent.weapon,
                        aPos: new THREE.Vector3(0, 1.5, 0),
                        bPos: new THREE.Vector3(0, -.3, 0),
                        material: mc.ribbon_arrow,
                        stepInterval: .01,
                        steps: 10,
                        timeout: .45
                    }), new M({
                        id: "swing_melee",
                        duration: .45
                    })
                }
            }),
            2: new q(2, this, {
                name: "Whirlwind",
                icon: "data/skill/warrior_spin.jpg",
                description: "Spin your sword, dealing damage to enemies in a circle around you. Decreases movement speed while active.",
                targettype: "none",
                casttype: "instant",
                cooldown: 6,
                effecttype: "channel",
                channelInterval: .5,
                channelDuration: 4,
                channelMoveInterrupt: !1,
                channelInstantFirstTick: !0,
                maxrange: 8,
                predict: !1,
                effect: function() {
                    Xa.damage({
                        scaledmg: .37 + .75 * this.abilitypower,
                        basedmg: 17,
                        spread: .2,
                        attacker: this.parent,
                        mode: "aoe",
                        aoeRange: 4
                    }), this.parent.stats.addMod(new s(this.parent, this.parent, {
                        duration: .8,
                        name: "Whirlwind Slow",
                        movespeed: function(a) {
                            return .7 * a
                        }
                    }))
                },
                channelAnim: ya ? void 0 : new M({
                    id: "spin",
                    duration: .5,
                    type: "loop"
                }),
                onCastFun: ya ? void 0 : function() {
                    Fc({
                        parent: this.parent.weapon,
                        aPos: new THREE.Vector3(0, 1.8, 0),
                        bPos: new THREE.Vector3(0, -.3, 0),
                        material: mc.ribbon_whirlwind,
                        stepInterval: .015,
                        steps: 15,
                        timeout: 4
                    })
                }
            }),
            3: new q(3, this, {
                name: "Charge",
                icon: "data/skill/warrior_charge.jpg",
                description: "Charge at your enemy, interrupting his current cast and stopping his movements.",
                casttype: "instant",
                cooldown: 9,
                effecttype: "channel",
                channelInterval: .1,
                channelDuration: 5,
                maxrange: 35,
                channelMoveInterrupt: !1,
                ignoreEc: !0,
                predict: !1,
                effect: function() {
                    this.casttarget && Ta(this.parent, this.casttarget).distance() > 3 && !this.casttarget.stats.isDead() ? (this.parent.rotation = B(this.parent, this.casttarget), this.parent.walkForward = 1, this.parent.walkSideward = 0, ya ? this.parent.ignoreMovement = .1 : this.parent.ignoreInput = .15, this.parent.stats.addMod(new s(this.parent, this.parent, {
                        duration: .15,
                        name: "Charge",
                        unique: !0,
                        movespeed: function(a) {
                            return 30
                        }
                    })), this.casttarget.stats.addMod(new s(this.casttarget, this.parent, {
                        duration: 1,
                        name: "Stun",
                        unique: !0,
                        incapacitate: !0
                    })), this.casttarget.walkForward = 0, this.casttarget.walkSideward = 0, Xa.interrupt(this.casttarget, this.parent)) : (this.interruptChannel(), this.parent.walkForward = 0, this.parent.walkSideward = 0, this.parent.stats.servermovespeed = void 0)
                }
            }),
            4: new q(4, this, {
                name: "Taunt",
                icon: "data/skill/warrior_shout.jpg",
                description: "Intimidate your enemies with a loud roar, generating high levels of threat and regenerating a portion of your missing health. Removes debuffs.",
                targettype: "none",
                casttype: "instant",
                cooldown: 20,
                maxrange: 30,
                simulate: !0,
                effect: function() {
                    var a = this.abilitypower;
                    Xa.damage({
                        scaledmg: .05 + .02 * this.abilitypower,
                        basedmg: 3 + 5 * this.abilitypower,
                        spread: .1,
                        attacker: this.parent,
                        mode: "aoe",
                        aoeRange: 23,
                        aggro: 1e3
                    }), this.parent.stats.addMod(new s(this.parent, this.parent, {
                        id: "tauntreg",
                        overwrite: !0,
                        duration: 10,
                        interval: 1,
                        effect: function() {
                            Xa.damage({
                                attacker: this.source,
                                target: this.target,
                                spread: .1,
                                basedmg: (this.target.stats.maxhp - this.target.stats.currenthp) * (.04 + .018 * a),
                                scaledmg: 0,
                                heal: !0
                            })
                        }
                    }))
                },
                characterAnim: function() {
                    return new M({
                        id: "boost",
                        duration: 1
                    })
                }
            })
        }
    }

    function J(a) {
        this.level = a, this.type = "mage", ya || (this.color = mc.mage), this.getDefense = function() {
            return .8
        }, this.getMaxHp = function() {
            return parseInt(1.2 * Math.pow(12 + 1.5 * this.level, 1.9))
        }, this.skills = {
            1: new q(1, this, {
                name: "Ice Bolt",
                description: "Fire a magic ice bolt at the enemy, dealing damage to all targets in the area and slowing them for a brief moment.",
                icon: "data/skill/mage_icebolt.jpg",
                targettype: "enemy",
                casttype: "instant",
                baselevel: 1,
                maxrange: 30,
                simulate: !0,
                spell: function(a, b, c) {
                    if (!ya) {
                        var d = new THREE.Mesh(Cc.icebolt.geo, mc.mage_ice);
                        d.scale.z = 2
                    }
                    return new p({
                        name: "Ice Bolt",
                        target: a,
                        source: b,
                        effect: c,
                        mode: "follow",
                        movespeed: 20,
                        geometry: d ? d : void 0
                    })
                },
                effect: function(a) {
                    Xa.damage({
                        scaledmg: .2 + .3 * this.abilitypower,
                        basedmg: 20,
                        attacker: a.source,
                        mode: "aoe",
                        aoeRange: 9,
                        aoeCenter: a.target.position,
                        mod: {
                            unique: !0,
                            id: "frostcallfrosted",
                            duration: 6,
                            name: "Frosted",
                            movespeed: function(a) {
                                return .6 * a
                            }
                        }
                    })
                }
            }),
            2: new q(2, this, {
                name: "Frostcall",
                description: "You call down a blizzard on an enemies position, dealing damage over time. Channeled.",
                icon: "data/skill/mage_blizzard.jpg",
                targettype: "enemy",
                casttype: "timed",
                casttime: 1,
                effecttype: "channel",
                channelInterval: 1,
                channelDuration: 5,
                spellchannel: !0,
                cooldown: 7,
                maxrange: 35,
                channelInstantFirstTick: !0,
                allowDeadTarget: !0,
                spell: function(a, b, c) {
                    if (a) return new p({
                        name: "Frostcall",
                        startposition: ya ? a.position : a.geometry ? a.geometry.position : a.position,
                        source: b,
                        effect: c,
                        mode: "static",
                        timeout: 5,
                        geometry: ya ? void 0 : new THREE.Mesh(Cc.frostcall.geo, mc.mage_frost)
                    })
                },
                effect: function(a) {
                    if (Xa.damage({
                            scaledmg: 1.1 + .6 * this.abilitypower,
                            basedmg: 25 + 5 * this.abilitypower,
                            spread: .2,
                            attacker: a.source,
                            mode: "aoe",
                            aoeRange: 12,
                            aoeCenter: a.spell.position,
                            mod: {
                                unique: !0,
                                id: "frostcallfrosted",
                                duration: 2,
                                name: "Frosted",
                                movespeed: function(a) {
                                    return .4 * a
                                }
                            }
                        }), !ya && a.target && a.target.geometry)
                        for (var b = 0; b < 15; ++b) {
                            var c = Math.random() * Math.PI * 2,
                                d = 12 * Math.random(),
                                e = new p({
                                    name: "Flake",
                                    mode: "static",
                                    movedir: new THREE.Vector3(0, -1, 0),
                                    startposition: new THREE.Vector3(a.spell.position.x + Math.cos(c) * d, a.target.geometry.position.y + 15 + 10 * Math.random(), a.spell.position.z + Math.sin(c) * d),
                                    timeout: 2,
                                    movespeed: 12,
                                    geometry: new THREE.Mesh(Cc.frostcallblizz.geo, mc.mage_ice)
                                });
                            Ya.push(e)
                        }
                }
            }),
            3: new q(3, this, {
                name: "Teleport",
                description: "Teleports you forward in an instant.",
                icon: "data/skill/mage_tp.jpg",
                targettype: "none",
                casttype: "instant",
                cooldown: 9,
                effecttype: "instant",
                maxrange: 100,
                predict: !1,
                effect: function(a) {
                    var b = z(a.source.rotation);
                    a.source.position.x += 25 * b.x, a.source.position.z += 25 * b.y, ya && (this.parent.ignoreMovement = .5), ya || a.source.animationQueue.push(new M({
                        id: "channel",
                        duration: .5
                    }))
                }
            }),
            4: new q(4, this, {
                name: "Iceblock",
                description: "Freezes you in an iceblock, rendering you invincible for a moment and recovering a portion of your health.",
                icon: "data/skill/mage_iceblock.jpg",
                targettype: "none",
                casttype: "instant",
                cooldown: 18,
                effecttype: "channel",
                channelDuration: 5,
                channelInterval: 8,
                channelInstantFirstTick: !0,
                channelMoveInterrupt: !1,
                spellchannel: !0,
                maxrange: 100,
                predict: !1,
                ignoreEc: !0,
                spell: function(a, b, c) {
                    return new p({
                        name: "Iceblock",
                        startposition: ya ? b.position : b.geometry.position,
                        source: b,
                        mode: "static",
                        effect: c,
                        timeout: 5,
                        geometry: ya ? void 0 : new THREE.Mesh(Cc.iceblock.geo, mc.mage_frost)
                    })
                },
                effect: function(a) {
                    var b = this.abilitypower;
                    a.source.stats.addMod(new s(a.source, a.source, {
                        duration: 5,
                        name: "Iceblock",
                        invincible: !0,
                        interval: 1,
                        id: "iceblock",
                        overwrite: !0,
                        movespeed: function() {
                            return 0
                        },
                        effect: function() {
                            Xa.damage({
                                attacker: this.source,
                                target: this.target,
                                spread: .1,
                                basedmg: this.target.stats.maxhp * (.035 + .03 * b),
                                scaledmg: 0,
                                heal: !0
                            })
                        }
                    })), a.source.walkForward = 0, a.source.walkSideward = 0
                },
                channelAnim: ya ? void 0 : new M({
                    id: "channel",
                    duration: 60
                })
            })
        }
    }

    function K(a) {
        this.level = a, this.type = "archer", ya || (this.color = mc.archer), this.getDefense = function() {
            return .8
        }, this.getMaxHp = function() {
            return parseInt(1.2 * Math.pow(12 + 1.5 * this.level, 1.9))
        }, this.skills = {
            1: new q(1, this, {
                name: "Piercing Shot",
                description: "Fires an arrow at your target. Pierces their armor up to 5 times, increasing your next Piercing Shot damage by 18%",
                icon: "data/skill/archer_pierce.jpg",
                targettype: "enemy",
                casttype: "instant",
                baselevel: 1,
                maxrange: 30,
                simulate: !0,
                spell: function(a, b, c) {
                    if (!ya) {
                        var d = new THREE.Mesh(Cc.archer_arrow.geo, mc.archer_arrow);
                        d.scale.set(Cc.archer_arrow.scale[0], Cc.archer_arrow.scale[1], Cc.archer_arrow.scale[2])
                    }
                    return new p({
                        name: "Pierce Shot",
                        target: a,
                        source: b,
                        effect: c,
                        mode: "follow",
                        movespeed: 80,
                        geometry: d ? d : void 0,
                        ribbon: ya ? void 0 : {
                            deleteWithSpell: !1,
                            parent: d,
                            stepInterval: .05,
                            steps: 5,
                            timeout: 1,
                            material: mc.ribbon_arrow,
                            aPos: new THREE.Vector3(.6, 0, 0),
                            bPos: new THREE.Vector3(-.6, -0, 0)
                        }
                    })
                },
                effect: function(a) {
                    if (a.target) {
                        var b = 1 + .18 * a.target.stats.queryMod({
                            source: a.source,
                            id: "pierceshot"
                        }).length;
                        Xa.damage({
                            scaledmg: (.6 + .55 * this.abilitypower) * b,
                            basedmg: 20 * b,
                            attacker: a.source,
                            target: a.target,
                            mod: {
                                id: "pierceshot",
                                duration: 6
                            }
                        })
                    }
                },
                characterAnim: function() {
                    return new M({
                        id: "release_spell",
                        duration: .3
                    })
                }
            }),
            2: new q(2, this, {
                name: "Volley",
                icon: "data/skill/archer_volley.jpg",
                description: "Shoot all targets infront of you over a duration.",
                targettype: "enemy",
                casttype: "instant",
                cooldown: 6,
                effecttype: "channel",
                channelInterval: ya ? .3 : .1,
                channelDuration: 3,
                channelMoveInterrupt: !1,
                channelInstantFirstTick: !0,
                maxrange: 30,
                predict: !1,
                allowDeadTarget: !0,
                effect: function() {
                    Xa.damage({
                        scaledmg: .2 + .25 * this.abilitypower,
                        basedmg: 10,
                        spread: .2,
                        attacker: this.parent,
                        mode: "aoe",
                        aoeRange: 33,
                        aoeArc: .7,
                        aoeFun: ya ? void 0 : function(a, b) {
                            if (!(a.length <= 0)) {
                                var c = new THREE.Mesh(Cc.archer_arrow.geo, mc.archer_arrow);
                                c.scale.set(Cc.archer_arrow.scale[0], Cc.archer_arrow.scale[1], Cc.archer_arrow.scale[2]);
                                var d = new p({
                                    name: "Volley",
                                    target: Ia(a),
                                    source: b,
                                    mode: "follow",
                                    movespeed: 50,
                                    geometry: c,
                                    ribbon: {
                                        deleteWithSpell: !1,
                                        parent: c,
                                        stepInterval: .05,
                                        steps: 5,
                                        timeout: 1,
                                        material: mc.ribbon_arrow,
                                        aPos: new THREE.Vector3(.6, 0, 0),
                                        bPos: new THREE.Vector3(-.6, -0, 0)
                                    }
                                });
                                Ya.push(d)
                            }
                        }
                    })
                },
                channelAnim: ya ? void 0 : new M({
                    id: "release_spell",
                    duration: .1,
                    type: "loop"
                })
            }),
            3: new q(3, this, {
                name: "Leeching Arrow",
                description: "Fires a condemned arrow at your enemy, reducing their healing and stealing some of their health.",
                icon: "data/skill/archer_siphon.jpg",
                targettype: "enemy",
                casttype: "instant",
                maxrange: 30,
                cooldown: 14,
                simulate: !0,
                spell: function(a, b, c) {
                    if (!ya) var d = new THREE.Object3D;
                    return new p({
                        name: "Leeching Arrow",
                        target: a,
                        source: b,
                        effect: c,
                        mode: "follow",
                        movespeed: 55,
                        geometry: d ? d : void 0,
                        ribbon: ya ? void 0 : {
                            deleteWithSpell: !1,
                            parent: d,
                            stepInterval: .05,
                            steps: 10,
                            timeout: 3,
                            tailType: "default",
                            material: mc.ribbon_leech,
                            aPos: new THREE.Vector3(1.5, 0, 0),
                            bPos: new THREE.Vector3(-1.5, -0, 0)
                        }
                    })
                },
                effect: function(a) {
                    var b = this.abilitypower,
                        c = 1.2 + .5 * b;
                    Xa.damage({
                        scaledmg: c,
                        basedmg: 20,
                        attacker: a.source,
                        target: a.target,
                        mod: {
                            id: "leeching",
                            unique: !0,
                            duration: 6,
                            name: "Leeching Arrow",
                            healmod: function(a) {
                                return a * (.5 / b * .7 + .3)
                            }
                        }
                    }), Xa.damage({
                        scaledmg: 2 * c,
                        basedmg: 20,
                        attacker: a.source,
                        target: a.source,
                        heal: !0
                    })
                },
                characterAnim: function() {
                    return new M({
                        id: "release_spell",
                        duration: .3
                    })
                }
            }),
            4: new q(4, this, {
                name: "Sprint",
                description: "You sprint at a very high speed for a short moment.",
                icon: "data/skill/archer_sprint.jpg",
                targettype: "none",
                casttype: "instant",
                cooldown: 5,
                effect: function(a) {
                    Xa.damage({
                        attacker: a.source,
                        target: a.source,
                        buff: !0,
                        mod: {
                            id: "windrush",
                            unique: !0,
                            duration: .6,
                            name: "Wind rush",
                            movespeed: function(a) {
                                return 30
                            }
                        }
                    })
                },
                characterAnim: function() {
                    return new M({
                        id: "release_buff",
                        duration: 1
                    })
                }
            })
        }
    }

    function L(a) {
        this.level = a, this.type = "shaman", ya || (this.color = mc.shaman), this.getDefense = function() {
            return .8
        }, this.getMaxHp = function() {
            return parseInt(1.2 * Math.pow(12 + 1.5 * this.level, 1.9))
        }, this.skills = {
            1: new q(1, this, {
                name: "Healing ritual",
                description: "Heals your target upon cast and for a short while afterwards.",
                icon: "data/skill/shaman_heal.jpg",
                targettype: "friendly",
                casttype: "timed",
                casttime: .6,
                baselevel: 1,
                maxrange: 30,
                effect: function() {
                    var a = this.abilitypower;
                    Xa.damage({
                        scaledmg: 1.1 + .2 * a,
                        basedmg: 4 + 1.8 * a,
                        spread: .2,
                        attacker: this.parent,
                        target: this.casttarget,
                        heal: !0,
                        mod: {
                            id: "healritual",
                            overwrite: !0,
                            duration: 10,
                            interval: 1,
                            effect: function() {
                                Xa.damage({
                                    attacker: this.source,
                                    target: this.target,
                                    spread: .1,
                                    basedmg: 3 + .8 * a,
                                    scaledmg: .5 + .3 * a,
                                    heal: !0
                                })
                            }
                        }
                    })
                },
                spell: ya ? void 0 : function(a, b, c) {
                    if (a && b) {
                        var d = new THREE.Object3D;
                        return new p({
                            name: "Healing ritual",
                            mode: "attach",
                            target: a,
                            source: b,
                            timeout: 10,
                            geometry: d,
                            tick: function(b) {
                                this.geometry.position.copy(this.position);
                                var c = .15 + a.stats.scale;
                                this.geometry.position.x += Math.sin(8 * this.timeout) * c, this.geometry.position.z += Math.cos(8 * this.timeout) * c, this.geometry.position.y += Math.cos(5 + 6 * this.timeout) * c * .5, c *= .5, this.geometry.scale.set(c, c, c)
                            },
                            ribbon: {
                                deleteWithSpell: !0,
                                parent: d,
                                stepInterval: .1,
                                steps: 8,
                                timeout: 10,
                                material: mc.ribbon_heal,
                                aPos: new THREE.Vector3(1.5, 0, 0),
                                bPos: new THREE.Vector3(-1.5, -0, 0)
                            }
                        })
                    }
                },
                characterAnim: function() {
                    return new M({
                        id: "release_buff",
                        duration: .5
                    })
                }
            }),
            2: new q(2, this, {
                name: "Equilibrate",
                description: "Summons a spirit upon a friendly target that heals allys and damages enemies",
                icon: "data/skill/shaman_spirit.jpg",
                targettype: "friendly",
                casttype: "instant",
                maxrange: 30,
                channelInstantFirstTick: !0,
                unique: !0,
                simulate: !0,
                effect: function(a) {
                    var b = this.abilitypower;
                    Xa.damage({
                        scaledmg: .3 + .15 * b,
                        basedmg: 2 + b,
                        spread: .2,
                        attacker: a.source,
                        target: a.target,
                        heal: !0
                    }), Xa.damage({
                        scaledmg: .4 + .3 * b,
                        basedmg: 2 + b,
                        spread: .1,
                        attacker: a.source,
                        mode: "aoe",
                        aoeRange: 8,
                        aoeCenter: a.spell.position
                    })
                },
                spell: function(a, b, c) {
                    var d = void 0;
                    b.position;
                    return ya || (d = new THREE.Mesh(Cc.equilibrate.geo, mc.equilibrate), d.scale.set(Cc.equilibrate.scale[0], Cc.equilibrate.scale[1], Cc.equilibrate.scale[2])), new p({
                        name: "Spirit",
                        mode: "attach",
                        target: a,
                        source: b,
                        effect: c,
                        effectInterval: 1,
                        timeout: 60,
                        geometry: d,
                        tick: ya ? void 0 : function(b) {
                            this.geometry.position.copy(this.position);
                            var c = .35 + a.stats.scale;
                            this.geometry.position.x += Math.sin(4 * this.timeout) * c, this.geometry.position.z += Math.cos(4 * this.timeout) * c, this.geometry.rotation.x += 3 * b, this.geometry.rotation.z -= 2 * b, this.geometry.rotation.y = 1.5 * b, c *= .4, this.geometry.scale.set(c, c, c)
                        },
                        ribbon: ya ? void 0 : {
                            deleteWithSpell: !0,
                            parent: d,
                            stepInterval: .05,
                            steps: 5,
                            timeout: 60,
                            material: mc.ribbon_arrow,
                            aPos: new THREE.Vector3(.6, 0, 0),
                            bPos: new THREE.Vector3(-.6, -0, 0)
                        }
                    })
                }
            }),
            3: new q(3, this, {
                name: "Decay",
                icon: "data/skill/shaman_decay.jpg",
                description: "Cast a spell of decay upon your enemy, slowing their movement and dealing damage over time.",
                targettype: "enemy",
                casttype: "instant",
                baselevel: 1,
                maxrange: 25,
                simulate: !0,
                effect: function(a) {
                    var b = this.abilitypower;
                    Xa.damage({
                        attacker: a.source,
                        target: a.target,
                        debuff: !0,
                        mod: {
                            overwrite: !0,
                            id: "decay",
                            duration: 8,
                            name: "Decay",
                            interval: 1,
                            effect: function() {
                                Xa.damage({
                                    attacker: this.source,
                                    target: this.target,
                                    spread: .1,
                                    basedmg: 16 + 2 * b,
                                    scaledmg: .25 + .25 * b
                                })
                            }
                        }
                    }), Xa.damage({
                        attacker: a.source,
                        target: a.target,
                        debuff: !0,
                        mod: {
                            unique: !0,
                            id: "decayslow",
                            duration: 8,
                            name: "Decay",
                            movespeed: function(a) {
                                return .7 * a
                            }
                        }
                    })
                },
                spell: ya ? void 0 : function(a, b, c) {
                    if (a && b && a != b) {
                        var d = new THREE.Object3D;
                        return new p({
                            name: "Decay",
                            mode: "attach",
                            target: a,
                            source: b,
                            timeout: 10,
                            geometry: d,
                            tick: function(b) {
                                this.geometry.position.copy(this.position);
                                var c = .15 + a.stats.scale;
                                this.geometry.position.x += Math.sin(8 * this.timeout) * c, this.geometry.position.z += Math.cos(8 * this.timeout) * c, this.geometry.position.y += Math.cos(5 + 6 * this.timeout) * c * .5, c *= .5, this.geometry.scale.set(c, c, c)
                            },
                            ribbon: {
                                deleteWithSpell: !0,
                                parent: d,
                                stepInterval: .1,
                                steps: 8,
                                timeout: 10,
                                material: mc.ribbon_decay,
                                aPos: new THREE.Vector3(1.5, 0, 0),
                                bPos: new THREE.Vector3(-1.5, -0, 0)
                            }
                        })
                    }
                },
                characterAnim: function() {
                    return new M({
                        id: "release_buff",
                        duration: 1
                    })
                }
            }),
            4: new q(4, this, {
                name: "Wind rush",
                description: "Temporarily boost the movement speed of you and your allies.",
                icon: "data/skill/shaman_windrush.jpg",
                targettype: "none",
                casttype: "instant",
                cooldown: 20,
                maxrange: 30,
                simulate: !0,
                effect: function(a) {
                    Xa.damage({
                        attacker: a.source,
                        buff: !0,
                        mode: "aoe",
                        aoeRange: 30,
                        mod: {
                            id: "windrush",
                            unique: !0,
                            duration: 6,
                            name: "Wind rush",
                            movespeed: function(a) {
                                return 1.5 * a
                            }
                        }
                    })
                },
                characterAnim: function() {
                    return new M({
                        id: "release_buff",
                        duration: 1
                    })
                }
            })
        }
    }

    function M(a) {
        this.id = a.id || "idle", this.type = a.type || "timed", this.duration = a.duration || 1, this.timer = this.duration, this.deleteMe = !1
    }

    function N(a, b) {
        for (var c = 0; c < ib.length; c++)
            if (a >= ib[c].value) return (a / ib[c].value).toFixed(b).replace(jb, "$1") + ib[c].symbol;
        return a.toFixed(b).replace(jb, "$1")
    }

    function O() {
        if (ub.expbar && Zb) {
            ub.expbartext.html(Zb.class.exp + " / " + Zb.class.nextLevelExp);
            var a = Math.min(100, Zb.class.exp / Zb.class.nextLevelExp * 100);
            ub.expbar.css("width", a + "%")
        }
    }

    function P() {
        var a;
        ub.castbar && Zb && 1 == Zb.state.id ? (a = 100 - Zb.state.duration / Zb.state.maxduration * 100, ub.castbarcontainer.show()) : (ub.castbarcontainer.hide(), a = 0), ub.castbar.css("width", a + "%")
    }

    function Q(a) {
        if (ub.chatboxWrapper) {
            var b = a.msg || "Message error.",
                c = "chatmsg";
            if (a.src) switch (a.src) {
                case "server":
                case "whisper":
                    c += " chatmsg-w";
                    break;
                case "playerkill":
                    if (!kb(sa.get("chat-pvp"))) return;
                    c += " chatmsg-pk";
                    break;
                case "death":
                    c += " chatmsg-death";
                    break;
                case "system":
                    c += " chatmsg-system";
                    break;
                case "loot":
                    if (!kb(sa.get("chat-loot"))) return;
                    c += " chatmsg-loot";
                    break;
                case "exp":
                    if (!kb(sa.get("chat-exp"))) return;
                    c += " chatmsg-exp";
                    break;
                case "local":
                    if (!kb(sa.get("chat-chat"))) return;
                    if (c += " chatmsg-player", !a.name) return !1;
                    b = "[" + a.name + "]: " + b;
                    break;
                case "global":
                    if (!kb(sa.get("chat-chat"))) return;
                    if (c += " chatmsg-global", !a.name) return !1;
                    b = "[" + a.name + " (global)]: " + b
            }
            var d = ub.chatboxWrapper[0].scrollHeight - ub.chatboxWrapper[0].scrollTop === ub.chatboxWrapper[0].clientHeight,
                e = $("<p class='" + c + "'></p>");
            e.text(b), e.html(e.html().replace("$g", vb.goldCoin)), e.html(e.html().replace("$0", vb.faction1)), e.html(e.html().replace("$1", vb.faction2)), e.appendTo(ub.chatboxBody);
            var f = $("#chatboxBody > p");
            f.length > 50 && f[0].remove(), d && ub.chatboxWrapper.scrollTop(ub.chatboxWrapper[0].scrollHeight)
        }
    }

    function R() {
        "undefined" != typeof aipPlayer && (adplayer = new aipPlayer({
            AD_WIDTH: 960,
            AD_HEIGHT: 540,
            AD_FULLSCREEN: !0,
            PREROLL_ELEM: document.getElementById("preroll"),
            AIP_COMPLETE: function() {
                xb()
            },
            AIP_REMOVE: function() {}
        })), xb = function() {
            yb(), sa.set("lastAd", Date.now())
        }, yb = function() {
            ad(Uc)
        }
    }

    function S(a, b) {
        var c = document.head || document.getElementsByTagName("head")[0],
            d = document.createElement("script"),
            e = !0;
        d.async = "async", d.type = "text/javascript", d.charset = "UTF-8", d.src = a, d.onload = d.onreadystatechange = function() {
            !e || d.readyState && !/loaded|complete/.test(d.readyState) || (e = !1, b(), d.onload = d.onreadystatechange = null)
        }, c.appendChild(d)
    }

    function T(a) {
        var b = document.createElement("canvas");
        b.width = a.width, b.height = a.height;
        var c = b.getContext("2d");
        return c.drawImage(a, 0, 0), c.getImageData(0, 0, a.width, a.height)
    }

    function U(a, b, c) {
        return a <= b ? b : a >= c ? c : a
    }

    function V(a, b) {
        a = U(a, 0, ya ? heightmap.shape[0] : Pb.width - 1), b = U(b, 0, ya ? heightmap.shape[0] : Pb.width - 1);
        var c = ya ? 4 * (a + heightmap.shape[0] * b) : 4 * (a + Pb.width * b),
            d = ya ? heightmap.data : Pb.data;
        return {
            r: d[c],
            g: d[c + 1],
            b: d[c + 2],
            a: d[c + 3]
        }
    }

    function W(a) {
        if (!a.material) return !1;
        this.steps = a.steps || 10, this.stepInterval = a.stepInterval || .5, this.stepIntervalTimer = this.stepInterval, this.stepsDone = 0, this.headType = a.headType || "glue", this.tailType = a.tailType || "compress", this.geom = new THREE.PlaneGeometry(1, 1, 1, this.steps - 1), this.material = a.material, this.mesh = new THREE.Mesh(this.geom, this.material), this.mesh.frustumCulled = !1, Rb.add(this.mesh), this.timeout = a.timeout || void 0, this.timeout && (this.timer = this.timeout), this.a = new THREE.Object3D, Rb.add(this.a), this.b = new THREE.Object3D, Rb.add(this.b),
            a.parent && (a.parent.add(this.a), a.parent.add(this.b), a.parent.updateMatrixWorld()), a.aPos && this.a.position.copy(a.aPos), a.bPos && this.b.position.copy(a.bPos), this.at = [];
        var b = this.a.getWorldPosition();
        this.bt = [];
        for (var c = this.b.getWorldPosition(), d = 0; d < this.steps; ++d) this.at.push(new THREE.Vector3(b.x, b.y, b.z)), this.bt.push(new THREE.Vector3(c.x, c.y, c.z));
        this.step(b, c), this.uvStepSize = 1 / this.steps, this.uvShift = 0, this.deleteMe = !1
    }

    function X(a) {
        "use strict";
        var b, c = a.children;
        if (c)
            for (var d = 0; d < c.length; d += 1) b = c[d], X(b)
    }

    function Y(a, b) {
        var c = new THREE.Vector3,
            d = .5 * ca.width,
            e = .5 * ca.height;
        return c.copy(a), c.project(b), c.x = Math.round(c.x * d), c.y = Math.round(c.y * e), c
    }

    function Z() {
        this.isresetting = 0, this.goal = new THREE.Vector2(0, 0), this.hasReachedGoal = !1, this.tick = function(a) {
            if (this.parent.target && !ca.entities.hasOwnProperty(this.parent.target.id) && (this.parent.desiredTarget = this.parent.target.id, this.parent.target = void 0), this.parent.target) {
                var b = Ta(this.parent.target, this.parent),
                    c = void 0 !== b && b.distance() < this.parent.class.skills[1].maxrange + 1.2;
                this.parent.walkForward = c ? 0 : 1, this.parent.rotation = B(this.parent, this.parent.target)
            } else this.parent.walkForward = 0, 0 == this.goal.x || 0 == this.goal.z || this.hasReachedGoal || (C(this.parent, this.goal) > this.parent.stats.movespeed * a ? (this.parent.walkForward = 1, this.parent.rotation = A(this.parent.position, this.goal)) : (this.parent.walkForward = 0, this.hasReachedGoal = !0))
        }
    }

    function _(a) {
        var b = fd[a];
        if (!b) {
            var c = document.getElementsByTagName("body")[0],
                d = document.createElement("div"),
                e = document.createTextNode("Mq");
            d.appendChild(e), d.setAttribute("style", "font:" + a + ";position:absolute;top:0;left:0"), c.appendChild(d), b = d.offsetHeight, fd[a] = b, c.removeChild(d)
        }
        return b
    }

    function aa() {
        return this.textWidth = null, this.textHeight = null, this.canvas = document.createElement("canvas"), this.ctx = this.canvas.getContext("2d"), this
    }

    function ba(a, b) {
        THREE.Object3D.call(this), this._font = b.font || "30px Arial", this._fillStyle = b.fillStyle || "#FFFFFF", this._outlineSize = b.outlineSize || 0, this._outlineStyle = b.outlineStyle || "black", this.canvas = new aa, this.align = b.align || ed.center, this.antialias = ("undefined" === b.antialias, !0), this.setText(a)
    }
    if (! function(a, b) {
            "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
                if (!a.document) throw new Error("jQuery requires a window with a document");
                return b(a)
            } : b(a)
        }("undefined" != typeof window ? window : this, function(a, b) {
            function c(a) {
                var b = !!a && "length" in a && a.length,
                    c = fa.type(a);
                return "function" !== c && !fa.isWindow(a) && ("array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a)
            }

            function d(a, b, c) {
                if (fa.isFunction(b)) return fa.grep(a, function(a, d) {
                    return !!b.call(a, d, a) !== c
                });
                if (b.nodeType) return fa.grep(a, function(a) {
                    return a === b !== c
                });
                if ("string" == typeof b) {
                    if (pa.test(b)) return fa.filter(b, a, c);
                    b = fa.filter(b, a)
                }
                return fa.grep(a, function(a) {
                    return _.call(b, a) > -1 !== c
                })
            }

            function e(a, b) {
                for (;
                    (a = a[b]) && 1 !== a.nodeType;);
                return a
            }

            function f(a) {
                var b = {};
                return fa.each(a.match(va) || [], function(a, c) {
                    b[c] = !0
                }), b
            }

            function g() {
                X.removeEventListener("DOMContentLoaded", g), a.removeEventListener("load", g), fa.ready()
            }

            function h() {
                this.expando = fa.expando + h.uid++
            }

            function i(a, b, c) {
                var d;
                if (void 0 === c && 1 === a.nodeType)
                    if (d = "data-" + b.replace(Ca, "-$&").toLowerCase(), c = a.getAttribute(d), "string" == typeof c) {
                        try {
                            c = "true" === c || "false" !== c && ("null" === c ? null : +c + "" === c ? +c : Ba.test(c) ? fa.parseJSON(c) : c)
                        } catch (a) {}
                        Aa.set(a, b, c)
                    } else c = void 0;
                return c
            }

            function j(a, b, c, d) {
                var e, f = 1,
                    g = 20,
                    h = d ? function() {
                        return d.cur()
                    } : function() {
                        return fa.css(a, b, "")
                    },
                    i = h(),
                    j = c && c[3] || (fa.cssNumber[b] ? "" : "px"),
                    k = (fa.cssNumber[b] || "px" !== j && +i) && Ea.exec(fa.css(a, b));
                if (k && k[3] !== j) {
                    j = j || k[3], c = c || [], k = +i || 1;
                    do f = f || ".5", k /= f, fa.style(a, b, k + j); while (f !== (f = h() / i) && 1 !== f && --g)
                }
                return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e
            }

            function k(a, b) {
                var c = "undefined" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || "*") : "undefined" != typeof a.querySelectorAll ? a.querySelectorAll(b || "*") : [];
                return void 0 === b || b && fa.nodeName(a, b) ? fa.merge([a], c) : c
            }

            function l(a, b) {
                for (var c = 0, d = a.length; d > c; c++) za.set(a[c], "globalEval", !b || za.get(b[c], "globalEval"))
            }

            function m(a, b, c, d, e) {
                for (var f, g, h, i, j, m, n = b.createDocumentFragment(), o = [], p = 0, q = a.length; q > p; p++)
                    if (f = a[p], f || 0 === f)
                        if ("object" === fa.type(f)) fa.merge(o, f.nodeType ? [f] : f);
                        else if (La.test(f)) {
                    for (g = g || n.appendChild(b.createElement("div")), h = (Ia.exec(f) || ["", ""])[1].toLowerCase(), i = Ka[h] || Ka._default, g.innerHTML = i[1] + fa.htmlPrefilter(f) + i[2], m = i[0]; m--;) g = g.lastChild;
                    fa.merge(o, g.childNodes), g = n.firstChild, g.textContent = ""
                } else o.push(b.createTextNode(f));
                for (n.textContent = "", p = 0; f = o[p++];)
                    if (d && fa.inArray(f, d) > -1) e && e.push(f);
                    else if (j = fa.contains(f.ownerDocument, f), g = k(n.appendChild(f), "script"), j && l(g), c)
                    for (m = 0; f = g[m++];) Ja.test(f.type || "") && c.push(f);
                return n
            }

            function n() {
                return !0
            }

            function o() {
                return !1
            }

            function p() {
                try {
                    return X.activeElement
                } catch (a) {}
            }

            function q(a, b, c, d, e, f) {
                var g, h;
                if ("object" == typeof b) {
                    "string" != typeof c && (d = d || c, c = void 0);
                    for (h in b) q(a, h, c, d, b[h], f);
                    return a
                }
                if (null == d && null == e ? (e = c, d = c = void 0) : null == e && ("string" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1) e = o;
                else if (!e) return a;
                return 1 === f && (g = e, e = function(a) {
                    return fa().off(a), g.apply(this, arguments)
                }, e.guid = g.guid || (g.guid = fa.guid++)), a.each(function() {
                    fa.event.add(this, b, e, d, c)
                })
            }

            function r(a, b) {
                return fa.nodeName(a, "table") && fa.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a
            }

            function s(a) {
                return a.type = (null !== a.getAttribute("type")) + "/" + a.type, a
            }

            function t(a) {
                var b = Sa.exec(a.type);
                return b ? a.type = b[1] : a.removeAttribute("type"), a
            }

            function u(a, b) {
                var c, d, e, f, g, h, i, j;
                if (1 === b.nodeType) {
                    if (za.hasData(a) && (f = za.access(a), g = za.set(b, f), j = f.events)) {
                        delete g.handle, g.events = {};
                        for (e in j)
                            for (c = 0, d = j[e].length; d > c; c++) fa.event.add(b, e, j[e][c])
                    }
                    Aa.hasData(a) && (h = Aa.access(a), i = fa.extend({}, h), Aa.set(b, i))
                }
            }

            function v(a, b) {
                var c = b.nodeName.toLowerCase();
                "input" === c && Ha.test(a.type) ? b.checked = a.checked : "input" !== c && "textarea" !== c || (b.defaultValue = a.defaultValue)
            }

            function w(a, b, c, d) {
                b = Z.apply([], b);
                var e, f, g, h, i, j, l = 0,
                    n = a.length,
                    o = n - 1,
                    p = b[0],
                    q = fa.isFunction(p);
                if (q || n > 1 && "string" == typeof p && !da.checkClone && Ra.test(p)) return a.each(function(e) {
                    var f = a.eq(e);
                    q && (b[0] = p.call(this, e, f.html())), w(f, b, c, d)
                });
                if (n && (e = m(b, a[0].ownerDocument, !1, a, d), f = e.firstChild, 1 === e.childNodes.length && (e = f), f || d)) {
                    for (g = fa.map(k(e, "script"), s), h = g.length; n > l; l++) i = e, l !== o && (i = fa.clone(i, !0, !0), h && fa.merge(g, k(i, "script"))), c.call(a[l], i, l);
                    if (h)
                        for (j = g[g.length - 1].ownerDocument, fa.map(g, t), l = 0; h > l; l++) i = g[l], Ja.test(i.type || "") && !za.access(i, "globalEval") && fa.contains(j, i) && (i.src ? fa._evalUrl && fa._evalUrl(i.src) : fa.globalEval(i.textContent.replace(Ta, "")))
                }
                return a
            }

            function x(a, b, c) {
                for (var d, e = b ? fa.filter(b, a) : a, f = 0; null != (d = e[f]); f++) c || 1 !== d.nodeType || fa.cleanData(k(d)), d.parentNode && (c && fa.contains(d.ownerDocument, d) && l(k(d, "script")), d.parentNode.removeChild(d));
                return a
            }

            function y(a, b) {
                var c = fa(b.createElement(a)).appendTo(b.body),
                    d = fa.css(c[0], "display");
                return c.detach(), d
            }

            function z(a) {
                var b = X,
                    c = Va[a];
                return c || (c = y(a, b), "none" !== c && c || (Ua = (Ua || fa("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), b = Ua[0].contentDocument, b.write(), b.close(), c = y(a, b), Ua.detach()), Va[a] = c), c
            }

            function A(a, b, c) {
                var d, e, f, g, h = a.style;
                return c = c || Ya(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, "" !== g && void 0 !== g || fa.contains(a.ownerDocument, a) || (g = fa.style(a, b)), c && !da.pixelMarginRight() && Xa.test(g) && Wa.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f), void 0 !== g ? g + "" : g
            }

            function B(a, b) {
                return {
                    get: function() {
                        return a() ? void delete this.get : (this.get = b).apply(this, arguments)
                    }
                }
            }

            function C(a) {
                if (a in db) return a;
                for (var b = a[0].toUpperCase() + a.slice(1), c = cb.length; c--;)
                    if (a = cb[c] + b, a in db) return a
            }

            function D(a, b, c) {
                var d = Ea.exec(b);
                return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || "px") : b
            }

            function E(a, b, c, d, e) {
                for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2) "margin" === c && (g += fa.css(a, c + Fa[f], !0, e)), d ? ("content" === c && (g -= fa.css(a, "padding" + Fa[f], !0, e)), "margin" !== c && (g -= fa.css(a, "border" + Fa[f] + "Width", !0, e))) : (g += fa.css(a, "padding" + Fa[f], !0, e), "padding" !== c && (g += fa.css(a, "border" + Fa[f] + "Width", !0, e)));
                return g
            }

            function F(a, b, c) {
                var d = !0,
                    e = "width" === b ? a.offsetWidth : a.offsetHeight,
                    f = Ya(a),
                    g = "border-box" === fa.css(a, "boxSizing", !1, f);
                if (0 >= e || null == e) {
                    if (e = A(a, b, f), (0 > e || null == e) && (e = a.style[b]), Xa.test(e)) return e;
                    d = g && (da.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0
                }
                return e + E(a, b, c || (g ? "border" : "content"), d, f) + "px"
            }

            function G(a, b) {
                for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) d = a[g], d.style && (f[g] = za.get(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && Ga(d) && (f[g] = za.access(d, "olddisplay", z(d.nodeName)))) : (e = Ga(d), "none" === c && e || za.set(d, "olddisplay", e ? c : fa.css(d, "display"))));
                for (g = 0; h > g; g++) d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
                return a
            }

            function H(a, b, c, d, e) {
                return new H.prototype.init(a, b, c, d, e)
            }

            function I() {
                return a.setTimeout(function() {
                    eb = void 0
                }), eb = fa.now()
            }

            function J(a, b) {
                var c, d = 0,
                    e = {
                        height: a
                    };
                for (b = b ? 1 : 0; 4 > d; d += 2 - b) c = Fa[d], e["margin" + c] = e["padding" + c] = a;
                return b && (e.opacity = e.width = a), e
            }

            function K(a, b, c) {
                for (var d, e = (N.tweeners[b] || []).concat(N.tweeners["*"]), f = 0, g = e.length; g > f; f++)
                    if (d = e[f].call(c, b, a)) return d
            }

            function L(a, b, c) {
                var d, e, f, g, h, i, j, k, l = this,
                    m = {},
                    n = a.style,
                    o = a.nodeType && Ga(a),
                    p = za.get(a, "fxshow");
                c.queue || (h = fa._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function() {
                    h.unqueued || i()
                }), h.unqueued++, l.always(function() {
                    l.always(function() {
                        h.unqueued--, fa.queue(a, "fx").length || h.empty.fire()
                    })
                })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [n.overflow, n.overflowX, n.overflowY], j = fa.css(a, "display"), k = "none" === j ? za.get(a, "olddisplay") || z(a.nodeName) : j, "inline" === k && "none" === fa.css(a, "float") && (n.display = "inline-block")), c.overflow && (n.overflow = "hidden", l.always(function() {
                    n.overflow = c.overflow[0], n.overflowX = c.overflow[1], n.overflowY = c.overflow[2]
                }));
                for (d in b)
                    if (e = b[d], gb.exec(e)) {
                        if (delete b[d], f = f || "toggle" === e, e === (o ? "hide" : "show")) {
                            if ("show" !== e || !p || void 0 === p[d]) continue;
                            o = !0
                        }
                        m[d] = p && p[d] || fa.style(a, d)
                    } else j = void 0;
                if (fa.isEmptyObject(m)) "inline" === ("none" === j ? z(a.nodeName) : j) && (n.display = j);
                else {
                    p ? "hidden" in p && (o = p.hidden) : p = za.access(a, "fxshow", {}), f && (p.hidden = !o), o ? fa(a).show() : l.done(function() {
                        fa(a).hide()
                    }), l.done(function() {
                        var b;
                        za.remove(a, "fxshow");
                        for (b in m) fa.style(a, b, m[b])
                    });
                    for (d in m) g = K(o ? p[d] : 0, d, l), d in p || (p[d] = g.start, o && (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0))
                }
            }

            function M(a, b) {
                var c, d, e, f, g;
                for (c in a)
                    if (d = fa.camelCase(c), e = b[d], f = a[c], fa.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = fa.cssHooks[d], g && "expand" in g) {
                        f = g.expand(f), delete a[d];
                        for (c in f) c in a || (a[c] = f[c], b[c] = e)
                    } else b[d] = e
            }

            function N(a, b, c) {
                var d, e, f = 0,
                    g = N.prefilters.length,
                    h = fa.Deferred().always(function() {
                        delete i.elem
                    }),
                    i = function() {
                        if (e) return !1;
                        for (var b = eb || I(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) j.tweens[g].run(f);
                        return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1)
                    },
                    j = h.promise({
                        elem: a,
                        props: fa.extend({}, b),
                        opts: fa.extend(!0, {
                            specialEasing: {},
                            easing: fa.easing._default
                        }, c),
                        originalProperties: b,
                        originalOptions: c,
                        startTime: eb || I(),
                        duration: c.duration,
                        tweens: [],
                        createTween: function(b, c) {
                            var d = fa.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
                            return j.tweens.push(d), d
                        },
                        stop: function(b) {
                            var c = 0,
                                d = b ? j.tweens.length : 0;
                            if (e) return this;
                            for (e = !0; d > c; c++) j.tweens[c].run(1);
                            return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this
                        }
                    }),
                    k = j.props;
                for (M(k, j.opts.specialEasing); g > f; f++)
                    if (d = N.prefilters[f].call(j, a, k, j.opts)) return fa.isFunction(d.stop) && (fa._queueHooks(j.elem, j.opts.queue).stop = fa.proxy(d.stop, d)), d;
                return fa.map(k, K, j), fa.isFunction(j.opts.start) && j.opts.start.call(a, j), fa.fx.timer(fa.extend(i, {
                    elem: a,
                    anim: j,
                    queue: j.opts.queue
                })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always)
            }

            function O(a) {
                return a.getAttribute && a.getAttribute("class") || ""
            }

            function P(a) {
                return function(b, c) {
                    "string" != typeof b && (c = b, b = "*");
                    var d, e = 0,
                        f = b.toLowerCase().match(va) || [];
                    if (fa.isFunction(c))
                        for (; d = f[e++];) "+" === d[0] ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c)
                }
            }

            function Q(a, b, c, d) {
                function e(h) {
                    var i;
                    return f[h] = !0, fa.each(a[h] || [], function(a, h) {
                        var j = h(b, c, d);
                        return "string" != typeof j || g || f[j] ? g ? !(i = j) : void 0 : (b.dataTypes.unshift(j), e(j), !1)
                    }), i
                }
                var f = {},
                    g = a === Ab;
                return e(b.dataTypes[0]) || !f["*"] && e("*")
            }

            function R(a, b) {
                var c, d, e = fa.ajaxSettings.flatOptions || {};
                for (c in b) void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);
                return d && fa.extend(!0, a, d), a
            }

            function S(a, b, c) {
                for (var d, e, f, g, h = a.contents, i = a.dataTypes;
                    "*" === i[0];) i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader("Content-Type"));
                if (d)
                    for (e in h)
                        if (h[e] && h[e].test(d)) {
                            i.unshift(e);
                            break
                        }
                if (i[0] in c) f = i[0];
                else {
                    for (e in c) {
                        if (!i[0] || a.converters[e + " " + i[0]]) {
                            f = e;
                            break
                        }
                        g || (g = e)
                    }
                    f = f || g
                }
                return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0
            }

            function T(a, b, c, d) {
                var e, f, g, h, i, j = {},
                    k = a.dataTypes.slice();
                if (k[1])
                    for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
                for (f = k.shift(); f;)
                    if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())
                        if ("*" === f) f = i;
                        else if ("*" !== i && i !== f) {
                    if (g = j[i + " " + f] || j["* " + f], !g)
                        for (e in j)
                            if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
                                g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
                                break
                            }
                    if (g !== !0)
                        if (g && a.throws) b = g(b);
                        else try {
                            b = g(b)
                        } catch (a) {
                            return {
                                state: "parsererror",
                                error: g ? a : "No conversion from " + i + " to " + f
                            }
                        }
                }
                return {
                    state: "success",
                    data: b
                }
            }

            function U(a, b, c, d) {
                var e;
                if (fa.isArray(b)) fa.each(b, function(b, e) {
                    c || Eb.test(a) ? d(a, e) : U(a + "[" + ("object" == typeof e && null != e ? b : "") + "]", e, c, d)
                });
                else if (c || "object" !== fa.type(b)) d(a, b);
                else
                    for (e in b) U(a + "[" + e + "]", b[e], c, d)
            }

            function V(a) {
                return fa.isWindow(a) ? a : 9 === a.nodeType && a.defaultView
            }
            var W = [],
                X = a.document,
                Y = W.slice,
                Z = W.concat,
                $ = W.push,
                _ = W.indexOf,
                aa = {},
                ba = aa.toString,
                ca = aa.hasOwnProperty,
                da = {},
                ea = "2.2.4",
                fa = function(a, b) {
                    return new fa.fn.init(a, b)
                },
                ga = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
                ha = /^-ms-/,
                ia = /-([\da-z])/gi,
                ja = function(a, b) {
                    return b.toUpperCase()
                };
            fa.fn = fa.prototype = {
                jquery: ea,
                constructor: fa,
                selector: "",
                length: 0,
                toArray: function() {
                    return Y.call(this)
                },
                get: function(a) {
                    return null != a ? 0 > a ? this[a + this.length] : this[a] : Y.call(this)
                },
                pushStack: function(a) {
                    var b = fa.merge(this.constructor(), a);
                    return b.prevObject = this, b.context = this.context, b
                },
                each: function(a) {
                    return fa.each(this, a)
                },
                map: function(a) {
                    return this.pushStack(fa.map(this, function(b, c) {
                        return a.call(b, c, b)
                    }))
                },
                slice: function() {
                    return this.pushStack(Y.apply(this, arguments))
                },
                first: function() {
                    return this.eq(0)
                },
                last: function() {
                    return this.eq(-1)
                },
                eq: function(a) {
                    var b = this.length,
                        c = +a + (0 > a ? b : 0);
                    return this.pushStack(c >= 0 && b > c ? [this[c]] : [])
                },
                end: function() {
                    return this.prevObject || this.constructor()
                },
                push: $,
                sort: W.sort,
                splice: W.splice
            }, fa.extend = fa.fn.extend = function() {
                var a, b, c, d, e, f, g = arguments[0] || {},
                    h = 1,
                    i = arguments.length,
                    j = !1;
                for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || fa.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++)
                    if (null != (a = arguments[h]))
                        for (b in a) c = g[b], d = a[b], g !== d && (j && d && (fa.isPlainObject(d) || (e = fa.isArray(d))) ? (e ? (e = !1, f = c && fa.isArray(c) ? c : []) : f = c && fa.isPlainObject(c) ? c : {}, g[b] = fa.extend(j, f, d)) : void 0 !== d && (g[b] = d));
                return g
            }, fa.extend({
                expando: "jQuery" + (ea + Math.random()).replace(/\D/g, ""),
                isReady: !0,
                error: function(a) {
                    throw new Error(a)
                },
                noop: function() {},
                isFunction: function(a) {
                    return "function" === fa.type(a)
                },
                isArray: Array.isArray,
                isWindow: function(a) {
                    return null != a && a === a.window
                },
                isNumeric: function(a) {
                    var b = a && a.toString();
                    return !fa.isArray(a) && b - parseFloat(b) + 1 >= 0
                },
                isPlainObject: function(a) {
                    var b;
                    if ("object" !== fa.type(a) || a.nodeType || fa.isWindow(a)) return !1;
                    if (a.constructor && !ca.call(a, "constructor") && !ca.call(a.constructor.prototype || {}, "isPrototypeOf")) return !1;
                    for (b in a);
                    return void 0 === b || ca.call(a, b)
                },
                isEmptyObject: function(a) {
                    var b;
                    for (b in a) return !1;
                    return !0
                },
                type: function(a) {
                    return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? aa[ba.call(a)] || "object" : typeof a
                },
                globalEval: function(a) {
                    var b, c = eval;
                    a = fa.trim(a), a && (1 === a.indexOf("use strict") ? (b = X.createElement("script"), b.text = a, X.head.appendChild(b).parentNode.removeChild(b)) : c(a))
                },
                camelCase: function(a) {
                    return a.replace(ha, "ms-").replace(ia, ja)
                },
                nodeName: function(a, b) {
                    return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase()
                },
                each: function(a, b) {
                    var d, e = 0;
                    if (c(a))
                        for (d = a.length; d > e && b.call(a[e], e, a[e]) !== !1; e++);
                    else
                        for (e in a)
                            if (b.call(a[e], e, a[e]) === !1) break;
                    return a
                },
                trim: function(a) {
                    return null == a ? "" : (a + "").replace(ga, "")
                },
                makeArray: function(a, b) {
                    var d = b || [];
                    return null != a && (c(Object(a)) ? fa.merge(d, "string" == typeof a ? [a] : a) : $.call(d, a)), d
                },
                inArray: function(a, b, c) {
                    return null == b ? -1 : _.call(b, a, c)
                },
                merge: function(a, b) {
                    for (var c = +b.length, d = 0, e = a.length; c > d; d++) a[e++] = b[d];
                    return a.length = e, a
                },
                grep: function(a, b, c) {
                    for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) d = !b(a[f], f), d !== h && e.push(a[f]);
                    return e
                },
                map: function(a, b, d) {
                    var e, f, g = 0,
                        h = [];
                    if (c(a))
                        for (e = a.length; e > g; g++) f = b(a[g], g, d), null != f && h.push(f);
                    else
                        for (g in a) f = b(a[g], g, d), null != f && h.push(f);
                    return Z.apply([], h)
                },
                guid: 1,
                proxy: function(a, b) {
                    var c, d, e;
                    return "string" == typeof b && (c = a[b], b = a, a = c), fa.isFunction(a) ? (d = Y.call(arguments, 2), e = function() {
                        return a.apply(b || this, d.concat(Y.call(arguments)))
                    }, e.guid = a.guid = a.guid || fa.guid++, e) : void 0
                },
                now: Date.now,
                support: da
            }), "function" == typeof Symbol && (fa.fn[Symbol.iterator] = W[Symbol.iterator]), fa.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(a, b) {
                aa["[object " + b + "]"] = b.toLowerCase()
            });
            var ka = function(a) {
                function b(a, b, c, d) {
                    var e, f, g, h, i, j, l, n, o = b && b.ownerDocument,
                        p = b ? b.nodeType : 9;
                    if (c = c || [], "string" != typeof a || !a || 1 !== p && 9 !== p && 11 !== p) return c;
                    if (!d && ((b ? b.ownerDocument || b : O) !== G && F(b), b = b || G, I)) {
                        if (11 !== p && (j = ra.exec(a)))
                            if (e = j[1]) {
                                if (9 === p) {
                                    if (!(g = b.getElementById(e))) return c;
                                    if (g.id === e) return c.push(g), c
                                } else if (o && (g = o.getElementById(e)) && M(b, g) && g.id === e) return c.push(g), c
                            } else {
                                if (j[2]) return $.apply(c, b.getElementsByTagName(a)), c;
                                if ((e = j[3]) && v.getElementsByClassName && b.getElementsByClassName) return $.apply(c, b.getElementsByClassName(e)), c
                            }
                        if (v.qsa && !T[a + " "] && (!J || !J.test(a))) {
                            if (1 !== p) o = b, n = a;
                            else if ("object" !== b.nodeName.toLowerCase()) {
                                for ((h = b.getAttribute("id")) ? h = h.replace(ta, "\\$&") : b.setAttribute("id", h = N), l = z(a), f = l.length, i = ma.test(h) ? "#" + h : "[id='" + h + "']"; f--;) l[f] = i + " " + m(l[f]);
                                n = l.join(","), o = sa.test(a) && k(b.parentNode) || b
                            }
                            if (n) try {
                                return $.apply(c, o.querySelectorAll(n)), c
                            } catch (a) {} finally {
                                h === N && b.removeAttribute("id")
                            }
                        }
                    }
                    return B(a.replace(ha, "$1"), b, c, d)
                }

                function c() {
                    function a(c, d) {
                        return b.push(c + " ") > w.cacheLength && delete a[b.shift()], a[c + " "] = d
                    }
                    var b = [];
                    return a
                }

                function d(a) {
                    return a[N] = !0, a
                }

                function e(a) {
                    var b = G.createElement("div");
                    try {
                        return !!a(b)
                    } catch (a) {
                        return !1
                    } finally {
                        b.parentNode && b.parentNode.removeChild(b), b = null
                    }
                }

                function f(a, b) {
                    for (var c = a.split("|"), d = c.length; d--;) w.attrHandle[c[d]] = b
                }

                function g(a, b) {
                    var c = b && a,
                        d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || V) - (~a.sourceIndex || V);
                    if (d) return d;
                    if (c)
                        for (; c = c.nextSibling;)
                            if (c === b) return -1;
                    return a ? 1 : -1
                }

                function h(a) {
                    return function(b) {
                        var c = b.nodeName.toLowerCase();
                        return "input" === c && b.type === a
                    }
                }

                function i(a) {
                    return function(b) {
                        var c = b.nodeName.toLowerCase();
                        return ("input" === c || "button" === c) && b.type === a
                    }
                }

                function j(a) {
                    return d(function(b) {
                        return b = +b, d(function(c, d) {
                            for (var e, f = a([], c.length, b), g = f.length; g--;) c[e = f[g]] && (c[e] = !(d[e] = c[e]))
                        })
                    })
                }

                function k(a) {
                    return a && "undefined" != typeof a.getElementsByTagName && a
                }

                function l() {}

                function m(a) {
                    for (var b = 0, c = a.length, d = ""; c > b; b++) d += a[b].value;
                    return d
                }

                function n(a, b, c) {
                    var d = b.dir,
                        e = c && "parentNode" === d,
                        f = Q++;
                    return b.first ? function(b, c, f) {
                        for (; b = b[d];)
                            if (1 === b.nodeType || e) return a(b, c, f)
                    } : function(b, c, g) {
                        var h, i, j, k = [P, f];
                        if (g) {
                            for (; b = b[d];)
                                if ((1 === b.nodeType || e) && a(b, c, g)) return !0
                        } else
                            for (; b = b[d];)
                                if (1 === b.nodeType || e) {
                                    if (j = b[N] || (b[N] = {}), i = j[b.uniqueID] || (j[b.uniqueID] = {}), (h = i[d]) && h[0] === P && h[1] === f) return k[2] = h[2];
                                    if (i[d] = k, k[2] = a(b, c, g)) return !0
                                }
                    }
                }

                function o(a) {
                    return a.length > 1 ? function(b, c, d) {
                        for (var e = a.length; e--;)
                            if (!a[e](b, c, d)) return !1;
                        return !0
                    } : a[0]
                }

                function p(a, c, d) {
                    for (var e = 0, f = c.length; f > e; e++) b(a, c[e], d);
                    return d
                }

                function q(a, b, c, d, e) {
                    for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++)(f = a[h]) && (c && !c(f, d, e) || (g.push(f), j && b.push(h)));
                    return g
                }

                function r(a, b, c, e, f, g) {
                    return e && !e[N] && (e = r(e)), f && !f[N] && (f = r(f, g)), d(function(d, g, h, i) {
                        var j, k, l, m = [],
                            n = [],
                            o = g.length,
                            r = d || p(b || "*", h.nodeType ? [h] : h, []),
                            s = !a || !d && b ? r : q(r, m, a, h, i),
                            t = c ? f || (d ? a : o || e) ? [] : g : s;
                        if (c && c(s, t, h, i), e)
                            for (j = q(t, n), e(j, [], h, i), k = j.length; k--;)(l = j[k]) && (t[n[k]] = !(s[n[k]] = l));
                        if (d) {
                            if (f || a) {
                                if (f) {
                                    for (j = [], k = t.length; k--;)(l = t[k]) && j.push(s[k] = l);
                                    f(null, t = [], j, i)
                                }
                                for (k = t.length; k--;)(l = t[k]) && (j = f ? aa(d, l) : m[k]) > -1 && (d[j] = !(g[j] = l))
                            }
                        } else t = q(t === g ? t.splice(o, t.length) : t), f ? f(null, g, t, i) : $.apply(g, t)
                    })
                }

                function s(a) {
                    for (var b, c, d, e = a.length, f = w.relative[a[0].type], g = f || w.relative[" "], h = f ? 1 : 0, i = n(function(a) {
                            return a === b
                        }, g, !0), j = n(function(a) {
                            return aa(b, a) > -1
                        }, g, !0), k = [function(a, c, d) {
                            var e = !f && (d || c !== C) || ((b = c).nodeType ? i(a, c, d) : j(a, c, d));
                            return b = null, e
                        }]; e > h; h++)
                        if (c = w.relative[a[h].type]) k = [n(o(k), c)];
                        else {
                            if (c = w.filter[a[h].type].apply(null, a[h].matches), c[N]) {
                                for (d = ++h; e > d && !w.relative[a[d].type]; d++);
                                return r(h > 1 && o(k), h > 1 && m(a.slice(0, h - 1).concat({
                                    value: " " === a[h - 2].type ? "*" : ""
                                })).replace(ha, "$1"), c, d > h && s(a.slice(h, d)), e > d && s(a = a.slice(d)), e > d && m(a))
                            }
                            k.push(c)
                        }
                    return o(k)
                }

                function t(a, c) {
                    var e = c.length > 0,
                        f = a.length > 0,
                        g = function(d, g, h, i, j) {
                            var k, l, m, n = 0,
                                o = "0",
                                p = d && [],
                                r = [],
                                s = C,
                                t = d || f && w.find.TAG("*", j),
                                u = P += null == s ? 1 : Math.random() || .1,
                                v = t.length;
                            for (j && (C = g === G || g || j); o !== v && null != (k = t[o]); o++) {
                                if (f && k) {
                                    for (l = 0, g || k.ownerDocument === G || (F(k), h = !I); m = a[l++];)
                                        if (m(k, g || G, h)) {
                                            i.push(k);
                                            break
                                        }
                                    j && (P = u)
                                }
                                e && ((k = !m && k) && n--, d && p.push(k))
                            }
                            if (n += o, e && o !== n) {
                                for (l = 0; m = c[l++];) m(p, r, g, h);
                                if (d) {
                                    if (n > 0)
                                        for (; o--;) p[o] || r[o] || (r[o] = Y.call(i));
                                    r = q(r)
                                }
                                $.apply(i, r), j && !d && r.length > 0 && n + c.length > 1 && b.uniqueSort(i)
                            }
                            return j && (P = u, C = s), p
                        };
                    return e ? d(g) : g
                }
                var u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N = "sizzle" + 1 * new Date,
                    O = a.document,
                    P = 0,
                    Q = 0,
                    R = c(),
                    S = c(),
                    T = c(),
                    U = function(a, b) {
                        return a === b && (E = !0), 0
                    },
                    V = 1 << 31,
                    W = {}.hasOwnProperty,
                    X = [],
                    Y = X.pop,
                    Z = X.push,
                    $ = X.push,
                    _ = X.slice,
                    aa = function(a, b) {
                        for (var c = 0, d = a.length; d > c; c++)
                            if (a[c] === b) return c;
                        return -1
                    },
                    ba = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                    ca = "[\\x20\\t\\r\\n\\f]",
                    da = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
                    ea = "\\[" + ca + "*(" + da + ")(?:" + ca + "*([*^$|!~]?=)" + ca + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + da + "))|)" + ca + "*\\]",
                    fa = ":(" + da + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + ea + ")*)|.*)\\)|)",
                    ga = new RegExp(ca + "+", "g"),
                    ha = new RegExp("^" + ca + "+|((?:^|[^\\\\])(?:\\\\.)*)" + ca + "+$", "g"),
                    ia = new RegExp("^" + ca + "*," + ca + "*"),
                    ja = new RegExp("^" + ca + "*([>+~]|" + ca + ")" + ca + "*"),
                    ka = new RegExp("=" + ca + "*([^\\]'\"]*?)" + ca + "*\\]", "g"),
                    la = new RegExp(fa),
                    ma = new RegExp("^" + da + "$"),
                    na = {
                        ID: new RegExp("^#(" + da + ")"),
                        CLASS: new RegExp("^\\.(" + da + ")"),
                        TAG: new RegExp("^(" + da + "|[*])"),
                        ATTR: new RegExp("^" + ea),
                        PSEUDO: new RegExp("^" + fa),
                        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + ca + "*(even|odd|(([+-]|)(\\d*)n|)" + ca + "*(?:([+-]|)" + ca + "*(\\d+)|))" + ca + "*\\)|)", "i"),
                        bool: new RegExp("^(?:" + ba + ")$", "i"),
                        needsContext: new RegExp("^" + ca + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + ca + "*((?:-\\d)?\\d*)" + ca + "*\\)|)(?=[^-]|$)", "i")
                    },
                    oa = /^(?:input|select|textarea|button)$/i,
                    pa = /^h\d$/i,
                    qa = /^[^{]+\{\s*\[native \w/,
                    ra = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                    sa = /[+~]/,
                    ta = /'|\\/g,
                    ua = new RegExp("\\\\([\\da-f]{1,6}" + ca + "?|(" + ca + ")|.)", "ig"),
                    va = function(a, b, c) {
                        var d = "0x" + b - 65536;
                        return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320)
                    },
                    wa = function() {
                        F()
                    };
                try {
                    $.apply(X = _.call(O.childNodes), O.childNodes), X[O.childNodes.length].nodeType
                } catch (a) {
                    $ = {
                        apply: X.length ? function(a, b) {
                            Z.apply(a, _.call(b))
                        } : function(a, b) {
                            for (var c = a.length, d = 0; a[c++] = b[d++];);
                            a.length = c - 1
                        }
                    }
                }
                v = b.support = {}, y = b.isXML = function(a) {
                    var b = a && (a.ownerDocument || a).documentElement;
                    return !!b && "HTML" !== b.nodeName
                }, F = b.setDocument = function(a) {
                    var b, c, d = a ? a.ownerDocument || a : O;
                    return d !== G && 9 === d.nodeType && d.documentElement ? (G = d, H = G.documentElement, I = !y(G), (c = G.defaultView) && c.top !== c && (c.addEventListener ? c.addEventListener("unload", wa, !1) : c.attachEvent && c.attachEvent("onunload", wa)), v.attributes = e(function(a) {
                        return a.className = "i", !a.getAttribute("className")
                    }), v.getElementsByTagName = e(function(a) {
                        return a.appendChild(G.createComment("")), !a.getElementsByTagName("*").length
                    }), v.getElementsByClassName = qa.test(G.getElementsByClassName), v.getById = e(function(a) {
                        return H.appendChild(a).id = N, !G.getElementsByName || !G.getElementsByName(N).length
                    }), v.getById ? (w.find.ID = function(a, b) {
                        if ("undefined" != typeof b.getElementById && I) {
                            var c = b.getElementById(a);
                            return c ? [c] : []
                        }
                    }, w.filter.ID = function(a) {
                        var b = a.replace(ua, va);
                        return function(a) {
                            return a.getAttribute("id") === b
                        }
                    }) : (delete w.find.ID, w.filter.ID = function(a) {
                        var b = a.replace(ua, va);
                        return function(a) {
                            var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id");
                            return c && c.value === b
                        }
                    }), w.find.TAG = v.getElementsByTagName ? function(a, b) {
                        return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : v.qsa ? b.querySelectorAll(a) : void 0
                    } : function(a, b) {
                        var c, d = [],
                            e = 0,
                            f = b.getElementsByTagName(a);
                        if ("*" === a) {
                            for (; c = f[e++];) 1 === c.nodeType && d.push(c);
                            return d
                        }
                        return f
                    }, w.find.CLASS = v.getElementsByClassName && function(a, b) {
                        return "undefined" != typeof b.getElementsByClassName && I ? b.getElementsByClassName(a) : void 0
                    }, K = [], J = [], (v.qsa = qa.test(G.querySelectorAll)) && (e(function(a) {
                        H.appendChild(a).innerHTML = "<a id='" + N + "'></a><select id='" + N + "-\r\\' msallowcapture=''><option selected=''></option></select>", a.querySelectorAll("[msallowcapture^='']").length && J.push("[*^$]=" + ca + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || J.push("\\[" + ca + "*(?:value|" + ba + ")"), a.querySelectorAll("[id~=" + N + "-]").length || J.push("~="), a.querySelectorAll(":checked").length || J.push(":checked"), a.querySelectorAll("a#" + N + "+*").length || J.push(".#.+[+~]")
                    }), e(function(a) {
                        var b = G.createElement("input");
                        b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && J.push("name" + ca + "*[*^$|!~]?="), a.querySelectorAll(":enabled").length || J.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), J.push(",.*:")
                    })), (v.matchesSelector = qa.test(L = H.matches || H.webkitMatchesSelector || H.mozMatchesSelector || H.oMatchesSelector || H.msMatchesSelector)) && e(function(a) {
                        v.disconnectedMatch = L.call(a, "div"), L.call(a, "[s!='']:x"), K.push("!=", fa)
                    }), J = J.length && new RegExp(J.join("|")), K = K.length && new RegExp(K.join("|")), b = qa.test(H.compareDocumentPosition), M = b || qa.test(H.contains) ? function(a, b) {
                        var c = 9 === a.nodeType ? a.documentElement : a,
                            d = b && b.parentNode;
                        return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)))
                    } : function(a, b) {
                        if (b)
                            for (; b = b.parentNode;)
                                if (b === a) return !0;
                        return !1
                    }, U = b ? function(a, b) {
                        if (a === b) return E = !0, 0;
                        var c = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        return c ? c : (c = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & c || !v.sortDetached && b.compareDocumentPosition(a) === c ? a === G || a.ownerDocument === O && M(O, a) ? -1 : b === G || b.ownerDocument === O && M(O, b) ? 1 : D ? aa(D, a) - aa(D, b) : 0 : 4 & c ? -1 : 1)
                    } : function(a, b) {
                        if (a === b) return E = !0, 0;
                        var c, d = 0,
                            e = a.parentNode,
                            f = b.parentNode,
                            h = [a],
                            i = [b];
                        if (!e || !f) return a === G ? -1 : b === G ? 1 : e ? -1 : f ? 1 : D ? aa(D, a) - aa(D, b) : 0;
                        if (e === f) return g(a, b);
                        for (c = a; c = c.parentNode;) h.unshift(c);
                        for (c = b; c = c.parentNode;) i.unshift(c);
                        for (; h[d] === i[d];) d++;
                        return d ? g(h[d], i[d]) : h[d] === O ? -1 : i[d] === O ? 1 : 0
                    }, G) : G
                }, b.matches = function(a, c) {
                    return b(a, null, null, c)
                }, b.matchesSelector = function(a, c) {
                    if ((a.ownerDocument || a) !== G && F(a), c = c.replace(ka, "='$1']"), v.matchesSelector && I && !T[c + " "] && (!K || !K.test(c)) && (!J || !J.test(c))) try {
                        var d = L.call(a, c);
                        if (d || v.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d
                    } catch (a) {}
                    return b(c, G, null, [a]).length > 0
                }, b.contains = function(a, b) {
                    return (a.ownerDocument || a) !== G && F(a), M(a, b)
                }, b.attr = function(a, b) {
                    (a.ownerDocument || a) !== G && F(a);
                    var c = w.attrHandle[b.toLowerCase()],
                        d = c && W.call(w.attrHandle, b.toLowerCase()) ? c(a, b, !I) : void 0;
                    return void 0 !== d ? d : v.attributes || !I ? a.getAttribute(b) : (d = a.getAttributeNode(b)) && d.specified ? d.value : null
                }, b.error = function(a) {
                    throw new Error("Syntax error, unrecognized expression: " + a)
                }, b.uniqueSort = function(a) {
                    var b, c = [],
                        d = 0,
                        e = 0;
                    if (E = !v.detectDuplicates, D = !v.sortStable && a.slice(0), a.sort(U), E) {
                        for (; b = a[e++];) b === a[e] && (d = c.push(e));
                        for (; d--;) a.splice(c[d], 1)
                    }
                    return D = null, a
                }, x = b.getText = function(a) {
                    var b, c = "",
                        d = 0,
                        e = a.nodeType;
                    if (e) {
                        if (1 === e || 9 === e || 11 === e) {
                            if ("string" == typeof a.textContent) return a.textContent;
                            for (a = a.firstChild; a; a = a.nextSibling) c += x(a)
                        } else if (3 === e || 4 === e) return a.nodeValue
                    } else
                        for (; b = a[d++];) c += x(b);
                    return c
                }, w = b.selectors = {
                    cacheLength: 50,
                    createPseudo: d,
                    match: na,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: !0
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: !0
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
                    preFilter: {
                        ATTR: function(a) {
                            return a[1] = a[1].replace(ua, va), a[3] = (a[3] || a[4] || a[5] || "").replace(ua, va), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4)
                        },
                        CHILD: function(a) {
                            return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || b.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && b.error(a[0]), a
                        },
                        PSEUDO: function(a) {
                            var b, c = !a[6] && a[2];
                            return na.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && la.test(c) && (b = z(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3))
                        }
                    },
                    filter: {
                        TAG: function(a) {
                            var b = a.replace(ua, va).toLowerCase();
                            return "*" === a ? function() {
                                return !0
                            } : function(a) {
                                return a.nodeName && a.nodeName.toLowerCase() === b
                            }
                        },
                        CLASS: function(a) {
                            var b = R[a + " "];
                            return b || (b = new RegExp("(^|" + ca + ")" + a + "(" + ca + "|$)")) && R(a, function(a) {
                                return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "")
                            })
                        },
                        ATTR: function(a, c, d) {
                            return function(e) {
                                var f = b.attr(e, a);
                                return null == f ? "!=" === c : !c || (f += "", "=" === c ? f === d : "!=" === c ? f !== d : "^=" === c ? d && 0 === f.indexOf(d) : "*=" === c ? d && f.indexOf(d) > -1 : "$=" === c ? d && f.slice(-d.length) === d : "~=" === c ? (" " + f.replace(ga, " ") + " ").indexOf(d) > -1 : "|=" === c && (f === d || f.slice(0, d.length + 1) === d + "-"))
                            }
                        },
                        CHILD: function(a, b, c, d, e) {
                            var f = "nth" !== a.slice(0, 3),
                                g = "last" !== a.slice(-4),
                                h = "of-type" === b;
                            return 1 === d && 0 === e ? function(a) {
                                return !!a.parentNode
                            } : function(b, c, i) {
                                var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling",
                                    q = b.parentNode,
                                    r = h && b.nodeName.toLowerCase(),
                                    s = !i && !h,
                                    t = !1;
                                if (q) {
                                    if (f) {
                                        for (; p;) {
                                            for (m = b; m = m[p];)
                                                if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1;
                                            o = p = "only" === a && !o && "nextSibling"
                                        }
                                        return !0
                                    }
                                    if (o = [g ? q.firstChild : q.lastChild], g && s) {
                                        for (m = q, l = m[N] || (m[N] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === P && j[1], t = n && j[2], m = n && q.childNodes[n]; m = ++n && m && m[p] || (t = n = 0) || o.pop();)
                                            if (1 === m.nodeType && ++t && m === b) {
                                                k[a] = [P, n, t];
                                                break
                                            }
                                    } else if (s && (m = b, l = m[N] || (m[N] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === P && j[1], t = n), t === !1)
                                        for (;
                                            (m = ++n && m && m[p] || (t = n = 0) || o.pop()) && ((h ? m.nodeName.toLowerCase() !== r : 1 !== m.nodeType) || !++t || (s && (l = m[N] || (m[N] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [P, t]), m !== b)););
                                    return t -= e, t === d || t % d === 0 && t / d >= 0
                                }
                            }
                        },
                        PSEUDO: function(a, c) {
                            var e, f = w.pseudos[a] || w.setFilters[a.toLowerCase()] || b.error("unsupported pseudo: " + a);
                            return f[N] ? f(c) : f.length > 1 ? (e = [a, a, "", c], w.setFilters.hasOwnProperty(a.toLowerCase()) ? d(function(a, b) {
                                for (var d, e = f(a, c), g = e.length; g--;) d = aa(a, e[g]), a[d] = !(b[d] = e[g])
                            }) : function(a) {
                                return f(a, 0, e)
                            }) : f
                        }
                    },
                    pseudos: {
                        not: d(function(a) {
                            var b = [],
                                c = [],
                                e = A(a.replace(ha, "$1"));
                            return e[N] ? d(function(a, b, c, d) {
                                for (var f, g = e(a, null, d, []), h = a.length; h--;)(f = g[h]) && (a[h] = !(b[h] = f))
                            }) : function(a, d, f) {
                                return b[0] = a, e(b, null, f, c), b[0] = null, !c.pop()
                            }
                        }),
                        has: d(function(a) {
                            return function(c) {
                                return b(a, c).length > 0
                            }
                        }),
                        contains: d(function(a) {
                            return a = a.replace(ua, va),
                                function(b) {
                                    return (b.textContent || b.innerText || x(b)).indexOf(a) > -1
                                }
                        }),
                        lang: d(function(a) {
                            return ma.test(a || "") || b.error("unsupported lang: " + a), a = a.replace(ua, va).toLowerCase(),
                                function(b) {
                                    var c;
                                    do
                                        if (c = I ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) && 1 === b.nodeType);
                                    return !1
                                }
                        }),
                        target: function(b) {
                            var c = a.location && a.location.hash;
                            return c && c.slice(1) === b.id
                        },
                        root: function(a) {
                            return a === H
                        },
                        focus: function(a) {
                            return a === G.activeElement && (!G.hasFocus || G.hasFocus()) && !!(a.type || a.href || ~a.tabIndex)
                        },
                        enabled: function(a) {
                            return a.disabled === !1
                        },
                        disabled: function(a) {
                            return a.disabled === !0
                        },
                        checked: function(a) {
                            var b = a.nodeName.toLowerCase();
                            return "input" === b && !!a.checked || "option" === b && !!a.selected
                        },
                        selected: function(a) {
                            return a.parentNode && a.parentNode.selectedIndex, a.selected === !0
                        },
                        empty: function(a) {
                            for (a = a.firstChild; a; a = a.nextSibling)
                                if (a.nodeType < 6) return !1;
                            return !0
                        },
                        parent: function(a) {
                            return !w.pseudos.empty(a)
                        },
                        header: function(a) {
                            return pa.test(a.nodeName)
                        },
                        input: function(a) {
                            return oa.test(a.nodeName)
                        },
                        button: function(a) {
                            var b = a.nodeName.toLowerCase();
                            return "input" === b && "button" === a.type || "button" === b
                        },
                        text: function(a) {
                            var b;
                            return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase())
                        },
                        first: j(function() {
                            return [0]
                        }),
                        last: j(function(a, b) {
                            return [b - 1]
                        }),
                        eq: j(function(a, b, c) {
                            return [0 > c ? c + b : c]
                        }),
                        even: j(function(a, b) {
                            for (var c = 0; b > c; c += 2) a.push(c);
                            return a
                        }),
                        odd: j(function(a, b) {
                            for (var c = 1; b > c; c += 2) a.push(c);
                            return a
                        }),
                        lt: j(function(a, b, c) {
                            for (var d = 0 > c ? c + b : c; --d >= 0;) a.push(d);
                            return a
                        }),
                        gt: j(function(a, b, c) {
                            for (var d = 0 > c ? c + b : c; ++d < b;) a.push(d);
                            return a
                        })
                    }
                }, w.pseudos.nth = w.pseudos.eq;
                for (u in {
                        radio: !0,
                        checkbox: !0,
                        file: !0,
                        password: !0,
                        image: !0
                    }) w.pseudos[u] = h(u);
                for (u in {
                        submit: !0,
                        reset: !0
                    }) w.pseudos[u] = i(u);
                return l.prototype = w.filters = w.pseudos, w.setFilters = new l, z = b.tokenize = function(a, c) {
                    var d, e, f, g, h, i, j, k = S[a + " "];
                    if (k) return c ? 0 : k.slice(0);
                    for (h = a, i = [], j = w.preFilter; h;) {
                        d && !(e = ia.exec(h)) || (e && (h = h.slice(e[0].length) || h), i.push(f = [])), d = !1, (e = ja.exec(h)) && (d = e.shift(), f.push({
                            value: d,
                            type: e[0].replace(ha, " ")
                        }), h = h.slice(d.length));
                        for (g in w.filter) !(e = na[g].exec(h)) || j[g] && !(e = j[g](e)) || (d = e.shift(), f.push({
                            value: d,
                            type: g,
                            matches: e
                        }), h = h.slice(d.length));
                        if (!d) break
                    }
                    return c ? h.length : h ? b.error(a) : S(a, i).slice(0)
                }, A = b.compile = function(a, b) {
                    var c, d = [],
                        e = [],
                        f = T[a + " "];
                    if (!f) {
                        for (b || (b = z(a)), c = b.length; c--;) f = s(b[c]), f[N] ? d.push(f) : e.push(f);
                        f = T(a, t(e, d)), f.selector = a
                    }
                    return f
                }, B = b.select = function(a, b, c, d) {
                    var e, f, g, h, i, j = "function" == typeof a && a,
                        l = !d && z(a = j.selector || a);
                    if (c = c || [], 1 === l.length) {
                        if (f = l[0] = l[0].slice(0), f.length > 2 && "ID" === (g = f[0]).type && v.getById && 9 === b.nodeType && I && w.relative[f[1].type]) {
                            if (b = (w.find.ID(g.matches[0].replace(ua, va), b) || [])[0], !b) return c;
                            j && (b = b.parentNode), a = a.slice(f.shift().value.length)
                        }
                        for (e = na.needsContext.test(a) ? 0 : f.length; e-- && (g = f[e], !w.relative[h = g.type]);)
                            if ((i = w.find[h]) && (d = i(g.matches[0].replace(ua, va), sa.test(f[0].type) && k(b.parentNode) || b))) {
                                if (f.splice(e, 1), a = d.length && m(f), !a) return $.apply(c, d), c;
                                break
                            }
                    }
                    return (j || A(a, l))(d, b, !I, c, !b || sa.test(a) && k(b.parentNode) || b), c
                }, v.sortStable = N.split("").sort(U).join("") === N, v.detectDuplicates = !!E, F(), v.sortDetached = e(function(a) {
                    return 1 & a.compareDocumentPosition(G.createElement("div"))
                }), e(function(a) {
                    return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href")
                }) || f("type|href|height|width", function(a, b, c) {
                    return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2)
                }), v.attributes && e(function(a) {
                    return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value")
                }) || f("value", function(a, b, c) {
                    return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue
                }), e(function(a) {
                    return null == a.getAttribute("disabled")
                }) || f(ba, function(a, b, c) {
                    var d;
                    return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null
                }), b
            }(a);
            fa.find = ka, fa.expr = ka.selectors, fa.expr[":"] = fa.expr.pseudos, fa.uniqueSort = fa.unique = ka.uniqueSort, fa.text = ka.getText, fa.isXMLDoc = ka.isXML, fa.contains = ka.contains;
            var la = function(a, b, c) {
                    for (var d = [], e = void 0 !== c;
                        (a = a[b]) && 9 !== a.nodeType;)
                        if (1 === a.nodeType) {
                            if (e && fa(a).is(c)) break;
                            d.push(a)
                        }
                    return d
                },
                ma = function(a, b) {
                    for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);
                    return c
                },
                na = fa.expr.match.needsContext,
                oa = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,
                pa = /^.[^:#\[\.,]*$/;
            fa.filter = function(a, b, c) {
                var d = b[0];
                return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? fa.find.matchesSelector(d, a) ? [d] : [] : fa.find.matches(a, fa.grep(b, function(a) {
                    return 1 === a.nodeType
                }))
            }, fa.fn.extend({
                find: function(a) {
                    var b, c = this.length,
                        d = [],
                        e = this;
                    if ("string" != typeof a) return this.pushStack(fa(a).filter(function() {
                        for (b = 0; c > b; b++)
                            if (fa.contains(e[b], this)) return !0
                    }));
                    for (b = 0; c > b; b++) fa.find(a, e[b], d);
                    return d = this.pushStack(c > 1 ? fa.unique(d) : d), d.selector = this.selector ? this.selector + " " + a : a, d
                },
                filter: function(a) {
                    return this.pushStack(d(this, a || [], !1))
                },
                not: function(a) {
                    return this.pushStack(d(this, a || [], !0))
                },
                is: function(a) {
                    return !!d(this, "string" == typeof a && na.test(a) ? fa(a) : a || [], !1).length
                }
            });
            var qa, ra = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
                sa = fa.fn.init = function(a, b, c) {
                    var d, e;
                    if (!a) return this;
                    if (c = c || qa, "string" == typeof a) {
                        if (d = "<" === a[0] && ">" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : ra.exec(a), !d || !d[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a);
                        if (d[1]) {
                            if (b = b instanceof fa ? b[0] : b, fa.merge(this, fa.parseHTML(d[1], b && b.nodeType ? b.ownerDocument || b : X, !0)), oa.test(d[1]) && fa.isPlainObject(b))
                                for (d in b) fa.isFunction(this[d]) ? this[d](b[d]) : this.attr(d, b[d]);
                            return this
                        }
                        return e = X.getElementById(d[2]), e && e.parentNode && (this.length = 1, this[0] = e), this.context = X, this.selector = a, this
                    }
                    return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : fa.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(fa) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), fa.makeArray(a, this))
                };
            sa.prototype = fa.fn, qa = fa(X);
            var ta = /^(?:parents|prev(?:Until|All))/,
                ua = {
                    children: !0,
                    contents: !0,
                    next: !0,
                    prev: !0
                };
            fa.fn.extend({
                has: function(a) {
                    var b = fa(a, this),
                        c = b.length;
                    return this.filter(function() {
                        for (var a = 0; c > a; a++)
                            if (fa.contains(this, b[a])) return !0
                    })
                },
                closest: function(a, b) {
                    for (var c, d = 0, e = this.length, f = [], g = na.test(a) || "string" != typeof a ? fa(a, b || this.context) : 0; e > d; d++)
                        for (c = this[d]; c && c !== b; c = c.parentNode)
                            if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && fa.find.matchesSelector(c, a))) {
                                f.push(c);
                                break
                            }
                    return this.pushStack(f.length > 1 ? fa.uniqueSort(f) : f)
                },
                index: function(a) {
                    return a ? "string" == typeof a ? _.call(fa(a), this[0]) : _.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
                },
                add: function(a, b) {
                    return this.pushStack(fa.uniqueSort(fa.merge(this.get(), fa(a, b))))
                },
                addBack: function(a) {
                    return this.add(null == a ? this.prevObject : this.prevObject.filter(a))
                }
            }), fa.each({
                parent: function(a) {
                    var b = a.parentNode;
                    return b && 11 !== b.nodeType ? b : null
                },
                parents: function(a) {
                    return la(a, "parentNode")
                },
                parentsUntil: function(a, b, c) {
                    return la(a, "parentNode", c)
                },
                next: function(a) {
                    return e(a, "nextSibling")
                },
                prev: function(a) {
                    return e(a, "previousSibling")
                },
                nextAll: function(a) {
                    return la(a, "nextSibling")
                },
                prevAll: function(a) {
                    return la(a, "previousSibling")
                },
                nextUntil: function(a, b, c) {
                    return la(a, "nextSibling", c)
                },
                prevUntil: function(a, b, c) {
                    return la(a, "previousSibling", c)
                },
                siblings: function(a) {
                    return ma((a.parentNode || {}).firstChild, a)
                },
                children: function(a) {
                    return ma(a.firstChild)
                },
                contents: function(a) {
                    return a.contentDocument || fa.merge([], a.childNodes)
                }
            }, function(a, b) {
                fa.fn[a] = function(c, d) {
                    var e = fa.map(this, b, c);
                    return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = fa.filter(d, e)), this.length > 1 && (ua[a] || fa.uniqueSort(e), ta.test(a) && e.reverse()), this.pushStack(e)
                }
            });
            var va = /\S+/g;
            fa.Callbacks = function(a) {
                a = "string" == typeof a ? f(a) : fa.extend({}, a);
                var b, c, d, e, g = [],
                    h = [],
                    i = -1,
                    j = function() {
                        for (e = a.once, d = b = !0; h.length; i = -1)
                            for (c = h.shift(); ++i < g.length;) g[i].apply(c[0], c[1]) === !1 && a.stopOnFalse && (i = g.length, c = !1);
                        a.memory || (c = !1), b = !1, e && (g = c ? [] : "")
                    },
                    k = {
                        add: function() {
                            return g && (c && !b && (i = g.length - 1, h.push(c)), function b(c) {
                                fa.each(c, function(c, d) {
                                    fa.isFunction(d) ? a.unique && k.has(d) || g.push(d) : d && d.length && "string" !== fa.type(d) && b(d)
                                })
                            }(arguments), c && !b && j()), this
                        },
                        remove: function() {
                            return fa.each(arguments, function(a, b) {
                                for (var c;
                                    (c = fa.inArray(b, g, c)) > -1;) g.splice(c, 1), i >= c && i--
                            }), this
                        },
                        has: function(a) {
                            return a ? fa.inArray(a, g) > -1 : g.length > 0
                        },
                        empty: function() {
                            return g && (g = []), this
                        },
                        disable: function() {
                            return e = h = [], g = c = "", this
                        },
                        disabled: function() {
                            return !g
                        },
                        lock: function() {
                            return e = h = [], c || (g = c = ""), this
                        },
                        locked: function() {
                            return !!e
                        },
                        fireWith: function(a, c) {
                            return e || (c = c || [], c = [a, c.slice ? c.slice() : c], h.push(c), b || j()), this
                        },
                        fire: function() {
                            return k.fireWith(this, arguments), this
                        },
                        fired: function() {
                            return !!d
                        }
                    };
                return k
            }, fa.extend({
                Deferred: function(a) {
                    var b = [
                            ["resolve", "done", fa.Callbacks("once memory"), "resolved"],
                            ["reject", "fail", fa.Callbacks("once memory"), "rejected"],
                            ["notify", "progress", fa.Callbacks("memory")]
                        ],
                        c = "pending",
                        d = {
                            state: function() {
                                return c
                            },
                            always: function() {
                                return e.done(arguments).fail(arguments), this
                            },
                            then: function() {
                                var a = arguments;
                                return fa.Deferred(function(c) {
                                    fa.each(b, function(b, f) {
                                        var g = fa.isFunction(a[b]) && a[b];
                                        e[f[1]](function() {
                                            var a = g && g.apply(this, arguments);
                                            a && fa.isFunction(a.promise) ? a.promise().progress(c.notify).done(c.resolve).fail(c.reject) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments)
                                        })
                                    }), a = null
                                }).promise()
                            },
                            promise: function(a) {
                                return null != a ? fa.extend(a, d) : d
                            }
                        },
                        e = {};
                    return d.pipe = d.then, fa.each(b, function(a, f) {
                        var g = f[2],
                            h = f[3];
                        d[f[1]] = g.add, h && g.add(function() {
                            c = h
                        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {
                            return e[f[0] + "With"](this === e ? d : this, arguments), this
                        }, e[f[0] + "With"] = g.fireWith
                    }), d.promise(e), a && a.call(e, e), e
                },
                when: function(a) {
                    var b, c, d, e = 0,
                        f = Y.call(arguments),
                        g = f.length,
                        h = 1 !== g || a && fa.isFunction(a.promise) ? g : 0,
                        i = 1 === h ? a : fa.Deferred(),
                        j = function(a, c, d) {
                            return function(e) {
                                c[a] = this, d[a] = arguments.length > 1 ? Y.call(arguments) : e, d === b ? i.notifyWith(c, d) : --h || i.resolveWith(c, d)
                            }
                        };
                    if (g > 1)
                        for (b = new Array(g), c = new Array(g), d = new Array(g); g > e; e++) f[e] && fa.isFunction(f[e].promise) ? f[e].promise().progress(j(e, c, b)).done(j(e, d, f)).fail(i.reject) : --h;
                    return h || i.resolveWith(d, f), i.promise()
                }
            });
            var wa;
            fa.fn.ready = function(a) {
                return fa.ready.promise().done(a), this
            }, fa.extend({
                isReady: !1,
                readyWait: 1,
                holdReady: function(a) {
                    a ? fa.readyWait++ : fa.ready(!0)
                },
                ready: function(a) {
                    (a === !0 ? --fa.readyWait : fa.isReady) || (fa.isReady = !0, a !== !0 && --fa.readyWait > 0 || (wa.resolveWith(X, [fa]), fa.fn.triggerHandler && (fa(X).triggerHandler("ready"), fa(X).off("ready"))))
                }
            }), fa.ready.promise = function(b) {
                return wa || (wa = fa.Deferred(), "complete" === X.readyState || "loading" !== X.readyState && !X.documentElement.doScroll ? a.setTimeout(fa.ready) : (X.addEventListener("DOMContentLoaded", g), a.addEventListener("load", g))), wa.promise(b)
            }, fa.ready.promise();
            var xa = function(a, b, c, d, e, f, g) {
                    var h = 0,
                        i = a.length,
                        j = null == c;
                    if ("object" === fa.type(c)) {
                        e = !0;
                        for (h in c) xa(a, b, h, c[h], !0, f, g)
                    } else if (void 0 !== d && (e = !0, fa.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function(a, b, c) {
                            return j.call(fa(a), c)
                        })), b))
                        for (; i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
                    return e ? a : j ? b.call(a) : i ? b(a[0], c) : f
                },
                ya = function(a) {
                    return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType
                };
            h.uid = 1, h.prototype = {
                register: function(a, b) {
                    var c = b || {};
                    return a.nodeType ? a[this.expando] = c : Object.defineProperty(a, this.expando, {
                        value: c,
                        writable: !0,
                        configurable: !0
                    }), a[this.expando]
                },
                cache: function(a) {
                    if (!ya(a)) return {};
                    var b = a[this.expando];
                    return b || (b = {}, ya(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, {
                        value: b,
                        configurable: !0
                    }))), b
                },
                set: function(a, b, c) {
                    var d, e = this.cache(a);
                    if ("string" == typeof b) e[b] = c;
                    else
                        for (d in b) e[d] = b[d];
                    return e
                },
                get: function(a, b) {
                    return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][b]
                },
                access: function(a, b, c) {
                    var d;
                    return void 0 === b || b && "string" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, fa.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b)
                },
                remove: function(a, b) {
                    var c, d, e, f = a[this.expando];
                    if (void 0 !== f) {
                        if (void 0 === b) this.register(a);
                        else {
                            fa.isArray(b) ? d = b.concat(b.map(fa.camelCase)) : (e = fa.camelCase(b), b in f ? d = [b, e] : (d = e, d = d in f ? [d] : d.match(va) || [])), c = d.length;
                            for (; c--;) delete f[d[c]]
                        }(void 0 === b || fa.isEmptyObject(f)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando])
                    }
                },
                hasData: function(a) {
                    var b = a[this.expando];
                    return void 0 !== b && !fa.isEmptyObject(b)
                }
            };
            var za = new h,
                Aa = new h,
                Ba = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                Ca = /[A-Z]/g;
            fa.extend({
                hasData: function(a) {
                    return Aa.hasData(a) || za.hasData(a)
                },
                data: function(a, b, c) {
                    return Aa.access(a, b, c)
                },
                removeData: function(a, b) {
                    Aa.remove(a, b)
                },
                _data: function(a, b, c) {
                    return za.access(a, b, c)
                },
                _removeData: function(a, b) {
                    za.remove(a, b)
                }
            }), fa.fn.extend({
                data: function(a, b) {
                    var c, d, e, f = this[0],
                        g = f && f.attributes;
                    if (void 0 === a) {
                        if (this.length && (e = Aa.get(f), 1 === f.nodeType && !za.get(f, "hasDataAttrs"))) {
                            for (c = g.length; c--;) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = fa.camelCase(d.slice(5)), i(f, d, e[d])));
                            za.set(f, "hasDataAttrs", !0)
                        }
                        return e
                    }
                    return "object" == typeof a ? this.each(function() {
                        Aa.set(this, a)
                    }) : xa(this, function(b) {
                        var c, d;
                        if (f && void 0 === b) {
                            if (c = Aa.get(f, a) || Aa.get(f, a.replace(Ca, "-$&").toLowerCase()), void 0 !== c) return c;
                            if (d = fa.camelCase(a), c = Aa.get(f, d), void 0 !== c) return c;
                            if (c = i(f, d, void 0), void 0 !== c) return c
                        } else d = fa.camelCase(a), this.each(function() {
                            var c = Aa.get(this, d);
                            Aa.set(this, d, b), a.indexOf("-") > -1 && void 0 !== c && Aa.set(this, a, b)
                        })
                    }, null, b, arguments.length > 1, null, !0)
                },
                removeData: function(a) {
                    return this.each(function() {
                        Aa.remove(this, a)
                    })
                }
            }), fa.extend({
                queue: function(a, b, c) {
                    var d;
                    return a ? (b = (b || "fx") + "queue", d = za.get(a, b), c && (!d || fa.isArray(c) ? d = za.access(a, b, fa.makeArray(c)) : d.push(c)), d || []) : void 0
                },
                dequeue: function(a, b) {
                    b = b || "fx";
                    var c = fa.queue(a, b),
                        d = c.length,
                        e = c.shift(),
                        f = fa._queueHooks(a, b),
                        g = function() {
                            fa.dequeue(a, b)
                        };
                    "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire()
                },
                _queueHooks: function(a, b) {
                    var c = b + "queueHooks";
                    return za.get(a, c) || za.access(a, c, {
                        empty: fa.Callbacks("once memory").add(function() {
                            za.remove(a, [b + "queue", c])
                        })
                    })
                }
            }), fa.fn.extend({
                queue: function(a, b) {
                    var c = 2;
                    return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? fa.queue(this[0], a) : void 0 === b ? this : this.each(function() {
                        var c = fa.queue(this, a, b);
                        fa._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && fa.dequeue(this, a)
                    })
                },
                dequeue: function(a) {
                    return this.each(function() {
                        fa.dequeue(this, a)
                    })
                },
                clearQueue: function(a) {
                    return this.queue(a || "fx", [])
                },
                promise: function(a, b) {
                    var c, d = 1,
                        e = fa.Deferred(),
                        f = this,
                        g = this.length,
                        h = function() {
                            --d || e.resolveWith(f, [f])
                        };
                    for ("string" != typeof a && (b = a, a = void 0), a = a || "fx"; g--;) c = za.get(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));
                    return h(), e.promise(b)
                }
            });
            var Da = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
                Ea = new RegExp("^(?:([+-])=|)(" + Da + ")([a-z%]*)$", "i"),
                Fa = ["Top", "Right", "Bottom", "Left"],
                Ga = function(a, b) {
                    return a = b || a, "none" === fa.css(a, "display") || !fa.contains(a.ownerDocument, a)
                },
                Ha = /^(?:checkbox|radio)$/i,
                Ia = /<([\w:-]+)/,
                Ja = /^$|\/(?:java|ecma)script/i,
                Ka = {
                    option: [1, "<select multiple='multiple'>", "</select>"],
                    thead: [1, "<table>", "</table>"],
                    col: [2, "<table><colgroup>", "</colgroup></table>"],
                    tr: [2, "<table><tbody>", "</tbody></table>"],
                    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                    _default: [0, "", ""]
                };
            Ka.optgroup = Ka.option, Ka.tbody = Ka.tfoot = Ka.colgroup = Ka.caption = Ka.thead, Ka.th = Ka.td;
            var La = /<|&#?\w+;/;
            ! function() {
                var a = X.createDocumentFragment(),
                    b = a.appendChild(X.createElement("div")),
                    c = X.createElement("input");
                c.setAttribute("type", "radio"), c.setAttribute("checked", "checked"), c.setAttribute("name", "t"), b.appendChild(c), da.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = "<textarea>x</textarea>", da.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue
            }();
            var Ma = /^key/,
                Na = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
                Oa = /^([^.]*)(?:\.(.+)|)/;
            fa.event = {
                global: {},
                add: function(a, b, c, d, e) {
                    var f, g, h, i, j, k, l, m, n, o, p, q = za.get(a);
                    if (q)
                        for (c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = fa.guid++), (i = q.events) || (i = q.events = {}), (g = q.handle) || (g = q.handle = function(b) {
                                return "undefined" != typeof fa && fa.event.triggered !== b.type ? fa.event.dispatch.apply(a, arguments) : void 0
                            }), b = (b || "").match(va) || [""], j = b.length; j--;) h = Oa.exec(b[j]) || [], n = p = h[1], o = (h[2] || "").split(".").sort(), n && (l = fa.event.special[n] || {}, n = (e ? l.delegateType : l.bindType) || n, l = fa.event.special[n] || {}, k = fa.extend({
                            type: n,
                            origType: p,
                            data: d,
                            handler: c,
                            guid: c.guid,
                            selector: e,
                            needsContext: e && fa.expr.match.needsContext.test(e),
                            namespace: o.join(".")
                        }, f), (m = i[n]) || (m = i[n] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, o, g) !== !1 || a.addEventListener && a.addEventListener(n, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), fa.event.global[n] = !0)
                },
                remove: function(a, b, c, d, e) {
                    var f, g, h, i, j, k, l, m, n, o, p, q = za.hasData(a) && za.get(a);
                    if (q && (i = q.events)) {
                        for (b = (b || "").match(va) || [""], j = b.length; j--;)
                            if (h = Oa.exec(b[j]) || [], n = p = h[1], o = (h[2] || "").split(".").sort(), n) {
                                for (l = fa.event.special[n] || {}, n = (d ? l.delegateType : l.bindType) || n, m = i[n] || [], h = h[2] && new RegExp("(^|\\.)" + o.join("\\.(?:.*\\.|)") + "(\\.|$)"), g = f = m.length; f--;) k = m[f], !e && p !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && ("**" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));
                                g && !m.length && (l.teardown && l.teardown.call(a, o, q.handle) !== !1 || fa.removeEvent(a, n, q.handle), delete i[n])
                            } else
                                for (n in i) fa.event.remove(a, n + b[j], c, d, !0);
                        fa.isEmptyObject(i) && za.remove(a, "handle events")
                    }
                },
                dispatch: function(a) {
                    a = fa.event.fix(a);
                    var b, c, d, e, f, g = [],
                        h = Y.call(arguments),
                        i = (za.get(this, "events") || {})[a.type] || [],
                        j = fa.event.special[a.type] || {};
                    if (h[0] = a, a.delegateTarget = this, !j.preDispatch || j.preDispatch.call(this, a) !== !1) {
                        for (g = fa.event.handlers.call(this, a, i), b = 0;
                            (e = g[b++]) && !a.isPropagationStopped();)
                            for (a.currentTarget = e.elem, c = 0;
                                (f = e.handlers[c++]) && !a.isImmediatePropagationStopped();) a.rnamespace && !a.rnamespace.test(f.namespace) || (a.handleObj = f, a.data = f.data, d = ((fa.event.special[f.origType] || {}).handle || f.handler).apply(e.elem, h), void 0 !== d && (a.result = d) === !1 && (a.preventDefault(), a.stopPropagation()));
                        return j.postDispatch && j.postDispatch.call(this, a), a.result
                    }
                },
                handlers: function(a, b) {
                    var c, d, e, f, g = [],
                        h = b.delegateCount,
                        i = a.target;
                    if (h && i.nodeType && ("click" !== a.type || isNaN(a.button) || a.button < 1))
                        for (; i !== this; i = i.parentNode || this)
                            if (1 === i.nodeType && (i.disabled !== !0 || "click" !== a.type)) {
                                for (d = [], c = 0; h > c; c++) f = b[c], e = f.selector + " ", void 0 === d[e] && (d[e] = f.needsContext ? fa(e, this).index(i) > -1 : fa.find(e, this, null, [i]).length), d[e] && d.push(f);
                                d.length && g.push({
                                    elem: i,
                                    handlers: d
                                })
                            }
                    return h < b.length && g.push({
                        elem: this,
                        handlers: b.slice(h)
                    }), g
                },
                props: "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
                fixHooks: {},
                keyHooks: {
                    props: "char charCode key keyCode".split(" "),
                    filter: function(a, b) {
                        return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a
                    }
                },
                mouseHooks: {
                    props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
                    filter: function(a, b) {
                        var c, d, e, f = b.button;
                        return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || X, d = c.documentElement, e = c.body, a.pageX = b.clientX + (d && d.scrollLeft || e && e.scrollLeft || 0) - (d && d.clientLeft || e && e.clientLeft || 0), a.pageY = b.clientY + (d && d.scrollTop || e && e.scrollTop || 0) - (d && d.clientTop || e && e.clientTop || 0)), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), a
                    }
                },
                fix: function(a) {
                    if (a[fa.expando]) return a;
                    var b, c, d, e = a.type,
                        f = a,
                        g = this.fixHooks[e];
                    for (g || (this.fixHooks[e] = g = Na.test(e) ? this.mouseHooks : Ma.test(e) ? this.keyHooks : {}), d = g.props ? this.props.concat(g.props) : this.props, a = new fa.Event(f), b = d.length; b--;) c = d[b], a[c] = f[c];
                    return a.target || (a.target = X), 3 === a.target.nodeType && (a.target = a.target.parentNode), g.filter ? g.filter(a, f) : a
                },
                special: {
                    load: {
                        noBubble: !0
                    },
                    focus: {
                        trigger: function() {
                            return this !== p() && this.focus ? (this.focus(), !1) : void 0
                        },
                        delegateType: "focusin"
                    },
                    blur: {
                        trigger: function() {
                            return this === p() && this.blur ? (this.blur(), !1) : void 0
                        },
                        delegateType: "focusout"
                    },
                    click: {
                        trigger: function() {
                            return "checkbox" === this.type && this.click && fa.nodeName(this, "input") ? (this.click(), !1) : void 0
                        },
                        _default: function(a) {
                            return fa.nodeName(a.target, "a")
                        }
                    },
                    beforeunload: {
                        postDispatch: function(a) {
                            void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)
                        }
                    }
                }
            }, fa.removeEvent = function(a, b, c) {
                a.removeEventListener && a.removeEventListener(b, c)
            }, fa.Event = function(a, b) {
                return this instanceof fa.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? n : o) : this.type = a, b && fa.extend(this, b), this.timeStamp = a && a.timeStamp || fa.now(), void(this[fa.expando] = !0)) : new fa.Event(a, b)
            }, fa.Event.prototype = {
                constructor: fa.Event,
                isDefaultPrevented: o,
                isPropagationStopped: o,
                isImmediatePropagationStopped: o,
                isSimulated: !1,
                preventDefault: function() {
                    var a = this.originalEvent;
                    this.isDefaultPrevented = n, a && !this.isSimulated && a.preventDefault()
                },
                stopPropagation: function() {
                    var a = this.originalEvent;
                    this.isPropagationStopped = n, a && !this.isSimulated && a.stopPropagation()
                },
                stopImmediatePropagation: function() {
                    var a = this.originalEvent;
                    this.isImmediatePropagationStopped = n, a && !this.isSimulated && a.stopImmediatePropagation(), this.stopPropagation()
                }
            }, fa.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout"
            }, function(a, b) {
                fa.event.special[a] = {
                    delegateType: b,
                    bindType: b,
                    handle: function(a) {
                        var c, d = this,
                            e = a.relatedTarget,
                            f = a.handleObj;
                        return e && (e === d || fa.contains(d, e)) || (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c
                    }
                }
            }), fa.fn.extend({
                on: function(a, b, c, d) {
                    return q(this, a, b, c, d)
                },
                one: function(a, b, c, d) {
                    return q(this, a, b, c, d, 1)
                },
                off: function(a, b, c) {
                    var d, e;
                    if (a && a.preventDefault && a.handleObj) return d = a.handleObj, fa(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this;
                    if ("object" == typeof a) {
                        for (e in a) this.off(e, b, a[e]);
                        return this
                    }
                    return b !== !1 && "function" != typeof b || (c = b, b = void 0), c === !1 && (c = o), this.each(function() {
                        fa.event.remove(this, a, c, b)
                    })
                }
            });
            var Pa = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
                Qa = /<script|<style|<link/i,
                Ra = /checked\s*(?:[^=]|=\s*.checked.)/i,
                Sa = /^true\/(.*)/,
                Ta = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
            fa.extend({
                htmlPrefilter: function(a) {
                    return a.replace(Pa, "<$1></$2>")
                },
                clone: function(a, b, c) {
                    var d, e, f, g, h = a.cloneNode(!0),
                        i = fa.contains(a.ownerDocument, a);
                    if (!(da.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || fa.isXMLDoc(a)))
                        for (g = k(h), f = k(a), d = 0, e = f.length; e > d; d++) v(f[d], g[d]);
                    if (b)
                        if (c)
                            for (f = f || k(a), g = g || k(h), d = 0, e = f.length; e > d; d++) u(f[d], g[d]);
                        else u(a, h);
                    return g = k(h, "script"), g.length > 0 && l(g, !i && k(a, "script")), h
                },
                cleanData: function(a) {
                    for (var b, c, d, e = fa.event.special, f = 0; void 0 !== (c = a[f]); f++)
                        if (ya(c)) {
                            if (b = c[za.expando]) {
                                if (b.events)
                                    for (d in b.events) e[d] ? fa.event.remove(c, d) : fa.removeEvent(c, d, b.handle);
                                c[za.expando] = void 0
                            }
                            c[Aa.expando] && (c[Aa.expando] = void 0)
                        }
                }
            }), fa.fn.extend({
                domManip: w,
                detach: function(a) {
                    return x(this, a, !0)
                },
                remove: function(a) {
                    return x(this, a)
                },
                text: function(a) {
                    return xa(this, function(a) {
                        return void 0 === a ? fa.text(this) : this.empty().each(function() {
                            1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = a)
                        })
                    }, null, a, arguments.length)
                },
                append: function() {
                    return w(this, arguments, function(a) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            var b = r(this, a);
                            b.appendChild(a)
                        }
                    })
                },
                prepend: function() {
                    return w(this, arguments, function(a) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            var b = r(this, a);
                            b.insertBefore(a, b.firstChild)
                        }
                    })
                },
                before: function() {
                    return w(this, arguments, function(a) {
                        this.parentNode && this.parentNode.insertBefore(a, this)
                    })
                },
                after: function() {
                    return w(this, arguments, function(a) {
                        this.parentNode && this.parentNode.insertBefore(a, this.nextSibling)
                    })
                },
                empty: function() {
                    for (var a, b = 0; null != (a = this[b]); b++) 1 === a.nodeType && (fa.cleanData(k(a, !1)), a.textContent = "");
                    return this
                },
                clone: function(a, b) {
                    return a = null != a && a, b = null == b ? a : b, this.map(function() {
                        return fa.clone(this, a, b)
                    })
                },
                html: function(a) {
                    return xa(this, function(a) {
                        var b = this[0] || {},
                            c = 0,
                            d = this.length;
                        if (void 0 === a && 1 === b.nodeType) return b.innerHTML;
                        if ("string" == typeof a && !Qa.test(a) && !Ka[(Ia.exec(a) || ["", ""])[1].toLowerCase()]) {
                            a = fa.htmlPrefilter(a);
                            try {
                                for (; d > c; c++) b = this[c] || {}, 1 === b.nodeType && (fa.cleanData(k(b, !1)), b.innerHTML = a);
                                b = 0
                            } catch (a) {}
                        }
                        b && this.empty().append(a)
                    }, null, a, arguments.length)
                },
                replaceWith: function() {
                    var a = [];
                    return w(this, arguments, function(b) {
                        var c = this.parentNode;
                        fa.inArray(this, a) < 0 && (fa.cleanData(k(this)), c && c.replaceChild(b, this))
                    }, a)
                }
            }), fa.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, function(a, b) {
                fa.fn[a] = function(a) {
                    for (var c, d = [], e = fa(a), f = e.length - 1, g = 0; f >= g; g++) c = g === f ? this : this.clone(!0), fa(e[g])[b](c), $.apply(d, c.get());
                    return this.pushStack(d)
                }
            });
            var Ua, Va = {
                    HTML: "block",
                    BODY: "block"
                },
                Wa = /^margin/,
                Xa = new RegExp("^(" + Da + ")(?!px)[a-z%]+$", "i"),
                Ya = function(b) {
                    var c = b.ownerDocument.defaultView;
                    return c && c.opener || (c = a), c.getComputedStyle(b)
                },
                Za = function(a, b, c, d) {
                    var e, f, g = {};
                    for (f in b) g[f] = a.style[f], a.style[f] = b[f];
                    e = c.apply(a, d || []);
                    for (f in b) a.style[f] = g[f];
                    return e
                },
                $a = X.documentElement;
            ! function() {
                function b() {
                    h.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", h.innerHTML = "", $a.appendChild(g);
                    var b = a.getComputedStyle(h);
                    c = "1%" !== b.top, f = "2px" === b.marginLeft, d = "4px" === b.width, h.style.marginRight = "50%", e = "4px" === b.marginRight, $a.removeChild(g)
                }
                var c, d, e, f, g = X.createElement("div"),
                    h = X.createElement("div");
                h.style && (h.style.backgroundClip = "content-box", h.cloneNode(!0).style.backgroundClip = "", da.clearCloneStyle = "content-box" === h.style.backgroundClip, g.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", g.appendChild(h), fa.extend(da, {
                    pixelPosition: function() {
                        return b(), c
                    },
                    boxSizingReliable: function() {
                        return null == d && b(), d
                    },
                    pixelMarginRight: function() {
                        return null == d && b(), e
                    },
                    reliableMarginLeft: function() {
                        return null == d && b(), f
                    },
                    reliableMarginRight: function() {
                        var b, c = h.appendChild(X.createElement("div"));
                        return c.style.cssText = h.style.cssText = "-webkit-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", c.style.marginRight = c.style.width = "0", h.style.width = "1px", $a.appendChild(g), b = !parseFloat(a.getComputedStyle(c).marginRight), $a.removeChild(g), h.removeChild(c), b
                    }
                }))
            }();
            var _a = /^(none|table(?!-c[ea]).+)/,
                ab = {
                    position: "absolute",
                    visibility: "hidden",
                    display: "block"
                },
                bb = {
                    letterSpacing: "0",
                    fontWeight: "400"
                },
                cb = ["Webkit", "O", "Moz", "ms"],
                db = X.createElement("div").style;
            fa.extend({
                cssHooks: {
                    opacity: {
                        get: function(a, b) {
                            if (b) {
                                var c = A(a, "opacity");
                                return "" === c ? "1" : c
                            }
                        }
                    }
                },
                cssNumber: {
                    animationIterationCount: !0,
                    columnCount: !0,
                    fillOpacity: !0,
                    flexGrow: !0,
                    flexShrink: !0,
                    fontWeight: !0,
                    lineHeight: !0,
                    opacity: !0,
                    order: !0,
                    orphans: !0,
                    widows: !0,
                    zIndex: !0,
                    zoom: !0
                },
                cssProps: {
                    float: "cssFloat"
                },
                style: function(a, b, c, d) {
                    if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
                        var e, f, g, h = fa.camelCase(b),
                            i = a.style;
                        return b = fa.cssProps[h] || (fa.cssProps[h] = C(h) || h), g = fa.cssHooks[b] || fa.cssHooks[h], void 0 === c ? g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c, "string" === f && (e = Ea.exec(c)) && e[1] && (c = j(a, b, e), f = "number"), void(null != c && c === c && ("number" === f && (c += e && e[3] || (fa.cssNumber[h] ? "" : "px")), da.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), g && "set" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c))))
                    }
                },
                css: function(a, b, c, d) {
                    var e, f, g, h = fa.camelCase(b);
                    return b = fa.cssProps[h] || (fa.cssProps[h] = C(h) || h), g = fa.cssHooks[b] || fa.cssHooks[h], g && "get" in g && (e = g.get(a, !0, c)), void 0 === e && (e = A(a, b, d)), "normal" === e && b in bb && (e = bb[b]), "" === c || c ? (f = parseFloat(e), c === !0 || isFinite(f) ? f || 0 : e) : e
                }
            }), fa.each(["height", "width"], function(a, b) {
                fa.cssHooks[b] = {
                    get: function(a, c, d) {
                        return c ? _a.test(fa.css(a, "display")) && 0 === a.offsetWidth ? Za(a, ab, function() {
                            return F(a, b, d)
                        }) : F(a, b, d) : void 0
                    },
                    set: function(a, c, d) {
                        var e, f = d && Ya(a),
                            g = d && E(a, b, d, "border-box" === fa.css(a, "boxSizing", !1, f), f);
                        return g && (e = Ea.exec(c)) && "px" !== (e[3] || "px") && (a.style[b] = c, c = fa.css(a, b)), D(a, c, g)
                    }
                }
            }), fa.cssHooks.marginLeft = B(da.reliableMarginLeft, function(a, b) {
                return b ? (parseFloat(A(a, "marginLeft")) || a.getBoundingClientRect().left - Za(a, {
                    marginLeft: 0
                }, function() {
                    return a.getBoundingClientRect().left
                })) + "px" : void 0
            }), fa.cssHooks.marginRight = B(da.reliableMarginRight, function(a, b) {
                return b ? Za(a, {
                    display: "inline-block"
                }, A, [a, "marginRight"]) : void 0
            }), fa.each({
                margin: "",
                padding: "",
                border: "Width"
            }, function(a, b) {
                fa.cssHooks[a + b] = {
                    expand: function(c) {
                        for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 > d; d++) e[a + Fa[d] + b] = f[d] || f[d - 2] || f[0];
                        return e
                    }
                }, Wa.test(a) || (fa.cssHooks[a + b].set = D)
            }), fa.fn.extend({
                css: function(a, b) {
                    return xa(this, function(a, b, c) {
                        var d, e, f = {},
                            g = 0;
                        if (fa.isArray(b)) {
                            for (d = Ya(a), e = b.length; e > g; g++) f[b[g]] = fa.css(a, b[g], !1, d);
                            return f
                        }
                        return void 0 !== c ? fa.style(a, b, c) : fa.css(a, b)
                    }, a, b, arguments.length > 1)
                },
                show: function() {
                    return G(this, !0)
                },
                hide: function() {
                    return G(this)
                },
                toggle: function(a) {
                    return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
                        Ga(this) ? fa(this).show() : fa(this).hide()
                    })
                }
            }), fa.Tween = H, H.prototype = {
                constructor: H,
                init: function(a, b, c, d, e, f) {
                    this.elem = a, this.prop = c, this.easing = e || fa.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (fa.cssNumber[c] ? "" : "px")
                },
                cur: function() {
                    var a = H.propHooks[this.prop];
                    return a && a.get ? a.get(this) : H.propHooks._default.get(this)
                },
                run: function(a) {
                    var b, c = H.propHooks[this.prop];
                    return this.options.duration ? this.pos = b = fa.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : H.propHooks._default.set(this), this
                }
            }, H.prototype.init.prototype = H.prototype, H.propHooks = {
                _default: {
                    get: function(a) {
                        var b;
                        return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = fa.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0)
                    },
                    set: function(a) {
                        fa.fx.step[a.prop] ? fa.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[fa.cssProps[a.prop]] && !fa.cssHooks[a.prop] ? a.elem[a.prop] = a.now : fa.style(a.elem, a.prop, a.now + a.unit)
                    }
                }
            }, H.propHooks.scrollTop = H.propHooks.scrollLeft = {
                set: function(a) {
                    a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now)
                }
            }, fa.easing = {
                linear: function(a) {
                    return a
                },
                swing: function(a) {
                    return .5 - Math.cos(a * Math.PI) / 2
                },
                _default: "swing"
            }, fa.fx = H.prototype.init, fa.fx.step = {};
            var eb, fb, gb = /^(?:toggle|show|hide)$/,
                hb = /queueHooks$/;
            fa.Animation = fa.extend(N, {
                    tweeners: {
                        "*": [function(a, b) {
                            var c = this.createTween(a, b);
                            return j(c.elem, a, Ea.exec(b), c), c
                        }]
                    },
                    tweener: function(a, b) {
                        fa.isFunction(a) ? (b = a, a = ["*"]) : a = a.match(va);
                        for (var c, d = 0, e = a.length; e > d; d++) c = a[d], N.tweeners[c] = N.tweeners[c] || [], N.tweeners[c].unshift(b)
                    },
                    prefilters: [L],
                    prefilter: function(a, b) {
                        b ? N.prefilters.unshift(a) : N.prefilters.push(a);
                    }
                }), fa.speed = function(a, b, c) {
                    var d = a && "object" == typeof a ? fa.extend({}, a) : {
                        complete: c || !c && b || fa.isFunction(a) && a,
                        duration: a,
                        easing: c && b || b && !fa.isFunction(b) && b
                    };
                    return d.duration = fa.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in fa.fx.speeds ? fa.fx.speeds[d.duration] : fa.fx.speeds._default, null != d.queue && d.queue !== !0 || (d.queue = "fx"), d.old = d.complete, d.complete = function() {
                        fa.isFunction(d.old) && d.old.call(this), d.queue && fa.dequeue(this, d.queue)
                    }, d
                }, fa.fn.extend({
                    fadeTo: function(a, b, c, d) {
                        return this.filter(Ga).css("opacity", 0).show().end().animate({
                            opacity: b
                        }, a, c, d)
                    },
                    animate: function(a, b, c, d) {
                        var e = fa.isEmptyObject(a),
                            f = fa.speed(b, c, d),
                            g = function() {
                                var b = N(this, fa.extend({}, a), f);
                                (e || za.get(this, "finish")) && b.stop(!0)
                            };
                        return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g)
                    },
                    stop: function(a, b, c) {
                        var d = function(a) {
                            var b = a.stop;
                            delete a.stop, b(c)
                        };
                        return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function() {
                            var b = !0,
                                e = null != a && a + "queueHooks",
                                f = fa.timers,
                                g = za.get(this);
                            if (e) g[e] && g[e].stop && d(g[e]);
                            else
                                for (e in g) g[e] && g[e].stop && hb.test(e) && d(g[e]);
                            for (e = f.length; e--;) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));
                            !b && c || fa.dequeue(this, a)
                        })
                    },
                    finish: function(a) {
                        return a !== !1 && (a = a || "fx"), this.each(function() {
                            var b, c = za.get(this),
                                d = c[a + "queue"],
                                e = c[a + "queueHooks"],
                                f = fa.timers,
                                g = d ? d.length : 0;
                            for (c.finish = !0, fa.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));
                            for (b = 0; g > b; b++) d[b] && d[b].finish && d[b].finish.call(this);
                            delete c.finish
                        })
                    }
                }), fa.each(["toggle", "show", "hide"], function(a, b) {
                    var c = fa.fn[b];
                    fa.fn[b] = function(a, d, e) {
                        return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(J(b, !0), a, d, e)
                    }
                }), fa.each({
                    slideDown: J("show"),
                    slideUp: J("hide"),
                    slideToggle: J("toggle"),
                    fadeIn: {
                        opacity: "show"
                    },
                    fadeOut: {
                        opacity: "hide"
                    },
                    fadeToggle: {
                        opacity: "toggle"
                    }
                }, function(a, b) {
                    fa.fn[a] = function(a, c, d) {
                        return this.animate(b, a, c, d)
                    }
                }), fa.timers = [], fa.fx.tick = function() {
                    var a, b = 0,
                        c = fa.timers;
                    for (eb = fa.now(); b < c.length; b++) a = c[b], a() || c[b] !== a || c.splice(b--, 1);
                    c.length || fa.fx.stop(), eb = void 0
                }, fa.fx.timer = function(a) {
                    fa.timers.push(a), a() ? fa.fx.start() : fa.timers.pop()
                }, fa.fx.interval = 13, fa.fx.start = function() {
                    fb || (fb = a.setInterval(fa.fx.tick, fa.fx.interval))
                }, fa.fx.stop = function() {
                    a.clearInterval(fb), fb = null
                }, fa.fx.speeds = {
                    slow: 600,
                    fast: 200,
                    _default: 400
                }, fa.fn.delay = function(b, c) {
                    return b = fa.fx ? fa.fx.speeds[b] || b : b, c = c || "fx", this.queue(c, function(c, d) {
                        var e = a.setTimeout(c, b);
                        d.stop = function() {
                            a.clearTimeout(e)
                        }
                    })
                },
                function() {
                    var a = X.createElement("input"),
                        b = X.createElement("select"),
                        c = b.appendChild(X.createElement("option"));
                    a.type = "checkbox", da.checkOn = "" !== a.value, da.optSelected = c.selected, b.disabled = !0, da.optDisabled = !c.disabled, a = X.createElement("input"), a.value = "t", a.type = "radio", da.radioValue = "t" === a.value
                }();
            var ib, jb = fa.expr.attrHandle;
            fa.fn.extend({
                attr: function(a, b) {
                    return xa(this, fa.attr, a, b, arguments.length > 1)
                },
                removeAttr: function(a) {
                    return this.each(function() {
                        fa.removeAttr(this, a)
                    })
                }
            }), fa.extend({
                attr: function(a, b, c) {
                    var d, e, f = a.nodeType;
                    if (3 !== f && 8 !== f && 2 !== f) return "undefined" == typeof a.getAttribute ? fa.prop(a, b, c) : (1 === f && fa.isXMLDoc(a) || (b = b.toLowerCase(), e = fa.attrHooks[b] || (fa.expr.match.bool.test(b) ? ib : void 0)), void 0 !== c ? null === c ? void fa.removeAttr(a, b) : e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + ""), c) : e && "get" in e && null !== (d = e.get(a, b)) ? d : (d = fa.find.attr(a, b), null == d ? void 0 : d))
                },
                attrHooks: {
                    type: {
                        set: function(a, b) {
                            if (!da.radioValue && "radio" === b && fa.nodeName(a, "input")) {
                                var c = a.value;
                                return a.setAttribute("type", b), c && (a.value = c), b
                            }
                        }
                    }
                },
                removeAttr: function(a, b) {
                    var c, d, e = 0,
                        f = b && b.match(va);
                    if (f && 1 === a.nodeType)
                        for (; c = f[e++];) d = fa.propFix[c] || c, fa.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c)
                }
            }), ib = {
                set: function(a, b, c) {
                    return b === !1 ? fa.removeAttr(a, c) : a.setAttribute(c, c), c
                }
            }, fa.each(fa.expr.match.bool.source.match(/\w+/g), function(a, b) {
                var c = jb[b] || fa.find.attr;
                jb[b] = function(a, b, d) {
                    var e, f;
                    return d || (f = jb[b], jb[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, jb[b] = f), e
                }
            });
            var kb = /^(?:input|select|textarea|button)$/i,
                lb = /^(?:a|area)$/i;
            fa.fn.extend({
                prop: function(a, b) {
                    return xa(this, fa.prop, a, b, arguments.length > 1)
                },
                removeProp: function(a) {
                    return this.each(function() {
                        delete this[fa.propFix[a] || a]
                    })
                }
            }), fa.extend({
                prop: function(a, b, c) {
                    var d, e, f = a.nodeType;
                    if (3 !== f && 8 !== f && 2 !== f) return 1 === f && fa.isXMLDoc(a) || (b = fa.propFix[b] || b, e = fa.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b]
                },
                propHooks: {
                    tabIndex: {
                        get: function(a) {
                            var b = fa.find.attr(a, "tabindex");
                            return b ? parseInt(b, 10) : kb.test(a.nodeName) || lb.test(a.nodeName) && a.href ? 0 : -1
                        }
                    }
                },
                propFix: {
                    for: "htmlFor",
                    class: "className"
                }
            }), da.optSelected || (fa.propHooks.selected = {
                get: function(a) {
                    var b = a.parentNode;
                    return b && b.parentNode && b.parentNode.selectedIndex, null
                },
                set: function(a) {
                    var b = a.parentNode;
                    b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex)
                }
            }), fa.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
                fa.propFix[this.toLowerCase()] = this
            });
            var mb = /[\t\r\n\f]/g;
            fa.fn.extend({
                addClass: function(a) {
                    var b, c, d, e, f, g, h, i = 0;
                    if (fa.isFunction(a)) return this.each(function(b) {
                        fa(this).addClass(a.call(this, b, O(this)))
                    });
                    if ("string" == typeof a && a)
                        for (b = a.match(va) || []; c = this[i++];)
                            if (e = O(c), d = 1 === c.nodeType && (" " + e + " ").replace(mb, " ")) {
                                for (g = 0; f = b[g++];) d.indexOf(" " + f + " ") < 0 && (d += f + " ");
                                h = fa.trim(d), e !== h && c.setAttribute("class", h)
                            }
                    return this
                },
                removeClass: function(a) {
                    var b, c, d, e, f, g, h, i = 0;
                    if (fa.isFunction(a)) return this.each(function(b) {
                        fa(this).removeClass(a.call(this, b, O(this)))
                    });
                    if (!arguments.length) return this.attr("class", "");
                    if ("string" == typeof a && a)
                        for (b = a.match(va) || []; c = this[i++];)
                            if (e = O(c), d = 1 === c.nodeType && (" " + e + " ").replace(mb, " ")) {
                                for (g = 0; f = b[g++];)
                                    for (; d.indexOf(" " + f + " ") > -1;) d = d.replace(" " + f + " ", " ");
                                h = fa.trim(d), e !== h && c.setAttribute("class", h)
                            }
                    return this
                },
                toggleClass: function(a, b) {
                    var c = typeof a;
                    return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : fa.isFunction(a) ? this.each(function(c) {
                        fa(this).toggleClass(a.call(this, c, O(this), b), b)
                    }) : this.each(function() {
                        var b, d, e, f;
                        if ("string" === c)
                            for (d = 0, e = fa(this), f = a.match(va) || []; b = f[d++];) e.hasClass(b) ? e.removeClass(b) : e.addClass(b);
                        else void 0 !== a && "boolean" !== c || (b = O(this), b && za.set(this, "__className__", b), this.setAttribute && this.setAttribute("class", b || a === !1 ? "" : za.get(this, "__className__") || ""))
                    })
                },
                hasClass: function(a) {
                    var b, c, d = 0;
                    for (b = " " + a + " "; c = this[d++];)
                        if (1 === c.nodeType && (" " + O(c) + " ").replace(mb, " ").indexOf(b) > -1) return !0;
                    return !1
                }
            });
            var nb = /\r/g,
                ob = /[\x20\t\r\n\f]+/g;
            fa.fn.extend({
                val: function(a) {
                    var b, c, d, e = this[0];
                    return arguments.length ? (d = fa.isFunction(a), this.each(function(c) {
                        var e;
                        1 === this.nodeType && (e = d ? a.call(this, c, fa(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : fa.isArray(e) && (e = fa.map(e, function(a) {
                            return null == a ? "" : a + ""
                        })), b = fa.valHooks[this.type] || fa.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e))
                    })) : e ? (b = fa.valHooks[e.type] || fa.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(nb, "") : null == c ? "" : c)) : void 0
                }
            }), fa.extend({
                valHooks: {
                    option: {
                        get: function(a) {
                            var b = fa.find.attr(a, "value");
                            return null != b ? b : fa.trim(fa.text(a)).replace(ob, " ")
                        }
                    },
                    select: {
                        get: function(a) {
                            for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++)
                                if (c = d[i], (c.selected || i === e) && (da.optDisabled ? !c.disabled : null === c.getAttribute("disabled")) && (!c.parentNode.disabled || !fa.nodeName(c.parentNode, "optgroup"))) {
                                    if (b = fa(c).val(), f) return b;
                                    g.push(b)
                                }
                            return g
                        },
                        set: function(a, b) {
                            for (var c, d, e = a.options, f = fa.makeArray(b), g = e.length; g--;) d = e[g], (d.selected = fa.inArray(fa.valHooks.option.get(d), f) > -1) && (c = !0);
                            return c || (a.selectedIndex = -1), f
                        }
                    }
                }
            }), fa.each(["radio", "checkbox"], function() {
                fa.valHooks[this] = {
                    set: function(a, b) {
                        return fa.isArray(b) ? a.checked = fa.inArray(fa(a).val(), b) > -1 : void 0
                    }
                }, da.checkOn || (fa.valHooks[this].get = function(a) {
                    return null === a.getAttribute("value") ? "on" : a.value
                })
            });
            var pb = /^(?:focusinfocus|focusoutblur)$/;
            fa.extend(fa.event, {
                trigger: function(b, c, d, e) {
                    var f, g, h, i, j, k, l, m = [d || X],
                        n = ca.call(b, "type") ? b.type : b,
                        o = ca.call(b, "namespace") ? b.namespace.split(".") : [];
                    if (g = h = d = d || X, 3 !== d.nodeType && 8 !== d.nodeType && !pb.test(n + fa.event.triggered) && (n.indexOf(".") > -1 && (o = n.split("."), n = o.shift(), o.sort()), j = n.indexOf(":") < 0 && "on" + n, b = b[fa.expando] ? b : new fa.Event(n, "object" == typeof b && b), b.isTrigger = e ? 2 : 3, b.namespace = o.join("."), b.rnamespace = b.namespace ? new RegExp("(^|\\.)" + o.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : fa.makeArray(c, [b]), l = fa.event.special[n] || {}, e || !l.trigger || l.trigger.apply(d, c) !== !1)) {
                        if (!e && !l.noBubble && !fa.isWindow(d)) {
                            for (i = l.delegateType || n, pb.test(i + n) || (g = g.parentNode); g; g = g.parentNode) m.push(g), h = g;
                            h === (d.ownerDocument || X) && m.push(h.defaultView || h.parentWindow || a)
                        }
                        for (f = 0;
                            (g = m[f++]) && !b.isPropagationStopped();) b.type = f > 1 ? i : l.bindType || n, k = (za.get(g, "events") || {})[b.type] && za.get(g, "handle"), k && k.apply(g, c), k = j && g[j], k && k.apply && ya(g) && (b.result = k.apply(g, c), b.result === !1 && b.preventDefault());
                        return b.type = n, e || b.isDefaultPrevented() || l._default && l._default.apply(m.pop(), c) !== !1 || !ya(d) || j && fa.isFunction(d[n]) && !fa.isWindow(d) && (h = d[j], h && (d[j] = null), fa.event.triggered = n, d[n](), fa.event.triggered = void 0, h && (d[j] = h)), b.result
                    }
                },
                simulate: function(a, b, c) {
                    var d = fa.extend(new fa.Event, c, {
                        type: a,
                        isSimulated: !0
                    });
                    fa.event.trigger(d, null, b)
                }
            }), fa.fn.extend({
                trigger: function(a, b) {
                    return this.each(function() {
                        fa.event.trigger(a, b, this)
                    })
                },
                triggerHandler: function(a, b) {
                    var c = this[0];
                    return c ? fa.event.trigger(a, b, c, !0) : void 0
                }
            }), fa.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(a, b) {
                fa.fn[b] = function(a, c) {
                    return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b)
                }
            }), fa.fn.extend({
                hover: function(a, b) {
                    return this.mouseenter(a).mouseleave(b || a)
                }
            }), da.focusin = "onfocusin" in a, da.focusin || fa.each({
                focus: "focusin",
                blur: "focusout"
            }, function(a, b) {
                var c = function(a) {
                    fa.event.simulate(b, a.target, fa.event.fix(a))
                };
                fa.event.special[b] = {
                    setup: function() {
                        var d = this.ownerDocument || this,
                            e = za.access(d, b);
                        e || d.addEventListener(a, c, !0), za.access(d, b, (e || 0) + 1)
                    },
                    teardown: function() {
                        var d = this.ownerDocument || this,
                            e = za.access(d, b) - 1;
                        e ? za.access(d, b, e) : (d.removeEventListener(a, c, !0), za.remove(d, b))
                    }
                }
            });
            var qb = a.location,
                rb = fa.now(),
                sb = /\?/;
            fa.parseJSON = function(a) {
                return JSON.parse(a + "")
            }, fa.parseXML = function(b) {
                var c;
                if (!b || "string" != typeof b) return null;
                try {
                    c = (new a.DOMParser).parseFromString(b, "text/xml")
                } catch (a) {
                    c = void 0
                }
                return c && !c.getElementsByTagName("parsererror").length || fa.error("Invalid XML: " + b), c
            };
            var tb = /#.*$/,
                ub = /([?&])_=[^&]*/,
                vb = /^(.*?):[ \t]*([^\r\n]*)$/gm,
                wb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                xb = /^(?:GET|HEAD)$/,
                yb = /^\/\//,
                zb = {},
                Ab = {},
                Bb = "*/".concat("*"),
                Cb = X.createElement("a");
            Cb.href = qb.href, fa.extend({
                active: 0,
                lastModified: {},
                etag: {},
                ajaxSettings: {
                    url: qb.href,
                    type: "GET",
                    isLocal: wb.test(qb.protocol),
                    global: !0,
                    processData: !0,
                    async: !0,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                    accepts: {
                        "*": Bb,
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml, text/xml",
                        json: "application/json, text/javascript"
                    },
                    contents: {
                        xml: /\bxml\b/,
                        html: /\bhtml/,
                        json: /\bjson\b/
                    },
                    responseFields: {
                        xml: "responseXML",
                        text: "responseText",
                        json: "responseJSON"
                    },
                    converters: {
                        "* text": String,
                        "text html": !0,
                        "text json": fa.parseJSON,
                        "text xml": fa.parseXML
                    },
                    flatOptions: {
                        url: !0,
                        context: !0
                    }
                },
                ajaxSetup: function(a, b) {
                    return b ? R(R(a, fa.ajaxSettings), b) : R(fa.ajaxSettings, a)
                },
                ajaxPrefilter: P(zb),
                ajaxTransport: P(Ab),
                ajax: function(b, c) {
                    function d(b, c, d, h) {
                        var j, l, s, t, v, x = c;
                        2 !== u && (u = 2, i && a.clearTimeout(i), e = void 0, g = h || "", w.readyState = b > 0 ? 4 : 0, j = b >= 200 && 300 > b || 304 === b, d && (t = S(m, w, d)), t = T(m, t, w, j), j ? (m.ifModified && (v = w.getResponseHeader("Last-Modified"), v && (fa.lastModified[f] = v), v = w.getResponseHeader("etag"), v && (fa.etag[f] = v)), 204 === b || "HEAD" === m.type ? x = "nocontent" : 304 === b ? x = "notmodified" : (x = t.state, l = t.data, s = t.error, j = !s)) : (s = x, !b && x || (x = "error", 0 > b && (b = 0))), w.status = b, w.statusText = (c || x) + "", j ? p.resolveWith(n, [l, x, w]) : p.rejectWith(n, [w, x, s]), w.statusCode(r), r = void 0, k && o.trigger(j ? "ajaxSuccess" : "ajaxError", [w, m, j ? l : s]), q.fireWith(n, [w, x]), k && (o.trigger("ajaxComplete", [w, m]), --fa.active || fa.event.trigger("ajaxStop")))
                    }
                    "object" == typeof b && (c = b, b = void 0), c = c || {};
                    var e, f, g, h, i, j, k, l, m = fa.ajaxSetup({}, c),
                        n = m.context || m,
                        o = m.context && (n.nodeType || n.jquery) ? fa(n) : fa.event,
                        p = fa.Deferred(),
                        q = fa.Callbacks("once memory"),
                        r = m.statusCode || {},
                        s = {},
                        t = {},
                        u = 0,
                        v = "canceled",
                        w = {
                            readyState: 0,
                            getResponseHeader: function(a) {
                                var b;
                                if (2 === u) {
                                    if (!h)
                                        for (h = {}; b = vb.exec(g);) h[b[1].toLowerCase()] = b[2];
                                    b = h[a.toLowerCase()]
                                }
                                return null == b ? null : b
                            },
                            getAllResponseHeaders: function() {
                                return 2 === u ? g : null
                            },
                            setRequestHeader: function(a, b) {
                                var c = a.toLowerCase();
                                return u || (a = t[c] = t[c] || a, s[a] = b), this
                            },
                            overrideMimeType: function(a) {
                                return u || (m.mimeType = a), this
                            },
                            statusCode: function(a) {
                                var b;
                                if (a)
                                    if (2 > u)
                                        for (b in a) r[b] = [r[b], a[b]];
                                    else w.always(a[w.status]);
                                return this
                            },
                            abort: function(a) {
                                var b = a || v;
                                return e && e.abort(b), d(0, b), this
                            }
                        };
                    if (p.promise(w).complete = q.add, w.success = w.done, w.error = w.fail, m.url = ((b || m.url || qb.href) + "").replace(tb, "").replace(yb, qb.protocol + "//"), m.type = c.method || c.type || m.method || m.type, m.dataTypes = fa.trim(m.dataType || "*").toLowerCase().match(va) || [""], null == m.crossDomain) {
                        j = X.createElement("a");
                        try {
                            j.href = m.url, j.href = j.href, m.crossDomain = Cb.protocol + "//" + Cb.host != j.protocol + "//" + j.host
                        } catch (a) {
                            m.crossDomain = !0
                        }
                    }
                    if (m.data && m.processData && "string" != typeof m.data && (m.data = fa.param(m.data, m.traditional)), Q(zb, m, c, w), 2 === u) return w;
                    k = fa.event && m.global, k && 0 === fa.active++ && fa.event.trigger("ajaxStart"), m.type = m.type.toUpperCase(), m.hasContent = !xb.test(m.type), f = m.url, m.hasContent || (m.data && (f = m.url += (sb.test(f) ? "&" : "?") + m.data, delete m.data), m.cache === !1 && (m.url = ub.test(f) ? f.replace(ub, "$1_=" + rb++) : f + (sb.test(f) ? "&" : "?") + "_=" + rb++)), m.ifModified && (fa.lastModified[f] && w.setRequestHeader("If-Modified-Since", fa.lastModified[f]), fa.etag[f] && w.setRequestHeader("If-None-Match", fa.etag[f])), (m.data && m.hasContent && m.contentType !== !1 || c.contentType) && w.setRequestHeader("Content-Type", m.contentType), w.setRequestHeader("Accept", m.dataTypes[0] && m.accepts[m.dataTypes[0]] ? m.accepts[m.dataTypes[0]] + ("*" !== m.dataTypes[0] ? ", " + Bb + "; q=0.01" : "") : m.accepts["*"]);
                    for (l in m.headers) w.setRequestHeader(l, m.headers[l]);
                    if (m.beforeSend && (m.beforeSend.call(n, w, m) === !1 || 2 === u)) return w.abort();
                    v = "abort";
                    for (l in {
                            success: 1,
                            error: 1,
                            complete: 1
                        }) w[l](m[l]);
                    if (e = Q(Ab, m, c, w)) {
                        if (w.readyState = 1, k && o.trigger("ajaxSend", [w, m]), 2 === u) return w;
                        m.async && m.timeout > 0 && (i = a.setTimeout(function() {
                            w.abort("timeout")
                        }, m.timeout));
                        try {
                            u = 1, e.send(s, d)
                        } catch (a) {
                            if (!(2 > u)) throw a;
                            d(-1, a)
                        }
                    } else d(-1, "No Transport");
                    return w
                },
                getJSON: function(a, b, c) {
                    return fa.get(a, b, c, "json")
                },
                getScript: function(a, b) {
                    return fa.get(a, void 0, b, "script")
                }
            }), fa.each(["get", "post"], function(a, b) {
                fa[b] = function(a, c, d, e) {
                    return fa.isFunction(c) && (e = e || d, d = c, c = void 0), fa.ajax(fa.extend({
                        url: a,
                        type: b,
                        dataType: e,
                        data: c,
                        success: d
                    }, fa.isPlainObject(a) && a))
                }
            }), fa._evalUrl = function(a) {
                return fa.ajax({
                    url: a,
                    type: "GET",
                    dataType: "script",
                    async: !1,
                    global: !1,
                    throws: !0
                })
            }, fa.fn.extend({
                wrapAll: function(a) {
                    var b;
                    return fa.isFunction(a) ? this.each(function(b) {
                        fa(this).wrapAll(a.call(this, b))
                    }) : (this[0] && (b = fa(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function() {
                        for (var a = this; a.firstElementChild;) a = a.firstElementChild;
                        return a
                    }).append(this)), this)
                },
                wrapInner: function(a) {
                    return fa.isFunction(a) ? this.each(function(b) {
                        fa(this).wrapInner(a.call(this, b))
                    }) : this.each(function() {
                        var b = fa(this),
                            c = b.contents();
                        c.length ? c.wrapAll(a) : b.append(a)
                    })
                },
                wrap: function(a) {
                    var b = fa.isFunction(a);
                    return this.each(function(c) {
                        fa(this).wrapAll(b ? a.call(this, c) : a)
                    })
                },
                unwrap: function() {
                    return this.parent().each(function() {
                        fa.nodeName(this, "body") || fa(this).replaceWith(this.childNodes)
                    }).end()
                }
            }), fa.expr.filters.hidden = function(a) {
                return !fa.expr.filters.visible(a)
            }, fa.expr.filters.visible = function(a) {
                return a.offsetWidth > 0 || a.offsetHeight > 0 || a.getClientRects().length > 0
            };
            var Db = /%20/g,
                Eb = /\[\]$/,
                Fb = /\r?\n/g,
                Gb = /^(?:submit|button|image|reset|file)$/i,
                Hb = /^(?:input|select|textarea|keygen)/i;
            fa.param = function(a, b) {
                var c, d = [],
                    e = function(a, b) {
                        b = fa.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b)
                    };
                if (void 0 === b && (b = fa.ajaxSettings && fa.ajaxSettings.traditional), fa.isArray(a) || a.jquery && !fa.isPlainObject(a)) fa.each(a, function() {
                    e(this.name, this.value)
                });
                else
                    for (c in a) U(c, a[c], b, e);
                return d.join("&").replace(Db, "+")
            }, fa.fn.extend({
                serialize: function() {
                    return fa.param(this.serializeArray())
                },
                serializeArray: function() {
                    return this.map(function() {
                        var a = fa.prop(this, "elements");
                        return a ? fa.makeArray(a) : this
                    }).filter(function() {
                        var a = this.type;
                        return this.name && !fa(this).is(":disabled") && Hb.test(this.nodeName) && !Gb.test(a) && (this.checked || !Ha.test(a))
                    }).map(function(a, b) {
                        var c = fa(this).val();
                        return null == c ? null : fa.isArray(c) ? fa.map(c, function(a) {
                            return {
                                name: b.name,
                                value: a.replace(Fb, "\r\n")
                            }
                        }) : {
                            name: b.name,
                            value: c.replace(Fb, "\r\n")
                        }
                    }).get()
                }
            }), fa.ajaxSettings.xhr = function() {
                try {
                    return new a.XMLHttpRequest
                } catch (a) {}
            };
            var Ib = {
                    0: 200,
                    1223: 204
                },
                Jb = fa.ajaxSettings.xhr();
            da.cors = !!Jb && "withCredentials" in Jb, da.ajax = Jb = !!Jb, fa.ajaxTransport(function(b) {
                var c, d;
                return da.cors || Jb && !b.crossDomain ? {
                    send: function(e, f) {
                        var g, h = b.xhr();
                        if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields)
                            for (g in b.xhrFields) h[g] = b.xhrFields[g];
                        b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e["X-Requested-With"] || (e["X-Requested-With"] = "XMLHttpRequest");
                        for (g in e) h.setRequestHeader(g, e[g]);
                        c = function(a) {
                            return function() {
                                c && (c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, "abort" === a ? h.abort() : "error" === a ? "number" != typeof h.status ? f(0, "error") : f(h.status, h.statusText) : f(Ib[h.status] || h.status, h.statusText, "text" !== (h.responseType || "text") || "string" != typeof h.responseText ? {
                                    binary: h.response
                                } : {
                                    text: h.responseText
                                }, h.getAllResponseHeaders()))
                            }
                        }, h.onload = c(), d = h.onerror = c("error"), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function() {
                            4 === h.readyState && a.setTimeout(function() {
                                c && d()
                            })
                        }, c = c("abort");
                        try {
                            h.send(b.hasContent && b.data || null)
                        } catch (a) {
                            if (c) throw a
                        }
                    },
                    abort: function() {
                        c && c()
                    }
                } : void 0
            }), fa.ajaxSetup({
                accepts: {
                    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                },
                contents: {
                    script: /\b(?:java|ecma)script\b/
                },
                converters: {
                    "text script": function(a) {
                        return fa.globalEval(a), a
                    }
                }
            }), fa.ajaxPrefilter("script", function(a) {
                void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET")
            }), fa.ajaxTransport("script", function(a) {
                if (a.crossDomain) {
                    var b, c;
                    return {
                        send: function(d, e) {
                            b = fa("<script>").prop({
                                charset: a.scriptCharset,
                                src: a.url
                            }).on("load error", c = function(a) {
                                b.remove(), c = null, a && e("error" === a.type ? 404 : 200, a.type)
                            }), X.head.appendChild(b[0])
                        },
                        abort: function() {
                            c && c()
                        }
                    }
                }
            });
            var Kb = [],
                Lb = /(=)\?(?=&|$)|\?\?/;
            fa.ajaxSetup({
                jsonp: "callback",
                jsonpCallback: function() {
                    var a = Kb.pop() || fa.expando + "_" + rb++;
                    return this[a] = !0, a
                }
            }), fa.ajaxPrefilter("json jsonp", function(b, c, d) {
                var e, f, g, h = b.jsonp !== !1 && (Lb.test(b.url) ? "url" : "string" == typeof b.data && 0 === (b.contentType || "").indexOf("application/x-www-form-urlencoded") && Lb.test(b.data) && "data");
                return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = fa.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Lb, "$1" + e) : b.jsonp !== !1 && (b.url += (sb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function() {
                    return g || fa.error(e + " was not called"), g[0]
                }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
                    g = arguments
                }, d.always(function() {
                    void 0 === f ? fa(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Kb.push(e)), g && fa.isFunction(f) && f(g[0]), g = f = void 0
                }), "script") : void 0
            }), fa.parseHTML = function(a, b, c) {
                if (!a || "string" != typeof a) return null;
                "boolean" == typeof b && (c = b, b = !1), b = b || X;
                var d = oa.exec(a),
                    e = !c && [];
                return d ? [b.createElement(d[1])] : (d = m([a], b, e), e && e.length && fa(e).remove(), fa.merge([], d.childNodes))
            };
            var Mb = fa.fn.load;
            fa.fn.load = function(a, b, c) {
                if ("string" != typeof a && Mb) return Mb.apply(this, arguments);
                var d, e, f, g = this,
                    h = a.indexOf(" ");
                return h > -1 && (d = fa.trim(a.slice(h)), a = a.slice(0, h)), fa.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (e = "POST"), g.length > 0 && fa.ajax({
                    url: a,
                    type: e || "GET",
                    dataType: "html",
                    data: b
                }).done(function(a) {
                    f = arguments, g.html(d ? fa("<div>").append(fa.parseHTML(a)).find(d) : a)
                }).always(c && function(a, b) {
                    g.each(function() {
                        c.apply(this, f || [a.responseText, b, a])
                    })
                }), this
            }, fa.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(a, b) {
                fa.fn[b] = function(a) {
                    return this.on(b, a)
                }
            }), fa.expr.filters.animated = function(a) {
                return fa.grep(fa.timers, function(b) {
                    return a === b.elem
                }).length
            }, fa.offset = {
                setOffset: function(a, b, c) {
                    var d, e, f, g, h, i, j, k = fa.css(a, "position"),
                        l = fa(a),
                        m = {};
                    "static" === k && (a.style.position = "relative"), h = l.offset(), f = fa.css(a, "top"), i = fa.css(a, "left"), j = ("absolute" === k || "fixed" === k) && (f + i).indexOf("auto") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), fa.isFunction(b) && (b = b.call(a, c, fa.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), "using" in b ? b.using.call(a, m) : l.css(m)
                }
            }, fa.fn.extend({
                offset: function(a) {
                    if (arguments.length) return void 0 === a ? this : this.each(function(b) {
                        fa.offset.setOffset(this, a, b)
                    });
                    var b, c, d = this[0],
                        e = {
                            top: 0,
                            left: 0
                        },
                        f = d && d.ownerDocument;
                    return f ? (b = f.documentElement, fa.contains(b, d) ? (e = d.getBoundingClientRect(), c = V(f), {
                        top: e.top + c.pageYOffset - b.clientTop,
                        left: e.left + c.pageXOffset - b.clientLeft
                    }) : e) : void 0
                },
                position: function() {
                    if (this[0]) {
                        var a, b, c = this[0],
                            d = {
                                top: 0,
                                left: 0
                            };
                        return "fixed" === fa.css(c, "position") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), fa.nodeName(a[0], "html") || (d = a.offset()), d.top += fa.css(a[0], "borderTopWidth", !0), d.left += fa.css(a[0], "borderLeftWidth", !0)), {
                            top: b.top - d.top - fa.css(c, "marginTop", !0),
                            left: b.left - d.left - fa.css(c, "marginLeft", !0)
                        }
                    }
                },
                offsetParent: function() {
                    return this.map(function() {
                        for (var a = this.offsetParent; a && "static" === fa.css(a, "position");) a = a.offsetParent;
                        return a || $a
                    })
                }
            }), fa.each({
                scrollLeft: "pageXOffset",
                scrollTop: "pageYOffset"
            }, function(a, b) {
                var c = "pageYOffset" === b;
                fa.fn[a] = function(d) {
                    return xa(this, function(a, d, e) {
                        var f = V(a);
                        return void 0 === e ? f ? f[b] : a[d] : void(f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e)
                    }, a, d, arguments.length)
                }
            }), fa.each(["top", "left"], function(a, b) {
                fa.cssHooks[b] = B(da.pixelPosition, function(a, c) {
                    return c ? (c = A(a, b), Xa.test(c) ? fa(a).position()[b] + "px" : c) : void 0
                })
            }), fa.each({
                Height: "height",
                Width: "width"
            }, function(a, b) {
                fa.each({
                    padding: "inner" + a,
                    content: b,
                    "": "outer" + a
                }, function(c, d) {
                    fa.fn[d] = function(d, e) {
                        var f = arguments.length && (c || "boolean" != typeof d),
                            g = c || (d === !0 || e === !0 ? "margin" : "border");
                        return xa(this, function(b, c, d) {
                            var e;
                            return fa.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? fa.css(b, c, g) : fa.style(b, c, d, g)
                        }, b, f ? d : void 0, f, null)
                    }
                })
            }), fa.fn.extend({
                bind: function(a, b, c) {
                    return this.on(a, null, b, c)
                },
                unbind: function(a, b) {
                    return this.off(a, null, b)
                },
                delegate: function(a, b, c, d) {
                    return this.on(b, a, c, d)
                },
                undelegate: function(a, b, c) {
                    return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c)
                },
                size: function() {
                    return this.length
                }
            }), fa.fn.andSelf = fa.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
                return fa
            });
            var Nb = a.jQuery,
                Ob = a.$;
            return fa.noConflict = function(b) {
                return a.$ === fa && (a.$ = Ob), b && a.jQuery === fa && (a.jQuery = Nb), fa
            }, b || (a.jQuery = a.$ = fa), fa
        }), "undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery"); + function(a) {
        "use strict";
        var b = a.fn.jquery.split(" ")[0].split(".");
        if (b[0] < 2 && b[1] < 9 || 1 == b[0] && 9 == b[1] && b[2] < 1 || b[0] > 3) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4")
    }(jQuery), + function(a) {
        "use strict";

        function b() {
            var a = document.createElement("bootstrap"),
                b = {
                    WebkitTransition: "webkitTransitionEnd",
                    MozTransition: "transitionend",
                    OTransition: "oTransitionEnd otransitionend",
                    transition: "transitionend"
                };
            for (var c in b)
                if (void 0 !== a.style[c]) return {
                    end: b[c]
                };
            return !1
        }
        a.fn.emulateTransitionEnd = function(b) {
            var c = !1,
                d = this;
            a(this).one("bsTransitionEnd", function() {
                c = !0
            });
            var e = function() {
                c || a(d).trigger(a.support.transition.end)
            };
            return setTimeout(e, b), this
        }, a(function() {
            a.support.transition = b(), a.support.transition && (a.event.special.bsTransitionEnd = {
                bindType: a.support.transition.end,
                delegateType: a.support.transition.end,
                handle: function(b) {
                    if (a(b.target).is(this)) return b.handleObj.handler.apply(this, arguments)
                }
            })
        })
    }(jQuery), + function(a) {
        "use strict";

        function b(b) {
            return this.each(function() {
                var c = a(this),
                    e = c.data("bs.alert");
                e || c.data("bs.alert", e = new d(this)), "string" == typeof b && e[b].call(c)
            })
        }
        var c = '[data-dismiss="alert"]',
            d = function(b) {
                a(b).on("click", c, this.close)
            };
        d.VERSION = "3.3.7", d.TRANSITION_DURATION = 150, d.prototype.close = function(b) {
            function c() {
                g.detach().trigger("closed.bs.alert").remove()
            }
            var e = a(this),
                f = e.attr("data-target");
            f || (f = e.attr("href"), f = f && f.replace(/.*(?=#[^\s]*$)/, ""));
            var g = a("#" === f ? [] : f);
            b && b.preventDefault(), g.length || (g = e.closest(".alert")), g.trigger(b = a.Event("close.bs.alert")), b.isDefaultPrevented() || (g.removeClass("in"), a.support.transition && g.hasClass("fade") ? g.one("bsTransitionEnd", c).emulateTransitionEnd(d.TRANSITION_DURATION) : c())
        };
        var e = a.fn.alert;
        a.fn.alert = b, a.fn.alert.Constructor = d, a.fn.alert.noConflict = function() {
            return a.fn.alert = e, this
        }, a(document).on("click.bs.alert.data-api", c, d.prototype.close)
    }(jQuery), + function(a) {
        "use strict";

        function b(b) {
            return this.each(function() {
                var d = a(this),
                    e = d.data("bs.button"),
                    f = "object" == typeof b && b;
                e || d.data("bs.button", e = new c(this, f)), "toggle" == b ? e.toggle() : b && e.setState(b)
            })
        }
        var c = function(b, d) {
            this.$element = a(b), this.options = a.extend({}, c.DEFAULTS, d), this.isLoading = !1
        };
        c.VERSION = "3.3.7", c.DEFAULTS = {
            loadingText: "loading..."
        }, c.prototype.setState = function(b) {
            var c = "disabled",
                d = this.$element,
                e = d.is("input") ? "val" : "html",
                f = d.data();
            b += "Text", null == f.resetText && d.data("resetText", d[e]()), setTimeout(a.proxy(function() {
                d[e](null == f[b] ? this.options[b] : f[b]), "loadingText" == b ? (this.isLoading = !0, d.addClass(c).attr(c, c).prop(c, !0)) : this.isLoading && (this.isLoading = !1, d.removeClass(c).removeAttr(c).prop(c, !1))
            }, this), 0)
        }, c.prototype.toggle = function() {
            var a = !0,
                b = this.$element.closest('[data-toggle="buttons"]');
            if (b.length) {
                var c = this.$element.find("input");
                "radio" == c.prop("type") ? (c.prop("checked") && (a = !1), b.find(".active").removeClass("active"), this.$element.addClass("active")) : "checkbox" == c.prop("type") && (c.prop("checked") !== this.$element.hasClass("active") && (a = !1), this.$element.toggleClass("active")), c.prop("checked", this.$element.hasClass("active")), a && c.trigger("change")
            } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element.toggleClass("active")
        };
        var d = a.fn.button;
        a.fn.button = b, a.fn.button.Constructor = c, a.fn.button.noConflict = function() {
            return a.fn.button = d, this
        }, a(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function(c) {
            var d = a(c.target).closest(".btn");
            b.call(d, "toggle"), a(c.target).is('input[type="radio"], input[type="checkbox"]') || (c.preventDefault(), d.is("input,button") ? d.trigger("focus") : d.find("input:visible,button:visible").first().trigger("focus"))
        }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function(b) {
            a(b.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(b.type))
        })
    }(jQuery), + function(a) {
        "use strict";

        function b(b) {
            return this.each(function() {
                var d = a(this),
                    e = d.data("bs.carousel"),
                    f = a.extend({}, c.DEFAULTS, d.data(), "object" == typeof b && b),
                    g = "string" == typeof b ? b : f.slide;
                e || d.data("bs.carousel", e = new c(this, f)), "number" == typeof b ? e.to(b) : g ? e[g]() : f.interval && e.pause().cycle()
            })
        }
        var c = function(b, c) {
            this.$element = a(b), this.$indicators = this.$element.find(".carousel-indicators"), this.options = c, this.paused = null, this.sliding = null, this.interval = null, this.$active = null, this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", a.proxy(this.keydown, this)), "hover" == this.options.pause && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", a.proxy(this.pause, this)).on("mouseleave.bs.carousel", a.proxy(this.cycle, this))
        };
        c.VERSION = "3.3.7", c.TRANSITION_DURATION = 600, c.DEFAULTS = {
            interval: 5e3,
            pause: "hover",
            wrap: !0,
            keyboard: !0
        }, c.prototype.keydown = function(a) {
            if (!/input|textarea/i.test(a.target.tagName)) {
                switch (a.which) {
                    case 37:
                        this.prev();
                        break;
                    case 39:
                        this.next();
                        break;
                    default:
                        return
                }
                a.preventDefault()
            }
        }, c.prototype.cycle = function(b) {
            return b || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval(a.proxy(this.next, this), this.options.interval)), this
        }, c.prototype.getItemIndex = function(a) {
            return this.$items = a.parent().children(".item"), this.$items.index(a || this.$active)
        }, c.prototype.getItemForDirection = function(a, b) {
            var c = this.getItemIndex(b),
                d = "prev" == a && 0 === c || "next" == a && c == this.$items.length - 1;
            if (d && !this.options.wrap) return b;
            var e = "prev" == a ? -1 : 1,
                f = (c + e) % this.$items.length;
            return this.$items.eq(f)
        }, c.prototype.to = function(a) {
            var b = this,
                c = this.getItemIndex(this.$active = this.$element.find(".item.active"));
            if (!(a > this.$items.length - 1 || a < 0)) return this.sliding ? this.$element.one("slid.bs.carousel", function() {
                b.to(a)
            }) : c == a ? this.pause().cycle() : this.slide(a > c ? "next" : "prev", this.$items.eq(a))
        }, c.prototype.pause = function(b) {
            return b || (this.paused = !0), this.$element.find(".next, .prev").length && a.support.transition && (this.$element.trigger(a.support.transition.end), this.cycle(!0)), this.interval = clearInterval(this.interval), this
        }, c.prototype.next = function() {
            if (!this.sliding) return this.slide("next")
        }, c.prototype.prev = function() {
            if (!this.sliding) return this.slide("prev")
        }, c.prototype.slide = function(b, d) {
            var e = this.$element.find(".item.active"),
                f = d || this.getItemForDirection(b, e),
                g = this.interval,
                h = "next" == b ? "left" : "right",
                i = this;
            if (f.hasClass("active")) return this.sliding = !1;
            var j = f[0],
                k = a.Event("slide.bs.carousel", {
                    relatedTarget: j,
                    direction: h
                });
            if (this.$element.trigger(k), !k.isDefaultPrevented()) {
                if (this.sliding = !0, g && this.pause(), this.$indicators.length) {
                    this.$indicators.find(".active").removeClass("active");
                    var l = a(this.$indicators.children()[this.getItemIndex(f)]);
                    l && l.addClass("active")
                }
                var m = a.Event("slid.bs.carousel", {
                    relatedTarget: j,
                    direction: h
                });
                return a.support.transition && this.$element.hasClass("slide") ? (f.addClass(b), f[0].offsetWidth, e.addClass(h), f.addClass(h), e.one("bsTransitionEnd", function() {
                    f.removeClass([b, h].join(" ")).addClass("active"), e.removeClass(["active", h].join(" ")), i.sliding = !1, setTimeout(function() {
                        i.$element.trigger(m)
                    }, 0)
                }).emulateTransitionEnd(c.TRANSITION_DURATION)) : (e.removeClass("active"), f.addClass("active"), this.sliding = !1, this.$element.trigger(m)), g && this.cycle(), this
            }
        };
        var d = a.fn.carousel;
        a.fn.carousel = b, a.fn.carousel.Constructor = c, a.fn.carousel.noConflict = function() {
            return a.fn.carousel = d, this
        };
        var e = function(c) {
            var d, e = a(this),
                f = a(e.attr("data-target") || (d = e.attr("href")) && d.replace(/.*(?=#[^\s]+$)/, ""));
            if (f.hasClass("carousel")) {
                var g = a.extend({}, f.data(), e.data()),
                    h = e.attr("data-slide-to");
                h && (g.interval = !1), b.call(f, g), h && f.data("bs.carousel").to(h), c.preventDefault()
            }
        };
        a(document).on("click.bs.carousel.data-api", "[data-slide]", e).on("click.bs.carousel.data-api", "[data-slide-to]", e),
            a(window).on("load", function() {
                a('[data-ride="carousel"]').each(function() {
                    var c = a(this);
                    b.call(c, c.data())
                })
            })
    }(jQuery), + function(a) {
        "use strict";

        function b(b) {
            var c, d = b.attr("data-target") || (c = b.attr("href")) && c.replace(/.*(?=#[^\s]+$)/, "");
            return a(d)
        }

        function c(b) {
            return this.each(function() {
                var c = a(this),
                    e = c.data("bs.collapse"),
                    f = a.extend({}, d.DEFAULTS, c.data(), "object" == typeof b && b);
                !e && f.toggle && /show|hide/.test(b) && (f.toggle = !1), e || c.data("bs.collapse", e = new d(this, f)), "string" == typeof b && e[b]()
            })
        }
        var d = function(b, c) {
            this.$element = a(b), this.options = a.extend({}, d.DEFAULTS, c), this.$trigger = a('[data-toggle="collapse"][href="#' + b.id + '"],[data-toggle="collapse"][data-target="#' + b.id + '"]'), this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), this.options.toggle && this.toggle()
        };
        d.VERSION = "3.3.7", d.TRANSITION_DURATION = 350, d.DEFAULTS = {
            toggle: !0
        }, d.prototype.dimension = function() {
            var a = this.$element.hasClass("width");
            return a ? "width" : "height"
        }, d.prototype.show = function() {
            if (!this.transitioning && !this.$element.hasClass("in")) {
                var b, e = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
                if (!(e && e.length && (b = e.data("bs.collapse"), b && b.transitioning))) {
                    var f = a.Event("show.bs.collapse");
                    if (this.$element.trigger(f), !f.isDefaultPrevented()) {
                        e && e.length && (c.call(e, "hide"), b || e.data("bs.collapse", null));
                        var g = this.dimension();
                        this.$element.removeClass("collapse").addClass("collapsing")[g](0).attr("aria-expanded", !0), this.$trigger.removeClass("collapsed").attr("aria-expanded", !0), this.transitioning = 1;
                        var h = function() {
                            this.$element.removeClass("collapsing").addClass("collapse in")[g](""), this.transitioning = 0, this.$element.trigger("shown.bs.collapse")
                        };
                        if (!a.support.transition) return h.call(this);
                        var i = a.camelCase(["scroll", g].join("-"));
                        this.$element.one("bsTransitionEnd", a.proxy(h, this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i])
                    }
                }
            }
        }, d.prototype.hide = function() {
            if (!this.transitioning && this.$element.hasClass("in")) {
                var b = a.Event("hide.bs.collapse");
                if (this.$element.trigger(b), !b.isDefaultPrevented()) {
                    var c = this.dimension();
                    this.$element[c](this.$element[c]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1), this.$trigger.addClass("collapsed").attr("aria-expanded", !1), this.transitioning = 1;
                    var e = function() {
                        this.transitioning = 0, this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")
                    };
                    return a.support.transition ? void this.$element[c](0).one("bsTransitionEnd", a.proxy(e, this)).emulateTransitionEnd(d.TRANSITION_DURATION) : e.call(this)
                }
            }
        }, d.prototype.toggle = function() {
            this[this.$element.hasClass("in") ? "hide" : "show"]()
        }, d.prototype.getParent = function() {
            return a(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each(a.proxy(function(c, d) {
                var e = a(d);
                this.addAriaAndCollapsedClass(b(e), e)
            }, this)).end()
        }, d.prototype.addAriaAndCollapsedClass = function(a, b) {
            var c = a.hasClass("in");
            a.attr("aria-expanded", c), b.toggleClass("collapsed", !c).attr("aria-expanded", c)
        };
        var e = a.fn.collapse;
        a.fn.collapse = c, a.fn.collapse.Constructor = d, a.fn.collapse.noConflict = function() {
            return a.fn.collapse = e, this
        }, a(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function(d) {
            var e = a(this);
            e.attr("data-target") || d.preventDefault();
            var f = b(e),
                g = f.data("bs.collapse"),
                h = g ? "toggle" : e.data();
            c.call(f, h)
        })
    }(jQuery), + function(a) {
        "use strict";

        function b(b) {
            var c = b.attr("data-target");
            c || (c = b.attr("href"), c = c && /#[A-Za-z]/.test(c) && c.replace(/.*(?=#[^\s]*$)/, ""));
            var d = c && a(c);
            return d && d.length ? d : b.parent()
        }

        function c(c) {
            c && 3 === c.which || (a(e).remove(), a(f).each(function() {
                var d = a(this),
                    e = b(d),
                    f = {
                        relatedTarget: this
                    };
                e.hasClass("open") && (c && "click" == c.type && /input|textarea/i.test(c.target.tagName) && a.contains(e[0], c.target) || (e.trigger(c = a.Event("hide.bs.dropdown", f)), c.isDefaultPrevented() || (d.attr("aria-expanded", "false"), e.removeClass("open").trigger(a.Event("hidden.bs.dropdown", f)))))
            }))
        }

        function d(b) {
            return this.each(function() {
                var c = a(this),
                    d = c.data("bs.dropdown");
                d || c.data("bs.dropdown", d = new g(this)), "string" == typeof b && d[b].call(c)
            })
        }
        var e = ".dropdown-backdrop",
            f = '[data-toggle="dropdown"]',
            g = function(b) {
                a(b).on("click.bs.dropdown", this.toggle)
            };
        g.VERSION = "3.3.7", g.prototype.toggle = function(d) {
            var e = a(this);
            if (!e.is(".disabled, :disabled")) {
                var f = b(e),
                    g = f.hasClass("open");
                if (c(), !g) {
                    "ontouchstart" in document.documentElement && !f.closest(".navbar-nav").length && a(document.createElement("div")).addClass("dropdown-backdrop").insertAfter(a(this)).on("click", c);
                    var h = {
                        relatedTarget: this
                    };
                    if (f.trigger(d = a.Event("show.bs.dropdown", h)), d.isDefaultPrevented()) return;
                    e.trigger("focus").attr("aria-expanded", "true"), f.toggleClass("open").trigger(a.Event("shown.bs.dropdown", h))
                }
                return !1
            }
        }, g.prototype.keydown = function(c) {
            if (/(38|40|27|32)/.test(c.which) && !/input|textarea/i.test(c.target.tagName)) {
                var d = a(this);
                if (c.preventDefault(), c.stopPropagation(), !d.is(".disabled, :disabled")) {
                    var e = b(d),
                        g = e.hasClass("open");
                    if (!g && 27 != c.which || g && 27 == c.which) return 27 == c.which && e.find(f).trigger("focus"), d.trigger("click");
                    var h = " li:not(.disabled):visible a",
                        i = e.find(".dropdown-menu" + h);
                    if (i.length) {
                        var j = i.index(c.target);
                        38 == c.which && j > 0 && j--, 40 == c.which && j < i.length - 1 && j++, ~j || (j = 0), i.eq(j).trigger("focus")
                    }
                }
            }
        };
        var h = a.fn.dropdown;
        a.fn.dropdown = d, a.fn.dropdown.Constructor = g, a.fn.dropdown.noConflict = function() {
            return a.fn.dropdown = h, this
        }, a(document).on("click.bs.dropdown.data-api", c).on("click.bs.dropdown.data-api", ".dropdown form", function(a) {
            a.stopPropagation()
        }).on("click.bs.dropdown.data-api", f, g.prototype.toggle).on("keydown.bs.dropdown.data-api", f, g.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", g.prototype.keydown)
    }(jQuery), + function(a) {
        "use strict";

        function b(b, d) {
            return this.each(function() {
                var e = a(this),
                    f = e.data("bs.modal"),
                    g = a.extend({}, c.DEFAULTS, e.data(), "object" == typeof b && b);
                f || e.data("bs.modal", f = new c(this, g)), "string" == typeof b ? f[b](d) : g.show && f.show(d)
            })
        }
        var c = function(b, c) {
            this.options = c, this.$body = a(document.body), this.$element = a(b), this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, this.options.remote && this.$element.find(".modal-content").load(this.options.remote, a.proxy(function() {
                this.$element.trigger("loaded.bs.modal")
            }, this))
        };
        c.VERSION = "3.3.7", c.TRANSITION_DURATION = 300, c.BACKDROP_TRANSITION_DURATION = 150, c.DEFAULTS = {
            backdrop: !0,
            keyboard: !0,
            show: !0
        }, c.prototype.toggle = function(a) {
            return this.isShown ? this.hide() : this.show(a)
        }, c.prototype.show = function(b) {
            var d = this,
                e = a.Event("show.bs.modal", {
                    relatedTarget: b
                });
            this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', a.proxy(this.hide, this)), this.$dialog.on("mousedown.dismiss.bs.modal", function() {
                d.$element.one("mouseup.dismiss.bs.modal", function(b) {
                    a(b.target).is(d.$element) && (d.ignoreBackdropClick = !0)
                })
            }), this.backdrop(function() {
                var e = a.support.transition && d.$element.hasClass("fade");
                d.$element.parent().length || d.$element.appendTo(d.$body), d.$element.show().scrollTop(0), d.adjustDialog(), e && d.$element[0].offsetWidth, d.$element.addClass("in"), d.enforceFocus();
                var f = a.Event("shown.bs.modal", {
                    relatedTarget: b
                });
                e ? d.$dialog.one("bsTransitionEnd", function() {
                    d.$element.trigger("focus").trigger(f)
                }).emulateTransitionEnd(c.TRANSITION_DURATION) : d.$element.trigger("focus").trigger(f)
            }))
        }, c.prototype.hide = function(b) {
            b && b.preventDefault(), b = a.Event("hide.bs.modal"), this.$element.trigger(b), this.isShown && !b.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), a(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), this.$dialog.off("mousedown.dismiss.bs.modal"), a.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", a.proxy(this.hideModal, this)).emulateTransitionEnd(c.TRANSITION_DURATION) : this.hideModal())
        }, c.prototype.enforceFocus = function() {
            a(document).off("focusin.bs.modal").on("focusin.bs.modal", a.proxy(function(a) {
                document === a.target || this.$element[0] === a.target || this.$element.has(a.target).length || this.$element.trigger("focus")
            }, this))
        }, c.prototype.escape = function() {
            this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", a.proxy(function(a) {
                27 == a.which && this.hide()
            }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal")
        }, c.prototype.resize = function() {
            this.isShown ? a(window).on("resize.bs.modal", a.proxy(this.handleUpdate, this)) : a(window).off("resize.bs.modal")
        }, c.prototype.hideModal = function() {
            var a = this;
            this.$element.hide(), this.backdrop(function() {
                a.$body.removeClass("modal-open"), a.resetAdjustments(), a.resetScrollbar(), a.$element.trigger("hidden.bs.modal")
            })
        }, c.prototype.removeBackdrop = function() {
            this.$backdrop && this.$backdrop.remove(), this.$backdrop = null
        }, c.prototype.backdrop = function(b) {
            var d = this,
                e = this.$element.hasClass("fade") ? "fade" : "";
            if (this.isShown && this.options.backdrop) {
                var f = a.support.transition && e;
                if (this.$backdrop = a(document.createElement("div")).addClass("modal-backdrop " + e).appendTo(this.$body), this.$element.on("click.dismiss.bs.modal", a.proxy(function(a) {
                        return this.ignoreBackdropClick ? void(this.ignoreBackdropClick = !1) : void(a.target === a.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide()))
                    }, this)), f && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !b) return;
                f ? this.$backdrop.one("bsTransitionEnd", b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : b()
            } else if (!this.isShown && this.$backdrop) {
                this.$backdrop.removeClass("in");
                var g = function() {
                    d.removeBackdrop(), b && b()
                };
                a.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : g()
            } else b && b()
        }, c.prototype.handleUpdate = function() {
            this.adjustDialog()
        }, c.prototype.adjustDialog = function() {
            var a = this.$element[0].scrollHeight > document.documentElement.clientHeight;
            this.$element.css({
                paddingLeft: !this.bodyIsOverflowing && a ? this.scrollbarWidth : "",
                paddingRight: this.bodyIsOverflowing && !a ? this.scrollbarWidth : ""
            })
        }, c.prototype.resetAdjustments = function() {
            this.$element.css({
                paddingLeft: "",
                paddingRight: ""
            })
        }, c.prototype.checkScrollbar = function() {
            var a = window.innerWidth;
            if (!a) {
                var b = document.documentElement.getBoundingClientRect();
                a = b.right - Math.abs(b.left)
            }
            this.bodyIsOverflowing = document.body.clientWidth < a, this.scrollbarWidth = this.measureScrollbar()
        }, c.prototype.setScrollbar = function() {
            var a = parseInt(this.$body.css("padding-right") || 0, 10);
            this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", a + this.scrollbarWidth)
        }, c.prototype.resetScrollbar = function() {
            this.$body.css("padding-right", this.originalBodyPad)
        }, c.prototype.measureScrollbar = function() {
            var a = document.createElement("div");
            a.className = "modal-scrollbar-measure", this.$body.append(a);
            var b = a.offsetWidth - a.clientWidth;
            return this.$body[0].removeChild(a), b
        };
        var d = a.fn.modal;
        a.fn.modal = b, a.fn.modal.Constructor = c, a.fn.modal.noConflict = function() {
            return a.fn.modal = d, this
        }, a(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(c) {
            var d = a(this),
                e = d.attr("href"),
                f = a(d.attr("data-target") || e && e.replace(/.*(?=#[^\s]+$)/, "")),
                g = f.data("bs.modal") ? "toggle" : a.extend({
                    remote: !/#/.test(e) && e
                }, f.data(), d.data());
            d.is("a") && c.preventDefault(), f.one("show.bs.modal", function(a) {
                a.isDefaultPrevented() || f.one("hidden.bs.modal", function() {
                    d.is(":visible") && d.trigger("focus")
                })
            }), b.call(f, g, this)
        })
    }(jQuery), + function(a) {
        "use strict";

        function b(b) {
            return this.each(function() {
                var d = a(this),
                    e = d.data("bs.tooltip"),
                    f = "object" == typeof b && b;
                !e && /destroy|hide/.test(b) || (e || d.data("bs.tooltip", e = new c(this, f)), "string" == typeof b && e[b]())
            })
        }
        var c = function(a, b) {
            this.type = null, this.options = null, this.enabled = null, this.timeout = null, this.hoverState = null, this.$element = null, this.inState = null, this.init("tooltip", a, b)
        };
        c.VERSION = "3.3.7", c.TRANSITION_DURATION = 150, c.DEFAULTS = {
            animation: !0,
            placement: "top",
            selector: !1,
            template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
            trigger: "hover focus",
            title: "",
            delay: 0,
            html: !1,
            container: !1,
            viewport: {
                selector: "body",
                padding: 0
            }
        }, c.prototype.init = function(b, c, d) {
            if (this.enabled = !0, this.type = b, this.$element = a(c), this.options = this.getOptions(d), this.$viewport = this.options.viewport && a(a.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), this.inState = {
                    click: !1,
                    hover: !1,
                    focus: !1
                }, this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
            for (var e = this.options.trigger.split(" "), f = e.length; f--;) {
                var g = e[f];
                if ("click" == g) this.$element.on("click." + this.type, this.options.selector, a.proxy(this.toggle, this));
                else if ("manual" != g) {
                    var h = "hover" == g ? "mouseenter" : "focusin",
                        i = "hover" == g ? "mouseleave" : "focusout";
                    this.$element.on(h + "." + this.type, this.options.selector, a.proxy(this.enter, this)), this.$element.on(i + "." + this.type, this.options.selector, a.proxy(this.leave, this))
                }
            }
            this.options.selector ? this._options = a.extend({}, this.options, {
                trigger: "manual",
                selector: ""
            }) : this.fixTitle()
        }, c.prototype.getDefaults = function() {
            return c.DEFAULTS
        }, c.prototype.getOptions = function(b) {
            return b = a.extend({}, this.getDefaults(), this.$element.data(), b), b.delay && "number" == typeof b.delay && (b.delay = {
                show: b.delay,
                hide: b.delay
            }), b
        }, c.prototype.getDelegateOptions = function() {
            var b = {},
                c = this.getDefaults();
            return this._options && a.each(this._options, function(a, d) {
                c[a] != d && (b[a] = d)
            }), b
        }, c.prototype.enter = function(b) {
            var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type);
            return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), b instanceof a.Event && (c.inState["focusin" == b.type ? "focus" : "hover"] = !0), c.tip().hasClass("in") || "in" == c.hoverState ? void(c.hoverState = "in") : (clearTimeout(c.timeout), c.hoverState = "in", c.options.delay && c.options.delay.show ? void(c.timeout = setTimeout(function() {
                "in" == c.hoverState && c.show()
            }, c.options.delay.show)) : c.show())
        }, c.prototype.isInStateTrue = function() {
            for (var a in this.inState)
                if (this.inState[a]) return !0;
            return !1
        }, c.prototype.leave = function(b) {
            var c = b instanceof this.constructor ? b : a(b.currentTarget).data("bs." + this.type);
            if (c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c)), b instanceof a.Event && (c.inState["focusout" == b.type ? "focus" : "hover"] = !1), !c.isInStateTrue()) return clearTimeout(c.timeout), c.hoverState = "out", c.options.delay && c.options.delay.hide ? void(c.timeout = setTimeout(function() {
                "out" == c.hoverState && c.hide()
            }, c.options.delay.hide)) : c.hide()
        }, c.prototype.show = function() {
            var b = a.Event("show.bs." + this.type);
            if (this.hasContent() && this.enabled) {
                this.$element.trigger(b);
                var d = a.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
                if (b.isDefaultPrevented() || !d) return;
                var e = this,
                    f = this.tip(),
                    g = this.getUID(this.type);
                this.setContent(), f.attr("id", g), this.$element.attr("aria-describedby", g), this.options.animation && f.addClass("fade");
                var h = "function" == typeof this.options.placement ? this.options.placement.call(this, f[0], this.$element[0]) : this.options.placement,
                    i = /\s?auto?\s?/i,
                    j = i.test(h);
                j && (h = h.replace(i, "") || "top"), f.detach().css({
                    top: 0,
                    left: 0,
                    display: "block"
                }).addClass(h).data("bs." + this.type, this), this.options.container ? f.appendTo(this.options.container) : f.insertAfter(this.$element), this.$element.trigger("inserted.bs." + this.type);
                var k = this.getPosition(),
                    l = f[0].offsetWidth,
                    m = f[0].offsetHeight;
                if (j) {
                    var n = h,
                        o = this.getPosition(this.$viewport);
                    h = "bottom" == h && k.bottom + m > o.bottom ? "top" : "top" == h && k.top - m < o.top ? "bottom" : "right" == h && k.right + l > o.width ? "left" : "left" == h && k.left - l < o.left ? "right" : h, f.removeClass(n).addClass(h)
                }
                var p = this.getCalculatedOffset(h, k, l, m);
                this.applyPlacement(p, h);
                var q = function() {
                    var a = e.hoverState;
                    e.$element.trigger("shown.bs." + e.type), e.hoverState = null, "out" == a && e.leave(e)
                };
                a.support.transition && this.$tip.hasClass("fade") ? f.one("bsTransitionEnd", q).emulateTransitionEnd(c.TRANSITION_DURATION) : q()
            }
        }, c.prototype.applyPlacement = function(b, c) {
            var d = this.tip(),
                e = d[0].offsetWidth,
                f = d[0].offsetHeight,
                g = parseInt(d.css("margin-top"), 10),
                h = parseInt(d.css("margin-left"), 10);
            isNaN(g) && (g = 0), isNaN(h) && (h = 0), b.top += g, b.left += h, a.offset.setOffset(d[0], a.extend({
                using: function(a) {
                    d.css({
                        top: Math.round(a.top),
                        left: Math.round(a.left)
                    })
                }
            }, b), 0), d.addClass("in");
            var i = d[0].offsetWidth,
                j = d[0].offsetHeight;
            "top" == c && j != f && (b.top = b.top + f - j);
            var k = this.getViewportAdjustedDelta(c, b, i, j);
            k.left ? b.left += k.left : b.top += k.top;
            var l = /top|bottom/.test(c),
                m = l ? 2 * k.left - e + i : 2 * k.top - f + j,
                n = l ? "offsetWidth" : "offsetHeight";
            d.offset(b), this.replaceArrow(m, d[0][n], l)
        }, c.prototype.replaceArrow = function(a, b, c) {
            this.arrow().css(c ? "left" : "top", 50 * (1 - a / b) + "%").css(c ? "top" : "left", "")
        }, c.prototype.setContent = function() {
            var a = this.tip(),
                b = this.getTitle();
            a.find(".tooltip-inner")[this.options.html ? "html" : "text"](b), a.removeClass("fade in top bottom left right")
        }, c.prototype.hide = function(b) {
            function d() {
                "in" != e.hoverState && f.detach(), e.$element && e.$element.removeAttr("aria-describedby").trigger("hidden.bs." + e.type), b && b()
            }
            var e = this,
                f = a(this.$tip),
                g = a.Event("hide.bs." + this.type);
            if (this.$element.trigger(g), !g.isDefaultPrevented()) return f.removeClass("in"), a.support.transition && f.hasClass("fade") ? f.one("bsTransitionEnd", d).emulateTransitionEnd(c.TRANSITION_DURATION) : d(), this.hoverState = null, this
        }, c.prototype.fixTitle = function() {
            var a = this.$element;
            (a.attr("title") || "string" != typeof a.attr("data-original-title")) && a.attr("data-original-title", a.attr("title") || "").attr("title", "")
        }, c.prototype.hasContent = function() {
            return this.getTitle()
        }, c.prototype.getPosition = function(b) {
            b = b || this.$element;
            var c = b[0],
                d = "BODY" == c.tagName,
                e = c.getBoundingClientRect();
            null == e.width && (e = a.extend({}, e, {
                width: e.right - e.left,
                height: e.bottom - e.top
            }));
            var f = window.SVGElement && c instanceof window.SVGElement,
                g = d ? {
                    top: 0,
                    left: 0
                } : f ? null : b.offset(),
                h = {
                    scroll: d ? document.documentElement.scrollTop || document.body.scrollTop : b.scrollTop()
                },
                i = d ? {
                    width: a(window).width(),
                    height: a(window).height()
                } : null;
            return a.extend({}, e, h, i, g)
        }, c.prototype.getCalculatedOffset = function(a, b, c, d) {
            return "bottom" == a ? {
                top: b.top + b.height,
                left: b.left + b.width / 2 - c / 2
            } : "top" == a ? {
                top: b.top - d,
                left: b.left + b.width / 2 - c / 2
            } : "left" == a ? {
                top: b.top + b.height / 2 - d / 2,
                left: b.left - c
            } : {
                top: b.top + b.height / 2 - d / 2,
                left: b.left + b.width
            }
        }, c.prototype.getViewportAdjustedDelta = function(a, b, c, d) {
            var e = {
                top: 0,
                left: 0
            };
            if (!this.$viewport) return e;
            var f = this.options.viewport && this.options.viewport.padding || 0,
                g = this.getPosition(this.$viewport);
            if (/right|left/.test(a)) {
                var h = b.top - f - g.scroll,
                    i = b.top + f - g.scroll + d;
                h < g.top ? e.top = g.top - h : i > g.top + g.height && (e.top = g.top + g.height - i)
            } else {
                var j = b.left - f,
                    k = b.left + f + c;
                j < g.left ? e.left = g.left - j : k > g.right && (e.left = g.left + g.width - k)
            }
            return e
        }, c.prototype.getTitle = function() {
            var a, b = this.$element,
                c = this.options;
            return a = b.attr("data-original-title") || ("function" == typeof c.title ? c.title.call(b[0]) : c.title)
        }, c.prototype.getUID = function(a) {
            do a += ~~(1e6 * Math.random()); while (document.getElementById(a));
            return a
        }, c.prototype.tip = function() {
            if (!this.$tip && (this.$tip = a(this.options.template), 1 != this.$tip.length)) throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");
            return this.$tip
        }, c.prototype.arrow = function() {
            return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
        }, c.prototype.enable = function() {
            this.enabled = !0
        }, c.prototype.disable = function() {
            this.enabled = !1
        }, c.prototype.toggleEnabled = function() {
            this.enabled = !this.enabled
        }, c.prototype.toggle = function(b) {
            var c = this;
            b && (c = a(b.currentTarget).data("bs." + this.type), c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data("bs." + this.type, c))), b ? (c.inState.click = !c.inState.click, c.isInStateTrue() ? c.enter(c) : c.leave(c)) : c.tip().hasClass("in") ? c.leave(c) : c.enter(c)
        }, c.prototype.destroy = function() {
            var a = this;
            clearTimeout(this.timeout), this.hide(function() {
                a.$element.off("." + a.type).removeData("bs." + a.type), a.$tip && a.$tip.detach(), a.$tip = null, a.$arrow = null, a.$viewport = null, a.$element = null
            })
        };
        var d = a.fn.tooltip;
        a.fn.tooltip = b, a.fn.tooltip.Constructor = c, a.fn.tooltip.noConflict = function() {
            return a.fn.tooltip = d, this
        }
    }(jQuery), + function(a) {
        "use strict";

        function b(b) {
            return this.each(function() {
                var d = a(this),
                    e = d.data("bs.popover"),
                    f = "object" == typeof b && b;
                !e && /destroy|hide/.test(b) || (e || d.data("bs.popover", e = new c(this, f)), "string" == typeof b && e[b]())
            })
        }
        var c = function(a, b) {
            this.init("popover", a, b)
        };
        if (!a.fn.tooltip) throw new Error("Popover requires tooltip.js");
        c.VERSION = "3.3.7", c.DEFAULTS = a.extend({}, a.fn.tooltip.Constructor.DEFAULTS, {
            placement: "right",
            trigger: "click",
            content: "",
            template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
        }), c.prototype = a.extend({}, a.fn.tooltip.Constructor.prototype), c.prototype.constructor = c, c.prototype.getDefaults = function() {
            return c.DEFAULTS
        }, c.prototype.setContent = function() {
            var a = this.tip(),
                b = this.getTitle(),
                c = this.getContent();
            a.find(".popover-title")[this.options.html ? "html" : "text"](b), a.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof c ? "html" : "append" : "text"](c), a.removeClass("fade top bottom left right in"), a.find(".popover-title").html() || a.find(".popover-title").hide()
        }, c.prototype.hasContent = function() {
            return this.getTitle() || this.getContent()
        }, c.prototype.getContent = function() {
            var a = this.$element,
                b = this.options;
            return a.attr("data-content") || ("function" == typeof b.content ? b.content.call(a[0]) : b.content)
        }, c.prototype.arrow = function() {
            return this.$arrow = this.$arrow || this.tip().find(".arrow")
        };
        var d = a.fn.popover;
        a.fn.popover = b, a.fn.popover.Constructor = c, a.fn.popover.noConflict = function() {
            return a.fn.popover = d, this
        }
    }(jQuery), + function(a) {
        "use strict";

        function b(c, d) {
            this.$body = a(document.body), this.$scrollElement = a(a(c).is(document.body) ? window : c), this.options = a.extend({}, b.DEFAULTS, d), this.selector = (this.options.target || "") + " .nav li > a", this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, this.$scrollElement.on("scroll.bs.scrollspy", a.proxy(this.process, this)), this.refresh(), this.process()
        }

        function c(c) {
            return this.each(function() {
                var d = a(this),
                    e = d.data("bs.scrollspy"),
                    f = "object" == typeof c && c;
                e || d.data("bs.scrollspy", e = new b(this, f)), "string" == typeof c && e[c]()
            })
        }
        b.VERSION = "3.3.7", b.DEFAULTS = {
            offset: 10
        }, b.prototype.getScrollHeight = function() {
            return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
        }, b.prototype.refresh = function() {
            var b = this,
                c = "offset",
                d = 0;
            this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), a.isWindow(this.$scrollElement[0]) || (c = "position", d = this.$scrollElement.scrollTop()), this.$body.find(this.selector).map(function() {
                var b = a(this),
                    e = b.data("target") || b.attr("href"),
                    f = /^#./.test(e) && a(e);
                return f && f.length && f.is(":visible") && [
                    [f[c]().top + d, e]
                ] || null
            }).sort(function(a, b) {
                return a[0] - b[0]
            }).each(function() {
                b.offsets.push(this[0]), b.targets.push(this[1])
            })
        }, b.prototype.process = function() {
            var a, b = this.$scrollElement.scrollTop() + this.options.offset,
                c = this.getScrollHeight(),
                d = this.options.offset + c - this.$scrollElement.height(),
                e = this.offsets,
                f = this.targets,
                g = this.activeTarget;
            if (this.scrollHeight != c && this.refresh(), b >= d) return g != (a = f[f.length - 1]) && this.activate(a);
            if (g && b < e[0]) return this.activeTarget = null, this.clear();
            for (a = e.length; a--;) g != f[a] && b >= e[a] && (void 0 === e[a + 1] || b < e[a + 1]) && this.activate(f[a])
        }, b.prototype.activate = function(b) {
            this.activeTarget = b, this.clear();
            var c = this.selector + '[data-target="' + b + '"],' + this.selector + '[href="' + b + '"]',
                d = a(c).parents("li").addClass("active");
            d.parent(".dropdown-menu").length && (d = d.closest("li.dropdown").addClass("active")), d.trigger("activate.bs.scrollspy")
        }, b.prototype.clear = function() {
            a(this.selector).parentsUntil(this.options.target, ".active").removeClass("active")
        };
        var d = a.fn.scrollspy;
        a.fn.scrollspy = c, a.fn.scrollspy.Constructor = b, a.fn.scrollspy.noConflict = function() {
            return a.fn.scrollspy = d, this
        }, a(window).on("load.bs.scrollspy.data-api", function() {
            a('[data-spy="scroll"]').each(function() {
                var b = a(this);
                c.call(b, b.data())
            })
        })
    }(jQuery), + function(a) {
        "use strict";

        function b(b) {
            return this.each(function() {
                var d = a(this),
                    e = d.data("bs.tab");
                e || d.data("bs.tab", e = new c(this)), "string" == typeof b && e[b]()
            })
        }
        var c = function(b) {
            this.element = a(b)
        };
        c.VERSION = "3.3.7", c.TRANSITION_DURATION = 150, c.prototype.show = function() {
            var b = this.element,
                c = b.closest("ul:not(.dropdown-menu)"),
                d = b.data("target");
            if (d || (d = b.attr("href"), d = d && d.replace(/.*(?=#[^\s]*$)/, "")), !b.parent("li").hasClass("active")) {
                var e = c.find(".active:last a"),
                    f = a.Event("hide.bs.tab", {
                        relatedTarget: b[0]
                    }),
                    g = a.Event("show.bs.tab", {
                        relatedTarget: e[0]
                    });
                if (e.trigger(f), b.trigger(g), !g.isDefaultPrevented() && !f.isDefaultPrevented()) {
                    var h = a(d);
                    this.activate(b.closest("li"), c), this.activate(h, h.parent(), function() {
                        e.trigger({
                            type: "hidden.bs.tab",
                            relatedTarget: b[0]
                        }), b.trigger({
                            type: "shown.bs.tab",
                            relatedTarget: e[0]
                        })
                    })
                }
            }
        }, c.prototype.activate = function(b, d, e) {
            function f() {
                g.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1), b.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0), h ? (b[0].offsetWidth, b.addClass("in")) : b.removeClass("fade"), b.parent(".dropdown-menu").length && b.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0), e && e()
            }
            var g = d.find("> .active"),
                h = e && a.support.transition && (g.length && g.hasClass("fade") || !!d.find("> .fade").length);
            g.length && h ? g.one("bsTransitionEnd", f).emulateTransitionEnd(c.TRANSITION_DURATION) : f(), g.removeClass("in")
        };
        var d = a.fn.tab;
        a.fn.tab = b, a.fn.tab.Constructor = c, a.fn.tab.noConflict = function() {
            return a.fn.tab = d, this
        };
        var e = function(c) {
            c.preventDefault(), b.call(a(this), "show")
        };
        a(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', e).on("click.bs.tab.data-api", '[data-toggle="pill"]', e)
    }(jQuery), + function(a) {
        "use strict";

        function b(b) {
            return this.each(function() {
                var d = a(this),
                    e = d.data("bs.affix"),
                    f = "object" == typeof b && b;
                e || d.data("bs.affix", e = new c(this, f)), "string" == typeof b && e[b]()
            })
        }
        var c = function(b, d) {
            this.options = a.extend({}, c.DEFAULTS, d), this.$target = a(this.options.target).on("scroll.bs.affix.data-api", a.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", a.proxy(this.checkPositionWithEventLoop, this)), this.$element = a(b), this.affixed = null, this.unpin = null, this.pinnedOffset = null, this.checkPosition()
        };
        c.VERSION = "3.3.7", c.RESET = "affix affix-top affix-bottom", c.DEFAULTS = {
            offset: 0,
            target: window
        }, c.prototype.getState = function(a, b, c, d) {
            var e = this.$target.scrollTop(),
                f = this.$element.offset(),
                g = this.$target.height();
            if (null != c && "top" == this.affixed) return e < c && "top";
            if ("bottom" == this.affixed) return null != c ? !(e + this.unpin <= f.top) && "bottom" : !(e + g <= a - d) && "bottom";
            var h = null == this.affixed,
                i = h ? e : f.top,
                j = h ? g : b;
            return null != c && e <= c ? "top" : null != d && i + j >= a - d && "bottom"
        }, c.prototype.getPinnedOffset = function() {
            if (this.pinnedOffset) return this.pinnedOffset;
            this.$element.removeClass(c.RESET).addClass("affix");
            var a = this.$target.scrollTop(),
                b = this.$element.offset();
            return this.pinnedOffset = b.top - a
        }, c.prototype.checkPositionWithEventLoop = function() {
            setTimeout(a.proxy(this.checkPosition, this), 1)
        }, c.prototype.checkPosition = function() {
            if (this.$element.is(":visible")) {
                var b = this.$element.height(),
                    d = this.options.offset,
                    e = d.top,
                    f = d.bottom,
                    g = Math.max(a(document).height(), a(document.body).height());
                "object" != typeof d && (f = e = d), "function" == typeof e && (e = d.top(this.$element)), "function" == typeof f && (f = d.bottom(this.$element));
                var h = this.getState(g, b, e, f);
                if (this.affixed != h) {
                    null != this.unpin && this.$element.css("top", "");
                    var i = "affix" + (h ? "-" + h : ""),
                        j = a.Event(i + ".bs.affix");
                    if (this.$element.trigger(j), j.isDefaultPrevented()) return;
                    this.affixed = h, this.unpin = "bottom" == h ? this.getPinnedOffset() : null, this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace("affix", "affixed") + ".bs.affix")
                }
                "bottom" == h && this.$element.offset({
                    top: g - b - f
                })
            }
        };
        var d = a.fn.affix;
        a.fn.affix = b, a.fn.affix.Constructor = c, a.fn.affix.noConflict = function() {
            return a.fn.affix = d, this
        }, a(window).on("load", function() {
            a('[data-spy="affix"]').each(function() {
                var c = a(this),
                    d = c.data();
                d.offset = d.offset || {}, null != d.offsetBottom && (d.offset.bottom = d.offsetBottom), null != d.offsetTop && (d.offset.top = d.offsetTop), b.call(c, d)
            })
        })
    }(jQuery), ! function(a) {
        function b() {}

        function c(a, b) {
            return function() {
                a.apply(b, arguments)
            }
        }

        function d(a) {
            if ("object" != typeof this) throw new TypeError("Promises must be constructed via new");
            if ("function" != typeof a) throw new TypeError("not a function");
            this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], j(a, this)
        }

        function e(a, b) {
            for (; 3 === a._state;) a = a._value;
            return 0 === a._state ? void a._deferreds.push(b) : (a._handled = !0, void d._immediateFn(function() {
                var c = 1 === a._state ? b.onFulfilled : b.onRejected;
                if (null === c) return void(1 === a._state ? f : g)(b.promise, a._value);
                var d;
                try {
                    d = c(a._value)
                } catch (a) {
                    return void g(b.promise, a)
                }
                f(b.promise, d)
            }))
        }

        function f(a, b) {
            try {
                if (b === a) throw new TypeError("A promise cannot be resolved with itself.");
                if (b && ("object" == typeof b || "function" == typeof b)) {
                    var e = b.then;
                    if (b instanceof d) return a._state = 3, a._value = b, void h(a);
                    if ("function" == typeof e) return void j(c(e, b), a)
                }
                a._state = 1, a._value = b, h(a)
            } catch (b) {
                g(a, b)
            }
        }

        function g(a, b) {
            a._state = 2, a._value = b, h(a)
        }

        function h(a) {
            2 === a._state && 0 === a._deferreds.length && d._immediateFn(function() {
                a._handled || d._unhandledRejectionFn(a._value)
            });
            for (var b = 0, c = a._deferreds.length; b < c; b++) e(a, a._deferreds[b]);
            a._deferreds = null
        }

        function i(a, b, c) {
            this.onFulfilled = "function" == typeof a ? a : null, this.onRejected = "function" == typeof b ? b : null, this.promise = c
        }

        function j(a, b) {
            var c = !1;
            try {
                a(function(a) {
                    c || (c = !0, f(b, a))
                }, function(a) {
                    c || (c = !0, g(b, a))
                })
            } catch (a) {
                if (c) return;
                c = !0, g(b, a)
            }
        }
        var k = setTimeout;
        d.prototype.catch = function(a) {
            return this.then(null, a)
        }, d.prototype.then = function(a, c) {
            var d = new this.constructor(b);
            return e(this, new i(a, c, d)), d
        }, d.all = function(a) {
            var b = Array.prototype.slice.call(a);
            return new d(function(a, c) {
                function d(f, g) {
                    try {
                        if (g && ("object" == typeof g || "function" == typeof g)) {
                            var h = g.then;
                            if ("function" == typeof h) return void h.call(g, function(a) {
                                d(f, a)
                            }, c)
                        }
                        b[f] = g, 0 === --e && a(b)
                    } catch (a) {
                        c(a)
                    }
                }
                if (0 === b.length) return a([]);
                for (var e = b.length, f = 0; f < b.length; f++) d(f, b[f])
            })
        }, d.resolve = function(a) {
            return a && "object" == typeof a && a.constructor === d ? a : new d(function(b) {
                b(a)
            })
        }, d.reject = function(a) {
            return new d(function(b, c) {
                c(a)
            })
        }, d.race = function(a) {
            return new d(function(b, c) {
                for (var d = 0, e = a.length; d < e; d++) a[d].then(b, c)
            })
        }, d._immediateFn = "function" == typeof setImmediate && function(a) {
            setImmediate(a)
        } || function(a) {
            k(a, 0)
        }, d._unhandledRejectionFn = function(a) {
            "undefined" != typeof console && console && console.warn("Possible Unhandled Promise Rejection:", a)
        }, d._setImmediateFn = function(a) {
            d._immediateFn = a
        }, d._setUnhandledRejectionFn = function(a) {
            d._unhandledRejectionFn = a
        }, "undefined" != typeof module && module.exports ? module.exports = d : a.Promise || (a.Promise = d)
    }(this),
    function(a, b) {
        "object" == typeof exports && "object" == typeof module ? module.exports = b() : "function" == typeof define && define.amd ? define([], b) : "object" == typeof exports ? exports.io = b() : a.io = b()
    }(this, function() {
        return function(a) {
            function b(d) {
                if (c[d]) return c[d].exports;
                var e = c[d] = {
                    exports: {},
                    id: d,
                    loaded: !1
                };
                return a[d].call(e.exports, e, e.exports, b),
                    e.loaded = !0, e.exports
            }
            var c = {};
            return b.m = a, b.c = c, b.p = "", b(0)
        }([function(a, b, c) {
            "use strict";

            function d(a, b) {
                "object" === ("undefined" == typeof a ? "undefined" : f(a)) && (b = a, a = void 0), b = b || {};
                var c, d = g(a),
                    h = d.source,
                    l = d.id,
                    m = d.path,
                    n = k[l] && m in k[l].nsps,
                    o = b.forceNew || b["force new connection"] || !1 === b.multiplex || n;
                return o ? (j("ignoring socket cache for %s", h), c = i(h, b)) : (k[l] || (j("new io instance for %s", h), k[l] = i(h, b)), c = k[l]), d.query && !b.query ? b.query = d.query : b && "object" === f(b.query) && (b.query = e(b.query)), c.socket(d.path, b)
            }

            function e(a) {
                var b = [];
                for (var c in a) a.hasOwnProperty(c) && b.push(encodeURIComponent(c) + "=" + encodeURIComponent(a[c]));
                return b.join("&")
            }
            var f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(a) {
                    return typeof a
                } : function(a) {
                    return a && "function" == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
                },
                g = c(1),
                h = c(6),
                i = c(14),
                j = c(3)("socket.io-client");
            a.exports = b = d;
            var k = b.managers = {};
            b.protocol = h.protocol, b.connect = d, b.Manager = c(14), b.Socket = c(42)
        }, function(a, b, c) {
            (function(b) {
                "use strict";

                function d(a, c) {
                    var d = a;
                    c = c || b.location, null == a && (a = c.protocol + "//" + c.host), "string" == typeof a && ("/" === a.charAt(0) && (a = "/" === a.charAt(1) ? c.protocol + a : c.host + a), /^(https?|wss?):\/\//.test(a) || (f("protocol-less url %s", a), a = "undefined" != typeof c ? c.protocol + "//" + a : "https://" + a), f("parse %s", a), d = e(a)), d.port || (/^(http|ws)$/.test(d.protocol) ? d.port = "80" : /^(http|ws)s$/.test(d.protocol) && (d.port = "443")), d.path = d.path || "/";
                    var g = d.host.indexOf(":") !== -1,
                        h = g ? "[" + d.host + "]" : d.host;
                    return d.id = d.protocol + "://" + h + ":" + d.port, d.href = d.protocol + "://" + h + (c && c.port === d.port ? "" : ":" + d.port), d
                }
                var e = c(2),
                    f = c(3)("socket.io-client:url");
                a.exports = d
            }).call(b, function() {
                return this
            }())
        }, function(a, b) {
            var c = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
                d = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"];
            a.exports = function(a) {
                var b = a,
                    e = a.indexOf("["),
                    f = a.indexOf("]");
                e != -1 && f != -1 && (a = a.substring(0, e) + a.substring(e, f).replace(/:/g, ";") + a.substring(f, a.length));
                for (var g = c.exec(a || ""), h = {}, i = 14; i--;) h[d[i]] = g[i] || "";
                return e != -1 && f != -1 && (h.source = b, h.host = h.host.substring(1, h.host.length - 1).replace(/;/g, ":"), h.authority = h.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), h.ipv6uri = !0), h
            }
        }, function(a, b, c) {
            function d() {
                return "WebkitAppearance" in document.documentElement.style || window.console && (console.firebug || console.exception && console.table) || navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31
            }

            function e() {
                var a = arguments,
                    c = this.useColors;
                if (a[0] = (c ? "%c" : "") + this.namespace + (c ? " %c" : " ") + a[0] + (c ? "%c " : " ") + "+" + b.humanize(this.diff), !c) return a;
                var d = "color: " + this.color;
                a = [a[0], d, "color: inherit"].concat(Array.prototype.slice.call(a, 1));
                var e = 0,
                    f = 0;
                return a[0].replace(/%[a-z%]/g, function(a) {
                    "%%" !== a && (e++, "%c" === a && (f = e))
                }), a.splice(f, 0, d), a
            }

            function f() {
                return "object" == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments)
            }

            function g(a) {
                try {
                    null == a ? b.storage.removeItem("debug") : b.storage.debug = a
                } catch (a) {}
            }

            function h() {
                var a;
                try {
                    a = b.storage.debug
                } catch (a) {}
                return a
            }

            function i() {
                try {
                    return window.localStorage
                } catch (a) {}
            }
            b = a.exports = c(4), b.log = f, b.formatArgs = e, b.save = g, b.load = h, b.useColors = d, b.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : i(), b.colors = ["lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson"], b.formatters.j = function(a) {
                return JSON.stringify(a)
            }, b.enable(h())
        }, function(a, b, c) {
            function d() {
                return b.colors[k++ % b.colors.length]
            }

            function e(a) {
                function c() {}

                function e() {
                    var a = e,
                        c = +new Date,
                        f = c - (j || c);
                    a.diff = f, a.prev = j, a.curr = c, j = c, null == a.useColors && (a.useColors = b.useColors()), null == a.color && a.useColors && (a.color = d());
                    var g = Array.prototype.slice.call(arguments);
                    g[0] = b.coerce(g[0]), "string" != typeof g[0] && (g = ["%o"].concat(g));
                    var h = 0;
                    g[0] = g[0].replace(/%([a-z%])/g, function(c, d) {
                        if ("%%" === c) return c;
                        h++;
                        var e = b.formatters[d];
                        if ("function" == typeof e) {
                            var f = g[h];
                            c = e.call(a, f), g.splice(h, 1), h--
                        }
                        return c
                    }), "function" == typeof b.formatArgs && (g = b.formatArgs.apply(a, g));
                    var i = e.log || b.log || console.log.bind(console);
                    i.apply(a, g)
                }
                c.enabled = !1, e.enabled = !0;
                var f = b.enabled(a) ? e : c;
                return f.namespace = a, f
            }

            function f(a) {
                b.save(a);
                for (var c = (a || "").split(/[\s,]+/), d = c.length, e = 0; e < d; e++) c[e] && (a = c[e].replace(/\*/g, ".*?"), "-" === a[0] ? b.skips.push(new RegExp("^" + a.substr(1) + "$")) : b.names.push(new RegExp("^" + a + "$")))
            }

            function g() {
                b.enable("")
            }

            function h(a) {
                var c, d;
                for (c = 0, d = b.skips.length; c < d; c++)
                    if (b.skips[c].test(a)) return !1;
                for (c = 0, d = b.names.length; c < d; c++)
                    if (b.names[c].test(a)) return !0;
                return !1
            }

            function i(a) {
                return a instanceof Error ? a.stack || a.message : a
            }
            b = a.exports = e, b.coerce = i, b.disable = g, b.enable = f, b.enabled = h, b.humanize = c(5), b.names = [], b.skips = [], b.formatters = {};
            var j, k = 0
        }, function(a, b) {
            function c(a) {
                if (a = "" + a, !(a.length > 1e4)) {
                    var b = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(a);
                    if (b) {
                        var c = parseFloat(b[1]),
                            d = (b[2] || "ms").toLowerCase();
                        switch (d) {
                            case "years":
                            case "year":
                            case "yrs":
                            case "yr":
                            case "y":
                                return c * k;
                            case "days":
                            case "day":
                            case "d":
                                return c * j;
                            case "hours":
                            case "hour":
                            case "hrs":
                            case "hr":
                            case "h":
                                return c * i;
                            case "minutes":
                            case "minute":
                            case "mins":
                            case "min":
                            case "m":
                                return c * h;
                            case "seconds":
                            case "second":
                            case "secs":
                            case "sec":
                            case "s":
                                return c * g;
                            case "milliseconds":
                            case "millisecond":
                            case "msecs":
                            case "msec":
                            case "ms":
                                return c
                        }
                    }
                }
            }

            function d(a) {
                return a >= j ? Math.round(a / j) + "d" : a >= i ? Math.round(a / i) + "h" : a >= h ? Math.round(a / h) + "m" : a >= g ? Math.round(a / g) + "s" : a + "ms"
            }

            function e(a) {
                return f(a, j, "day") || f(a, i, "hour") || f(a, h, "minute") || f(a, g, "second") || a + " ms"
            }

            function f(a, b, c) {
                if (!(a < b)) return a < 1.5 * b ? Math.floor(a / b) + " " + c : Math.ceil(a / b) + " " + c + "s"
            }
            var g = 1e3,
                h = 60 * g,
                i = 60 * h,
                j = 24 * i,
                k = 365.25 * j;
            a.exports = function(a, b) {
                return b = b || {}, "string" == typeof a ? c(a) : b.long ? e(a) : d(a)
            }
        }, function(a, b, c) {
            function d() {}

            function e(a) {
                var c = "",
                    d = !1;
                return c += a.type, b.BINARY_EVENT != a.type && b.BINARY_ACK != a.type || (c += a.attachments, c += "-"), a.nsp && "/" != a.nsp && (d = !0, c += a.nsp), null != a.id && (d && (c += ",", d = !1), c += a.id), null != a.data && (d && (c += ","), c += l.stringify(a.data)), k("encoded %j as %s", a, c), c
            }

            function f(a, b) {
                function c(a) {
                    var c = n.deconstructPacket(a),
                        d = e(c.packet),
                        f = c.buffers;
                    f.unshift(d), b(f)
                }
                n.removeBlobs(a, c)
            }

            function g() {
                this.reconstructor = null
            }

            function h(a) {
                var c = {},
                    d = 0;
                if (c.type = Number(a.charAt(0)), null == b.types[c.type]) return j();
                if (b.BINARY_EVENT == c.type || b.BINARY_ACK == c.type) {
                    for (var e = "";
                        "-" != a.charAt(++d) && (e += a.charAt(d), d != a.length););
                    if (e != Number(e) || "-" != a.charAt(d)) throw new Error("Illegal attachments");
                    c.attachments = Number(e)
                }
                if ("/" == a.charAt(d + 1))
                    for (c.nsp = ""; ++d;) {
                        var f = a.charAt(d);
                        if ("," == f) break;
                        if (c.nsp += f, d == a.length) break
                    } else c.nsp = "/";
                var g = a.charAt(d + 1);
                if ("" !== g && Number(g) == g) {
                    for (c.id = ""; ++d;) {
                        var f = a.charAt(d);
                        if (null == f || Number(f) != f) {
                            --d;
                            break
                        }
                        if (c.id += a.charAt(d), d == a.length) break
                    }
                    c.id = Number(c.id)
                }
                if (a.charAt(++d)) try {
                    c.data = l.parse(a.substr(d))
                } catch (a) {
                    return j()
                }
                return k("decoded %s as %j", a, c), c
            }

            function i(a) {
                this.reconPack = a, this.buffers = []
            }

            function j(a) {
                return {
                    type: b.ERROR,
                    data: "parser error"
                }
            }
            var k = c(3)("socket.io-parser"),
                l = c(7),
                m = (c(10), c(11)),
                n = c(12),
                o = c(13);
            b.protocol = 4, b.types = ["CONNECT", "DISCONNECT", "EVENT", "ACK", "ERROR", "BINARY_EVENT", "BINARY_ACK"], b.CONNECT = 0, b.DISCONNECT = 1, b.EVENT = 2, b.ACK = 3, b.ERROR = 4, b.BINARY_EVENT = 5, b.BINARY_ACK = 6, b.Encoder = d, b.Decoder = g, d.prototype.encode = function(a, c) {
                if (k("encoding packet %j", a), b.BINARY_EVENT == a.type || b.BINARY_ACK == a.type) f(a, c);
                else {
                    var d = e(a);
                    c([d])
                }
            }, m(g.prototype), g.prototype.add = function(a) {
                var c;
                if ("string" == typeof a) c = h(a), b.BINARY_EVENT == c.type || b.BINARY_ACK == c.type ? (this.reconstructor = new i(c), 0 === this.reconstructor.reconPack.attachments && this.emit("decoded", c)) : this.emit("decoded", c);
                else {
                    if (!o(a) && !a.base64) throw new Error("Unknown type: " + a);
                    if (!this.reconstructor) throw new Error("got binary data when not reconstructing a packet");
                    c = this.reconstructor.takeBinaryData(a), c && (this.reconstructor = null, this.emit("decoded", c))
                }
            }, g.prototype.destroy = function() {
                this.reconstructor && this.reconstructor.finishedReconstruction()
            }, i.prototype.takeBinaryData = function(a) {
                if (this.buffers.push(a), this.buffers.length == this.reconPack.attachments) {
                    var b = n.reconstructPacket(this.reconPack, this.buffers);
                    return this.finishedReconstruction(), b
                }
                return null
            }, i.prototype.finishedReconstruction = function() {
                this.reconPack = null, this.buffers = []
            }
        }, function(a, b, c) {
            var d;
            (function(a, e) {
                (function() {
                    function f(a, b) {
                        function c(a) {
                            if (c[a] !== q) return c[a];
                            var f;
                            if ("bug-string-char-index" == a) f = "a" != "a" [0];
                            else if ("json" == a) f = c("json-stringify") && c("json-parse");
                            else {
                                var g, h = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
                                if ("json-stringify" == a) {
                                    var j = b.stringify,
                                        k = "function" == typeof j && t;
                                    if (k) {
                                        (g = function() {
                                            return 1
                                        }).toJSON = g;
                                        try {
                                            k = "0" === j(0) && "0" === j(new d) && '""' == j(new e) && j(s) === q && j(q) === q && j() === q && "1" === j(g) && "[1]" == j([g]) && "[null]" == j([q]) && "null" == j(null) && "[null,null,null]" == j([q, s, null]) && j({
                                                a: [g, !0, !1, null, "\0\b\n\f\r\t"]
                                            }) == h && "1" === j(null, g) && "[\n 1,\n 2\n]" == j([1, 2], null, 1) && '"-271821-04-20T00:00:00.000Z"' == j(new i(-864e13)) && '"+275760-09-13T00:00:00.000Z"' == j(new i(864e13)) && '"-000001-01-01T00:00:00.000Z"' == j(new i(-621987552e5)) && '"1969-12-31T23:59:59.999Z"' == j(new i(-1))
                                        } catch (a) {
                                            k = !1
                                        }
                                    }
                                    f = k
                                }
                                if ("json-parse" == a) {
                                    var l = b.parse;
                                    if ("function" == typeof l) try {
                                        if (0 === l("0") && !l(!1)) {
                                            g = l(h);
                                            var m = 5 == g.a.length && 1 === g.a[0];
                                            if (m) {
                                                try {
                                                    m = !l('"\t"')
                                                } catch (a) {}
                                                if (m) try {
                                                    m = 1 !== l("01")
                                                } catch (a) {}
                                                if (m) try {
                                                    m = 1 !== l("1.")
                                                } catch (a) {}
                                            }
                                        }
                                    } catch (a) {
                                        m = !1
                                    }
                                    f = m
                                }
                            }
                            return c[a] = !!f
                        }
                        a || (a = j.Object()), b || (b = j.Object());
                        var d = a.Number || j.Number,
                            e = a.String || j.String,
                            g = a.Object || j.Object,
                            i = a.Date || j.Date,
                            k = a.SyntaxError || j.SyntaxError,
                            l = a.TypeError || j.TypeError,
                            m = a.Math || j.Math,
                            n = a.JSON || j.JSON;
                        "object" == typeof n && n && (b.stringify = n.stringify, b.parse = n.parse);
                        var o, p, q, r = g.prototype,
                            s = r.toString,
                            t = new i(-0xc782b5b800cec);
                        try {
                            t = t.getUTCFullYear() == -109252 && 0 === t.getUTCMonth() && 1 === t.getUTCDate() && 10 == t.getUTCHours() && 37 == t.getUTCMinutes() && 6 == t.getUTCSeconds() && 708 == t.getUTCMilliseconds()
                        } catch (a) {}
                        if (!c("json")) {
                            var u = "[object Function]",
                                v = "[object Date]",
                                w = "[object Number]",
                                x = "[object String]",
                                y = "[object Array]",
                                z = "[object Boolean]",
                                A = c("bug-string-char-index");
                            if (!t) var B = m.floor,
                                C = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
                                D = function(a, b) {
                                    return C[b] + 365 * (a - 1970) + B((a - 1969 + (b = +(b > 1))) / 4) - B((a - 1901 + b) / 100) + B((a - 1601 + b) / 400)
                                };
                            if ((o = r.hasOwnProperty) || (o = function(a) {
                                    var b, c = {};
                                    return (c.__proto__ = null, c.__proto__ = {
                                        toString: 1
                                    }, c).toString != s ? o = function(a) {
                                        var b = this.__proto__,
                                            c = a in (this.__proto__ = null, this);
                                        return this.__proto__ = b, c
                                    } : (b = c.constructor, o = function(a) {
                                        var c = (this.constructor || b).prototype;
                                        return a in this && !(a in c && this[a] === c[a])
                                    }), c = null, o.call(this, a)
                                }), p = function(a, b) {
                                    var c, d, e, f = 0;
                                    (c = function() {
                                        this.valueOf = 0
                                    }).prototype.valueOf = 0, d = new c;
                                    for (e in d) o.call(d, e) && f++;
                                    return c = d = null, f ? p = 2 == f ? function(a, b) {
                                        var c, d = {},
                                            e = s.call(a) == u;
                                        for (c in a) e && "prototype" == c || o.call(d, c) || !(d[c] = 1) || !o.call(a, c) || b(c)
                                    } : function(a, b) {
                                        var c, d, e = s.call(a) == u;
                                        for (c in a) e && "prototype" == c || !o.call(a, c) || (d = "constructor" === c) || b(c);
                                        (d || o.call(a, c = "constructor")) && b(c)
                                    } : (d = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"], p = function(a, b) {
                                        var c, e, f = s.call(a) == u,
                                            g = !f && "function" != typeof a.constructor && h[typeof a.hasOwnProperty] && a.hasOwnProperty || o;
                                        for (c in a) f && "prototype" == c || !g.call(a, c) || b(c);
                                        for (e = d.length; c = d[--e]; g.call(a, c) && b(c));
                                    }), p(a, b)
                                }, !c("json-stringify")) {
                                var E = {
                                        92: "\\\\",
                                        34: '\\"',
                                        8: "\\b",
                                        12: "\\f",
                                        10: "\\n",
                                        13: "\\r",
                                        9: "\\t"
                                    },
                                    F = "000000",
                                    G = function(a, b) {
                                        return (F + (b || 0)).slice(-a)
                                    },
                                    H = "\\u00",
                                    I = function(a) {
                                        for (var b = '"', c = 0, d = a.length, e = !A || d > 10, f = e && (A ? a.split("") : a); c < d; c++) {
                                            var g = a.charCodeAt(c);
                                            switch (g) {
                                                case 8:
                                                case 9:
                                                case 10:
                                                case 12:
                                                case 13:
                                                case 34:
                                                case 92:
                                                    b += E[g];
                                                    break;
                                                default:
                                                    if (g < 32) {
                                                        b += H + G(2, g.toString(16));
                                                        break
                                                    }
                                                    b += e ? f[c] : a.charAt(c)
                                            }
                                        }
                                        return b + '"'
                                    },
                                    J = function(a, b, c, d, e, f, g) {
                                        var h, i, j, k, m, n, r, t, u, A, C, E, F, H, K, L;
                                        try {
                                            h = b[a]
                                        } catch (a) {}
                                        if ("object" == typeof h && h)
                                            if (i = s.call(h), i != v || o.call(h, "toJSON")) "function" == typeof h.toJSON && (i != w && i != x && i != y || o.call(h, "toJSON")) && (h = h.toJSON(a));
                                            else if (h > -1 / 0 && h < 1 / 0) {
                                            if (D) {
                                                for (m = B(h / 864e5), j = B(m / 365.2425) + 1970 - 1; D(j + 1, 0) <= m; j++);
                                                for (k = B((m - D(j, 0)) / 30.42); D(j, k + 1) <= m; k++);
                                                m = 1 + m - D(j, k), n = (h % 864e5 + 864e5) % 864e5, r = B(n / 36e5) % 24, t = B(n / 6e4) % 60, u = B(n / 1e3) % 60, A = n % 1e3
                                            } else j = h.getUTCFullYear(), k = h.getUTCMonth(), m = h.getUTCDate(), r = h.getUTCHours(), t = h.getUTCMinutes(), u = h.getUTCSeconds(), A = h.getUTCMilliseconds();
                                            h = (j <= 0 || j >= 1e4 ? (j < 0 ? "-" : "+") + G(6, j < 0 ? -j : j) : G(4, j)) + "-" + G(2, k + 1) + "-" + G(2, m) + "T" + G(2, r) + ":" + G(2, t) + ":" + G(2, u) + "." + G(3, A) + "Z"
                                        } else h = null;
                                        if (c && (h = c.call(b, a, h)), null === h) return "null";
                                        if (i = s.call(h), i == z) return "" + h;
                                        if (i == w) return h > -1 / 0 && h < 1 / 0 ? "" + h : "null";
                                        if (i == x) return I("" + h);
                                        if ("object" == typeof h) {
                                            for (H = g.length; H--;)
                                                if (g[H] === h) throw l();
                                            if (g.push(h), C = [], K = f, f += e, i == y) {
                                                for (F = 0, H = h.length; F < H; F++) E = J(F, h, c, d, e, f, g), C.push(E === q ? "null" : E);
                                                L = C.length ? e ? "[\n" + f + C.join(",\n" + f) + "\n" + K + "]" : "[" + C.join(",") + "]" : "[]"
                                            } else p(d || h, function(a) {
                                                var b = J(a, h, c, d, e, f, g);
                                                b !== q && C.push(I(a) + ":" + (e ? " " : "") + b)
                                            }), L = C.length ? e ? "{\n" + f + C.join(",\n" + f) + "\n" + K + "}" : "{" + C.join(",") + "}" : "{}";
                                            return g.pop(), L
                                        }
                                    };
                                b.stringify = function(a, b, c) {
                                    var d, e, f, g;
                                    if (h[typeof b] && b)
                                        if ((g = s.call(b)) == u) e = b;
                                        else if (g == y) {
                                        f = {};
                                        for (var i, j = 0, k = b.length; j < k; i = b[j++], g = s.call(i), (g == x || g == w) && (f[i] = 1));
                                    }
                                    if (c)
                                        if ((g = s.call(c)) == w) {
                                            if ((c -= c % 1) > 0)
                                                for (d = "", c > 10 && (c = 10); d.length < c; d += " ");
                                        } else g == x && (d = c.length <= 10 ? c : c.slice(0, 10));
                                    return J("", (i = {}, i[""] = a, i), e, f, d, "", [])
                                }
                            }
                            if (!c("json-parse")) {
                                var K, L, M = e.fromCharCode,
                                    N = {
                                        92: "\\",
                                        34: '"',
                                        47: "/",
                                        98: "\b",
                                        116: "\t",
                                        110: "\n",
                                        102: "\f",
                                        114: "\r"
                                    },
                                    O = function() {
                                        throw K = L = null, k()
                                    },
                                    P = function() {
                                        for (var a, b, c, d, e, f = L, g = f.length; K < g;) switch (e = f.charCodeAt(K)) {
                                            case 9:
                                            case 10:
                                            case 13:
                                            case 32:
                                                K++;
                                                break;
                                            case 123:
                                            case 125:
                                            case 91:
                                            case 93:
                                            case 58:
                                            case 44:
                                                return a = A ? f.charAt(K) : f[K], K++, a;
                                            case 34:
                                                for (a = "@", K++; K < g;)
                                                    if (e = f.charCodeAt(K), e < 32) O();
                                                    else if (92 == e) switch (e = f.charCodeAt(++K)) {
                                                    case 92:
                                                    case 34:
                                                    case 47:
                                                    case 98:
                                                    case 116:
                                                    case 110:
                                                    case 102:
                                                    case 114:
                                                        a += N[e], K++;
                                                        break;
                                                    case 117:
                                                        for (b = ++K, c = K + 4; K < c; K++) e = f.charCodeAt(K), e >= 48 && e <= 57 || e >= 97 && e <= 102 || e >= 65 && e <= 70 || O();
                                                        a += M("0x" + f.slice(b, K));
                                                        break;
                                                    default:
                                                        O()
                                                } else {
                                                    if (34 == e) break;
                                                    for (e = f.charCodeAt(K), b = K; e >= 32 && 92 != e && 34 != e;) e = f.charCodeAt(++K);
                                                    a += f.slice(b, K)
                                                }
                                                if (34 == f.charCodeAt(K)) return K++, a;
                                                O();
                                            default:
                                                if (b = K, 45 == e && (d = !0, e = f.charCodeAt(++K)), e >= 48 && e <= 57) {
                                                    for (48 == e && (e = f.charCodeAt(K + 1), e >= 48 && e <= 57) && O(), d = !1; K < g && (e = f.charCodeAt(K), e >= 48 && e <= 57); K++);
                                                    if (46 == f.charCodeAt(K)) {
                                                        for (c = ++K; c < g && (e = f.charCodeAt(c), e >= 48 && e <= 57); c++);
                                                        c == K && O(), K = c
                                                    }
                                                    if (e = f.charCodeAt(K), 101 == e || 69 == e) {
                                                        for (e = f.charCodeAt(++K), 43 != e && 45 != e || K++, c = K; c < g && (e = f.charCodeAt(c), e >= 48 && e <= 57); c++);
                                                        c == K && O(), K = c
                                                    }
                                                    return +f.slice(b, K)
                                                }
                                                if (d && O(), "true" == f.slice(K, K + 4)) return K += 4, !0;
                                                if ("false" == f.slice(K, K + 5)) return K += 5, !1;
                                                if ("null" == f.slice(K, K + 4)) return K += 4, null;
                                                O()
                                        }
                                        return "$"
                                    },
                                    Q = function(a) {
                                        var b, c;
                                        if ("$" == a && O(), "string" == typeof a) {
                                            if ("@" == (A ? a.charAt(0) : a[0])) return a.slice(1);
                                            if ("[" == a) {
                                                for (b = []; a = P(), "]" != a; c || (c = !0)) c && ("," == a ? (a = P(), "]" == a && O()) : O()), "," == a && O(), b.push(Q(a));
                                                return b
                                            }
                                            if ("{" == a) {
                                                for (b = {}; a = P(), "}" != a; c || (c = !0)) c && ("," == a ? (a = P(), "}" == a && O()) : O()), "," != a && "string" == typeof a && "@" == (A ? a.charAt(0) : a[0]) && ":" == P() || O(), b[a.slice(1)] = Q(P());
                                                return b
                                            }
                                            O()
                                        }
                                        return a
                                    },
                                    R = function(a, b, c) {
                                        var d = S(a, b, c);
                                        d === q ? delete a[b] : a[b] = d
                                    },
                                    S = function(a, b, c) {
                                        var d, e = a[b];
                                        if ("object" == typeof e && e)
                                            if (s.call(e) == y)
                                                for (d = e.length; d--;) R(e, d, c);
                                            else p(e, function(a) {
                                                R(e, a, c)
                                            });
                                        return c.call(a, b, e)
                                    };
                                b.parse = function(a, b) {
                                    var c, d;
                                    return K = 0, L = "" + a, c = Q(P()), "$" != P() && O(), K = L = null, b && s.call(b) == u ? S((d = {}, d[""] = c, d), "", b) : c
                                }
                            }
                        }
                        return b.runInContext = f, b
                    }
                    var g = c(9),
                        h = {
                            function: !0,
                            object: !0
                        },
                        i = h[typeof b] && b && !b.nodeType && b,
                        j = h[typeof window] && window || this,
                        k = i && h[typeof a] && a && !a.nodeType && "object" == typeof e && e;
                    if (!k || k.global !== k && k.window !== k && k.self !== k || (j = k), i && !g) f(j, i);
                    else {
                        var l = j.JSON,
                            m = j.JSON3,
                            n = !1,
                            o = f(j, j.JSON3 = {
                                noConflict: function() {
                                    return n || (n = !0, j.JSON = l, j.JSON3 = m, l = m = null), o
                                }
                            });
                        j.JSON = {
                            parse: o.parse,
                            stringify: o.stringify
                        }
                    }
                    g && (d = function() {
                        return o
                    }.call(b, c, b, a), !(void 0 !== d && (a.exports = d)))
                }).call(this)
            }).call(b, c(8)(a), function() {
                return this
            }())
        }, function(a, b) {
            a.exports = function(a) {
                return a.webpackPolyfill || (a.deprecate = function() {}, a.paths = [], a.children = [], a.webpackPolyfill = 1), a
            }
        }, function(a, b) {
            (function(b) {
                a.exports = b
            }).call(b, {})
        }, function(a, b) {
            a.exports = Array.isArray || function(a) {
                return "[object Array]" == Object.prototype.toString.call(a)
            }
        }, function(a, b) {
            function c(a) {
                if (a) return d(a)
            }

            function d(a) {
                for (var b in c.prototype) a[b] = c.prototype[b];
                return a
            }
            a.exports = c, c.prototype.on = c.prototype.addEventListener = function(a, b) {
                return this._callbacks = this._callbacks || {}, (this._callbacks[a] = this._callbacks[a] || []).push(b), this
            }, c.prototype.once = function(a, b) {
                function c() {
                    d.off(a, c), b.apply(this, arguments)
                }
                var d = this;
                return this._callbacks = this._callbacks || {}, c.fn = b, this.on(a, c), this
            }, c.prototype.off = c.prototype.removeListener = c.prototype.removeAllListeners = c.prototype.removeEventListener = function(a, b) {
                if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
                var c = this._callbacks[a];
                if (!c) return this;
                if (1 == arguments.length) return delete this._callbacks[a], this;
                for (var d, e = 0; e < c.length; e++)
                    if (d = c[e], d === b || d.fn === b) {
                        c.splice(e, 1);
                        break
                    }
                return this
            }, c.prototype.emit = function(a) {
                this._callbacks = this._callbacks || {};
                var b = [].slice.call(arguments, 1),
                    c = this._callbacks[a];
                if (c) {
                    c = c.slice(0);
                    for (var d = 0, e = c.length; d < e; ++d) c[d].apply(this, b)
                }
                return this
            }, c.prototype.listeners = function(a) {
                return this._callbacks = this._callbacks || {}, this._callbacks[a] || []
            }, c.prototype.hasListeners = function(a) {
                return !!this.listeners(a).length
            }
        }, function(a, b, c) {
            (function(a) {
                var d = c(10),
                    e = c(13);
                b.deconstructPacket = function(a) {
                    function b(a) {
                        if (!a) return a;
                        if (e(a)) {
                            var f = {
                                _placeholder: !0,
                                num: c.length
                            };
                            return c.push(a), f
                        }
                        if (d(a)) {
                            for (var g = new Array(a.length), h = 0; h < a.length; h++) g[h] = b(a[h]);
                            return g
                        }
                        if ("object" == typeof a && !(a instanceof Date)) {
                            var g = {};
                            for (var i in a) g[i] = b(a[i]);
                            return g
                        }
                        return a
                    }
                    var c = [],
                        f = a.data,
                        g = a;
                    return g.data = b(f), g.attachments = c.length, {
                        packet: g,
                        buffers: c
                    }
                }, b.reconstructPacket = function(a, b) {
                    function c(a) {
                        if (a && a._placeholder) {
                            var e = b[a.num];
                            return e
                        }
                        if (d(a)) {
                            for (var f = 0; f < a.length; f++) a[f] = c(a[f]);
                            return a
                        }
                        if (a && "object" == typeof a) {
                            for (var g in a) a[g] = c(a[g]);
                            return a
                        }
                        return a
                    }
                    return a.data = c(a.data), a.attachments = void 0, a
                }, b.removeBlobs = function(b, c) {
                    function f(b, i, j) {
                        if (!b) return b;
                        if (a.Blob && b instanceof Blob || a.File && b instanceof File) {
                            g++;
                            var k = new FileReader;
                            k.onload = function() {
                                j ? j[i] = this.result : h = this.result, --g || c(h)
                            }, k.readAsArrayBuffer(b)
                        } else if (d(b))
                            for (var l = 0; l < b.length; l++) f(b[l], l, b);
                        else if (b && "object" == typeof b && !e(b))
                            for (var m in b) f(b[m], m, b)
                    }
                    var g = 0,
                        h = b;
                    f(h), g || c(h)
                }
            }).call(b, function() {
                return this
            }())
        }, function(a, b) {
            (function(b) {
                function c(a) {
                    return b.Buffer && b.Buffer.isBuffer(a) || b.ArrayBuffer && a instanceof ArrayBuffer
                }
                a.exports = c
            }).call(b, function() {
                return this
            }())
        }, function(a, b, c) {
            "use strict";

            function d(a, b) {
                return this instanceof d ? (a && "object" === ("undefined" == typeof a ? "undefined" : e(a)) && (b = a, a = void 0), b = b || {}, b.path = b.path || "/socket.io", this.nsps = {}, this.subs = [], this.opts = b, this.reconnection(b.reconnection !== !1), this.reconnectionAttempts(b.reconnectionAttempts || 1 / 0), this.reconnectionDelay(b.reconnectionDelay || 1e3), this.reconnectionDelayMax(b.reconnectionDelayMax || 5e3), this.randomizationFactor(b.randomizationFactor || .5), this.backoff = new n({
                    min: this.reconnectionDelay(),
                    max: this.reconnectionDelayMax(),
                    jitter: this.randomizationFactor()
                }), this.timeout(null == b.timeout ? 2e4 : b.timeout), this.readyState = "closed", this.uri = a, this.connecting = [], this.lastPing = null, this.encoding = !1, this.packetBuffer = [], this.encoder = new i.Encoder, this.decoder = new i.Decoder, this.autoConnect = b.autoConnect !== !1, void(this.autoConnect && this.open())) : new d(a, b)
            }
            var e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(a) {
                    return typeof a
                } : function(a) {
                    return a && "function" == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a
                },
                f = c(15),
                g = c(42),
                h = c(43),
                i = c(6),
                j = c(45),
                k = c(46),
                l = c(3)("socket.io-client:manager"),
                m = c(40),
                n = c(49),
                o = Object.prototype.hasOwnProperty;
            a.exports = d, d.prototype.emitAll = function() {
                this.emit.apply(this, arguments);
                for (var a in this.nsps) o.call(this.nsps, a) && this.nsps[a].emit.apply(this.nsps[a], arguments)
            }, d.prototype.updateSocketIds = function() {
                for (var a in this.nsps) o.call(this.nsps, a) && (this.nsps[a].id = this.engine.id)
            }, h(d.prototype), d.prototype.reconnection = function(a) {
                return arguments.length ? (this._reconnection = !!a, this) : this._reconnection
            }, d.prototype.reconnectionAttempts = function(a) {
                return arguments.length ? (this._reconnectionAttempts = a, this) : this._reconnectionAttempts
            }, d.prototype.reconnectionDelay = function(a) {
                return arguments.length ? (this._reconnectionDelay = a, this.backoff && this.backoff.setMin(a), this) : this._reconnectionDelay
            }, d.prototype.randomizationFactor = function(a) {
                return arguments.length ? (this._randomizationFactor = a, this.backoff && this.backoff.setJitter(a), this) : this._randomizationFactor
            }, d.prototype.reconnectionDelayMax = function(a) {
                return arguments.length ? (this._reconnectionDelayMax = a, this.backoff && this.backoff.setMax(a), this) : this._reconnectionDelayMax
            }, d.prototype.timeout = function(a) {
                return arguments.length ? (this._timeout = a, this) : this._timeout
            }, d.prototype.maybeReconnectOnOpen = function() {
                !this.reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect()
            }, d.prototype.open = d.prototype.connect = function(a, b) {
                if (l("readyState %s", this.readyState), ~this.readyState.indexOf("open")) return this;
                l("opening %s", this.uri), this.engine = f(this.uri, this.opts);
                var c = this.engine,
                    d = this;
                this.readyState = "opening", this.skipReconnect = !1;
                var e = j(c, "open", function() {
                        d.onopen(), a && a()
                    }),
                    g = j(c, "error", function(b) {
                        if (l("connect_error"), d.cleanup(), d.readyState = "closed", d.emitAll("connect_error", b), a) {
                            var c = new Error("Connection error");
                            c.data = b, a(c)
                        } else d.maybeReconnectOnOpen()
                    });
                if (!1 !== this._timeout) {
                    var h = this._timeout;
                    l("connect attempt will timeout after %d", h);
                    var i = setTimeout(function() {
                        l("connect attempt timed out after %d", h), e.destroy(), c.close(), c.emit("error", "timeout"), d.emitAll("connect_timeout", h)
                    }, h);
                    this.subs.push({
                        destroy: function() {
                            clearTimeout(i)
                        }
                    })
                }
                return this.subs.push(e), this.subs.push(g), this
            }, d.prototype.onopen = function() {
                l("open"), this.cleanup(), this.readyState = "open", this.emit("open");
                var a = this.engine;
                this.subs.push(j(a, "data", k(this, "ondata"))), this.subs.push(j(a, "ping", k(this, "onping"))), this.subs.push(j(a, "pong", k(this, "onpong"))), this.subs.push(j(a, "error", k(this, "onerror"))), this.subs.push(j(a, "close", k(this, "onclose"))), this.subs.push(j(this.decoder, "decoded", k(this, "ondecoded")))
            }, d.prototype.onping = function() {
                this.lastPing = new Date, this.emitAll("ping")
            }, d.prototype.onpong = function() {
                this.emitAll("pong", new Date - this.lastPing)
            }, d.prototype.ondata = function(a) {
                this.decoder.add(a)
            }, d.prototype.ondecoded = function(a) {
                this.emit("packet", a)
            }, d.prototype.onerror = function(a) {
                l("error", a), this.emitAll("error", a)
            }, d.prototype.socket = function(a, b) {
                function c() {
                    ~m(e.connecting, d) || e.connecting.push(d)
                }
                var d = this.nsps[a];
                if (!d) {
                    d = new g(this, a, b), this.nsps[a] = d;
                    var e = this;
                    d.on("connecting", c), d.on("connect", function() {
                        d.id = e.engine.id
                    }), this.autoConnect && c()
                }
                return d
            }, d.prototype.destroy = function(a) {
                var b = m(this.connecting, a);
                ~b && this.connecting.splice(b, 1), this.connecting.length || this.close()
            }, d.prototype.packet = function(a) {
                l("writing packet %j", a);
                var b = this;
                a.query && 0 === a.type && (a.nsp += "?" + a.query), b.encoding ? b.packetBuffer.push(a) : (b.encoding = !0, this.encoder.encode(a, function(c) {
                    for (var d = 0; d < c.length; d++) b.engine.write(c[d], a.options);
                    b.encoding = !1, b.processPacketQueue()
                }))
            }, d.prototype.processPacketQueue = function() {
                if (this.packetBuffer.length > 0 && !this.encoding) {
                    var a = this.packetBuffer.shift();
                    this.packet(a)
                }
            }, d.prototype.cleanup = function() {
                l("cleanup");
                for (var a = this.subs.length, b = 0; b < a; b++) {
                    var c = this.subs.shift();
                    c.destroy()
                }
                this.packetBuffer = [], this.encoding = !1, this.lastPing = null, this.decoder.destroy()
            }, d.prototype.close = d.prototype.disconnect = function() {
                l("disconnect"), this.skipReconnect = !0, this.reconnecting = !1, "opening" === this.readyState && this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.engine && this.engine.close()
            }, d.prototype.onclose = function(a) {
                l("onclose"), this.cleanup(), this.backoff.reset(), this.readyState = "closed", this.emit("close", a), this._reconnection && !this.skipReconnect && this.reconnect()
            }, d.prototype.reconnect = function() {
                if (this.reconnecting || this.skipReconnect) return this;
                var a = this;
                if (this.backoff.attempts >= this._reconnectionAttempts) l("reconnect failed"), this.backoff.reset(), this.emitAll("reconnect_failed"), this.reconnecting = !1;
                else {
                    var b = this.backoff.duration();
                    l("will wait %dms before reconnect attempt", b), this.reconnecting = !0;
                    var c = setTimeout(function() {
                        a.skipReconnect || (l("attempting reconnect"), a.emitAll("reconnect_attempt", a.backoff.attempts), a.emitAll("reconnecting", a.backoff.attempts), a.skipReconnect || a.open(function(b) {
                            b ? (l("reconnect attempt error"), a.reconnecting = !1, a.reconnect(), a.emitAll("reconnect_error", b.data)) : (l("reconnect success"), a.onreconnect())
                        }))
                    }, b);
                    this.subs.push({
                        destroy: function() {
                            clearTimeout(c)
                        }
                    })
                }
            }, d.prototype.onreconnect = function() {
                var a = this.backoff.attempts;
                this.reconnecting = !1, this.backoff.reset(), this.updateSocketIds(), this.emitAll("reconnect", a)
            }
        }, function(a, b, c) {
            a.exports = c(16)
        }, function(a, b, c) {
            a.exports = c(17), a.exports.parser = c(24)
        }, function(a, b, c) {
            (function(b) {
                function d(a, c) {
                    if (!(this instanceof d)) return new d(a, c);
                    c = c || {}, a && "object" == typeof a && (c = a, a = null), a ? (a = k(a), c.hostname = a.host, c.secure = "https" == a.protocol || "wss" == a.protocol, c.port = a.port, a.query && (c.query = a.query)) : c.host && (c.hostname = k(c.host).host), this.secure = null != c.secure ? c.secure : b.location && "https:" == location.protocol, c.hostname && !c.port && (c.port = this.secure ? "443" : "80"), this.agent = c.agent || !1, this.hostname = c.hostname || (b.location ? location.hostname : "localhost"), this.port = c.port || (b.location && location.port ? location.port : this.secure ? 443 : 80), this.query = c.query || {}, "string" == typeof this.query && (this.query = m.decode(this.query)), this.upgrade = !1 !== c.upgrade, this.path = (c.path || "/engine.io").replace(/\/$/, "") + "/", this.forceJSONP = !!c.forceJSONP, this.jsonp = !1 !== c.jsonp, this.forceBase64 = !!c.forceBase64, this.enablesXDR = !!c.enablesXDR, this.timestampParam = c.timestampParam || "t", this.timestampRequests = c.timestampRequests, this.transports = c.transports || ["polling", "websocket"], this.readyState = "", this.writeBuffer = [], this.policyPort = c.policyPort || 843, this.rememberUpgrade = c.rememberUpgrade || !1, this.binaryType = null, this.onlyBinaryUpgrades = c.onlyBinaryUpgrades, this.perMessageDeflate = !1 !== c.perMessageDeflate && (c.perMessageDeflate || {}), !0 === this.perMessageDeflate && (this.perMessageDeflate = {}), this.perMessageDeflate && null == this.perMessageDeflate.threshold && (this.perMessageDeflate.threshold = 1024), this.pfx = c.pfx || null, this.key = c.key || null, this.passphrase = c.passphrase || null, this.cert = c.cert || null, this.ca = c.ca || null, this.ciphers = c.ciphers || null, this.rejectUnauthorized = void 0 === c.rejectUnauthorized || c.rejectUnauthorized;
                    var e = "object" == typeof b && b;
                    e.global === e && c.extraHeaders && Object.keys(c.extraHeaders).length > 0 && (this.extraHeaders = c.extraHeaders), this.open()
                }

                function e(a) {
                    var b = {};
                    for (var c in a) a.hasOwnProperty(c) && (b[c] = a[c]);
                    return b
                }
                var f = c(18),
                    g = c(33),
                    h = c(3)("engine.io-client:socket"),
                    i = c(40),
                    j = c(24),
                    k = c(2),
                    l = c(41),
                    m = c(34);
                a.exports = d, d.priorWebsocketSuccess = !1, g(d.prototype), d.protocol = j.protocol, d.Socket = d, d.Transport = c(23), d.transports = c(18), d.parser = c(24), d.prototype.createTransport = function(a) {
                    h('creating transport "%s"', a);
                    var b = e(this.query);
                    b.EIO = j.protocol, b.transport = a, this.id && (b.sid = this.id);
                    var c = new f[a]({
                        agent: this.agent,
                        hostname: this.hostname,
                        port: this.port,
                        secure: this.secure,
                        path: this.path,
                        query: b,
                        forceJSONP: this.forceJSONP,
                        jsonp: this.jsonp,
                        forceBase64: this.forceBase64,
                        enablesXDR: this.enablesXDR,
                        timestampRequests: this.timestampRequests,
                        timestampParam: this.timestampParam,
                        policyPort: this.policyPort,
                        socket: this,
                        pfx: this.pfx,
                        key: this.key,
                        passphrase: this.passphrase,
                        cert: this.cert,
                        ca: this.ca,
                        ciphers: this.ciphers,
                        rejectUnauthorized: this.rejectUnauthorized,
                        perMessageDeflate: this.perMessageDeflate,
                        extraHeaders: this.extraHeaders
                    });
                    return c
                }, d.prototype.open = function() {
                    var a;
                    if (this.rememberUpgrade && d.priorWebsocketSuccess && this.transports.indexOf("websocket") != -1) a = "websocket";
                    else {
                        if (0 === this.transports.length) {
                            var b = this;
                            return void setTimeout(function() {
                                b.emit("error", "No transports available")
                            }, 0)
                        }
                        a = this.transports[0]
                    }
                    this.readyState = "opening";
                    try {
                        a = this.createTransport(a)
                    } catch (a) {
                        return this.transports.shift(), void this.open()
                    }
                    a.open(), this.setTransport(a)
                }, d.prototype.setTransport = function(a) {
                    h("setting transport %s", a.name);
                    var b = this;
                    this.transport && (h("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners()), this.transport = a, a.on("drain", function() {
                        b.onDrain()
                    }).on("packet", function(a) {
                        b.onPacket(a)
                    }).on("error", function(a) {
                        b.onError(a)
                    }).on("close", function() {
                        b.onClose("transport close")
                    })
                }, d.prototype.probe = function(a) {
                    function b() {
                        if (m.onlyBinaryUpgrades) {
                            var b = !this.supportsBinary && m.transport.supportsBinary;
                            l = l || b
                        }
                        l || (h('probe transport "%s" opened', a), k.send([{
                            type: "ping",
                            data: "probe"
                        }]), k.once("packet", function(b) {
                            if (!l)
                                if ("pong" == b.type && "probe" == b.data) {
                                    if (h('probe transport "%s" pong', a), m.upgrading = !0, m.emit("upgrading", k), !k) return;
                                    d.priorWebsocketSuccess = "websocket" == k.name, h('pausing current transport "%s"', m.transport.name), m.transport.pause(function() {
                                        l || "closed" != m.readyState && (h("changing transport and sending upgrade packet"), j(), m.setTransport(k), k.send([{
                                            type: "upgrade"
                                        }]), m.emit("upgrade", k), k = null, m.upgrading = !1, m.flush())
                                    })
                                } else {
                                    h('probe transport "%s" failed', a);
                                    var c = new Error("probe error");
                                    c.transport = k.name, m.emit("upgradeError", c)
                                }
                        }))
                    }

                    function c() {
                        l || (l = !0, j(), k.close(), k = null)
                    }

                    function e(b) {
                        var d = new Error("probe error: " + b);
                        d.transport = k.name, c(), h('probe transport "%s" failed because of error: %s', a, b), m.emit("upgradeError", d)
                    }

                    function f() {
                        e("transport closed")
                    }

                    function g() {
                        e("socket closed")
                    }

                    function i(a) {
                        k && a.name != k.name && (h('"%s" works - aborting "%s"', a.name, k.name), c())
                    }

                    function j() {
                        k.removeListener("open", b), k.removeListener("error", e), k.removeListener("close", f), m.removeListener("close", g), m.removeListener("upgrading", i)
                    }
                    h('probing transport "%s"', a);
                    var k = this.createTransport(a, {
                            probe: 1
                        }),
                        l = !1,
                        m = this;
                    d.priorWebsocketSuccess = !1, k.once("open", b), k.once("error", e), k.once("close", f), this.once("close", g), this.once("upgrading", i), k.open()
                }, d.prototype.onOpen = function() {
                    if (h("socket open"), this.readyState = "open", d.priorWebsocketSuccess = "websocket" == this.transport.name, this.emit("open"), this.flush(), "open" == this.readyState && this.upgrade && this.transport.pause) {
                        h("starting upgrade probes");
                        for (var a = 0, b = this.upgrades.length; a < b; a++) this.probe(this.upgrades[a])
                    }
                }, d.prototype.onPacket = function(a) {
                    if ("opening" == this.readyState || "open" == this.readyState) switch (h('socket receive: type "%s", data "%s"', a.type, a.data), this.emit("packet", a), this.emit("heartbeat"), a.type) {
                        case "open":
                            this.onHandshake(l(a.data));
                            break;
                        case "pong":
                            this.setPing(), this.emit("pong");
                            break;
                        case "error":
                            var b = new Error("server error");
                            b.code = a.data, this.onError(b);
                            break;
                        case "message":
                            this.emit("data", a.data), this.emit("message", a.data)
                    } else h('packet received with socket readyState "%s"', this.readyState)
                }, d.prototype.onHandshake = function(a) {
                    this.emit("handshake", a), this.id = a.sid, this.transport.query.sid = a.sid, this.upgrades = this.filterUpgrades(a.upgrades), this.pingInterval = a.pingInterval,
                        this.pingTimeout = a.pingTimeout, this.onOpen(), "closed" != this.readyState && (this.setPing(), this.removeListener("heartbeat", this.onHeartbeat), this.on("heartbeat", this.onHeartbeat))
                }, d.prototype.onHeartbeat = function(a) {
                    clearTimeout(this.pingTimeoutTimer);
                    var b = this;
                    b.pingTimeoutTimer = setTimeout(function() {
                        "closed" != b.readyState && b.onClose("ping timeout")
                    }, a || b.pingInterval + b.pingTimeout)
                }, d.prototype.setPing = function() {
                    var a = this;
                    clearTimeout(a.pingIntervalTimer), a.pingIntervalTimer = setTimeout(function() {
                        h("writing ping packet - expecting pong within %sms", a.pingTimeout), a.ping(), a.onHeartbeat(a.pingTimeout)
                    }, a.pingInterval)
                }, d.prototype.ping = function() {
                    var a = this;
                    this.sendPacket("ping", function() {
                        a.emit("ping")
                    })
                }, d.prototype.onDrain = function() {
                    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emit("drain") : this.flush()
                }, d.prototype.flush = function() {
                    "closed" != this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length && (h("flushing %d packets in socket", this.writeBuffer.length), this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, this.emit("flush"))
                }, d.prototype.write = d.prototype.send = function(a, b, c) {
                    return this.sendPacket("message", a, b, c), this
                }, d.prototype.sendPacket = function(a, b, c, d) {
                    if ("function" == typeof b && (d = b, b = void 0), "function" == typeof c && (d = c, c = null), "closing" != this.readyState && "closed" != this.readyState) {
                        c = c || {}, c.compress = !1 !== c.compress;
                        var e = {
                            type: a,
                            data: b,
                            options: c
                        };
                        this.emit("packetCreate", e), this.writeBuffer.push(e), d && this.once("flush", d), this.flush()
                    }
                }, d.prototype.close = function() {
                    function a() {
                        d.onClose("forced close"), h("socket closing - telling transport to close"), d.transport.close()
                    }

                    function b() {
                        d.removeListener("upgrade", b), d.removeListener("upgradeError", b), a()
                    }

                    function c() {
                        d.once("upgrade", b), d.once("upgradeError", b)
                    }
                    if ("opening" == this.readyState || "open" == this.readyState) {
                        this.readyState = "closing";
                        var d = this;
                        this.writeBuffer.length ? this.once("drain", function() {
                            this.upgrading ? c() : a()
                        }) : this.upgrading ? c() : a()
                    }
                    return this
                }, d.prototype.onError = function(a) {
                    h("socket error %j", a), d.priorWebsocketSuccess = !1, this.emit("error", a), this.onClose("transport error", a)
                }, d.prototype.onClose = function(a, b) {
                    if ("opening" == this.readyState || "open" == this.readyState || "closing" == this.readyState) {
                        h('socket close with reason: "%s"', a);
                        var c = this;
                        clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), this.readyState = "closed", this.id = null, this.emit("close", a, b), c.writeBuffer = [], c.prevBufferLen = 0
                    }
                }, d.prototype.filterUpgrades = function(a) {
                    for (var b = [], c = 0, d = a.length; c < d; c++) ~i(this.transports, a[c]) && b.push(a[c]);
                    return b
                }
            }).call(b, function() {
                return this
            }())
        }, function(a, b, c) {
            (function(a) {
                function d(b) {
                    var c, d = !1,
                        h = !1,
                        i = !1 !== b.jsonp;
                    if (a.location) {
                        var j = "https:" == location.protocol,
                            k = location.port;
                        k || (k = j ? 443 : 80), d = b.hostname != location.hostname || k != b.port, h = b.secure != j
                    }
                    if (b.xdomain = d, b.xscheme = h, c = new e(b), "open" in c && !b.forceJSONP) return new f(b);
                    if (!i) throw new Error("JSONP disabled");
                    return new g(b)
                }
                var e = c(19),
                    f = c(21),
                    g = c(37),
                    h = c(38);
                b.polling = d, b.websocket = h
            }).call(b, function() {
                return this
            }())
        }, function(a, b, c) {
            var d = c(20);
            a.exports = function(a) {
                var b = a.xdomain,
                    c = a.xscheme,
                    e = a.enablesXDR;
                try {
                    if ("undefined" != typeof XMLHttpRequest && (!b || d)) return new XMLHttpRequest
                } catch (a) {}
                try {
                    if ("undefined" != typeof XDomainRequest && !c && e) return new XDomainRequest
                } catch (a) {}
                if (!b) try {
                    return new ActiveXObject("Microsoft.XMLHTTP")
                } catch (a) {}
            }
        }, function(a, b) {
            try {
                a.exports = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest
            } catch (b) {
                a.exports = !1
            }
        }, function(a, b, c) {
            (function(b) {
                function d() {}

                function e(a) {
                    if (i.call(this, a), b.location) {
                        var c = "https:" == location.protocol,
                            d = location.port;
                        d || (d = c ? 443 : 80), this.xd = a.hostname != b.location.hostname || d != a.port, this.xs = a.secure != c
                    } else this.extraHeaders = a.extraHeaders
                }

                function f(a) {
                    this.method = a.method || "GET", this.uri = a.uri, this.xd = !!a.xd, this.xs = !!a.xs, this.async = !1 !== a.async, this.data = void 0 != a.data ? a.data : null, this.agent = a.agent, this.isBinary = a.isBinary, this.supportsBinary = a.supportsBinary, this.enablesXDR = a.enablesXDR, this.pfx = a.pfx, this.key = a.key, this.passphrase = a.passphrase, this.cert = a.cert, this.ca = a.ca, this.ciphers = a.ciphers, this.rejectUnauthorized = a.rejectUnauthorized, this.extraHeaders = a.extraHeaders, this.create()
                }

                function g() {
                    for (var a in f.requests) f.requests.hasOwnProperty(a) && f.requests[a].abort()
                }
                var h = c(19),
                    i = c(22),
                    j = c(33),
                    k = c(35),
                    l = c(3)("engine.io-client:polling-xhr");
                a.exports = e, a.exports.Request = f, k(e, i), e.prototype.supportsBinary = !0, e.prototype.request = function(a) {
                    return a = a || {}, a.uri = this.uri(), a.xd = this.xd, a.xs = this.xs, a.agent = this.agent || !1, a.supportsBinary = this.supportsBinary, a.enablesXDR = this.enablesXDR, a.pfx = this.pfx, a.key = this.key, a.passphrase = this.passphrase, a.cert = this.cert, a.ca = this.ca, a.ciphers = this.ciphers, a.rejectUnauthorized = this.rejectUnauthorized, a.extraHeaders = this.extraHeaders, new f(a)
                }, e.prototype.doWrite = function(a, b) {
                    var c = "string" != typeof a && void 0 !== a,
                        d = this.request({
                            method: "POST",
                            data: a,
                            isBinary: c
                        }),
                        e = this;
                    d.on("success", b), d.on("error", function(a) {
                        e.onError("xhr post error", a)
                    }), this.sendXhr = d
                }, e.prototype.doPoll = function() {
                    l("xhr poll");
                    var a = this.request(),
                        b = this;
                    a.on("data", function(a) {
                        b.onData(a)
                    }), a.on("error", function(a) {
                        b.onError("xhr poll error", a)
                    }), this.pollXhr = a
                }, j(f.prototype), f.prototype.create = function() {
                    var a = {
                        agent: this.agent,
                        xdomain: this.xd,
                        xscheme: this.xs,
                        enablesXDR: this.enablesXDR
                    };
                    a.pfx = this.pfx, a.key = this.key, a.passphrase = this.passphrase, a.cert = this.cert, a.ca = this.ca, a.ciphers = this.ciphers, a.rejectUnauthorized = this.rejectUnauthorized;
                    var c = this.xhr = new h(a),
                        d = this;
                    try {
                        l("xhr open %s: %s", this.method, this.uri), c.open(this.method, this.uri, this.async);
                        try {
                            if (this.extraHeaders) {
                                c.setDisableHeaderCheck(!0);
                                for (var e in this.extraHeaders) this.extraHeaders.hasOwnProperty(e) && c.setRequestHeader(e, this.extraHeaders[e])
                            }
                        } catch (a) {}
                        if (this.supportsBinary && (c.responseType = "arraybuffer"), "POST" == this.method) try {
                            this.isBinary ? c.setRequestHeader("Content-type", "application/octet-stream") : c.setRequestHeader("Content-type", "text/plain;charset=UTF-8")
                        } catch (a) {}
                        "withCredentials" in c && (c.withCredentials = !0), this.hasXDR() ? (c.onload = function() {
                            d.onLoad()
                        }, c.onerror = function() {
                            d.onError(c.responseText)
                        }) : c.onreadystatechange = function() {
                            4 == c.readyState && (200 == c.status || 1223 == c.status ? d.onLoad() : setTimeout(function() {
                                d.onError(c.status)
                            }, 0))
                        }, l("xhr data %s", this.data), c.send(this.data)
                    } catch (a) {
                        return void setTimeout(function() {
                            d.onError(a)
                        }, 0)
                    }
                    b.document && (this.index = f.requestsCount++, f.requests[this.index] = this)
                }, f.prototype.onSuccess = function() {
                    this.emit("success"), this.cleanup()
                }, f.prototype.onData = function(a) {
                    this.emit("data", a), this.onSuccess()
                }, f.prototype.onError = function(a) {
                    this.emit("error", a), this.cleanup(!0)
                }, f.prototype.cleanup = function(a) {
                    if ("undefined" != typeof this.xhr && null !== this.xhr) {
                        if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = d : this.xhr.onreadystatechange = d, a) try {
                            this.xhr.abort()
                        } catch (a) {}
                        b.document && delete f.requests[this.index], this.xhr = null
                    }
                }, f.prototype.onLoad = function() {
                    var a;
                    try {
                        var b;
                        try {
                            b = this.xhr.getResponseHeader("Content-Type").split(";")[0]
                        } catch (a) {}
                        if ("application/octet-stream" === b) a = this.xhr.response;
                        else if (this.supportsBinary) try {
                            a = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response))
                        } catch (b) {
                            for (var c = new Uint8Array(this.xhr.response), d = [], e = 0, f = c.length; e < f; e++) d.push(c[e]);
                            a = String.fromCharCode.apply(null, d)
                        } else a = this.xhr.responseText
                    } catch (a) {
                        this.onError(a)
                    }
                    null != a && this.onData(a)
                }, f.prototype.hasXDR = function() {
                    return "undefined" != typeof b.XDomainRequest && !this.xs && this.enablesXDR
                }, f.prototype.abort = function() {
                    this.cleanup()
                }, b.document && (f.requestsCount = 0, f.requests = {}, b.attachEvent ? b.attachEvent("onunload", g) : b.addEventListener && b.addEventListener("beforeunload", g, !1))
            }).call(b, function() {
                return this
            }())
        }, function(a, b, c) {
            function d(a) {
                var b = a && a.forceBase64;
                k && !b || (this.supportsBinary = !1), e.call(this, a)
            }
            var e = c(23),
                f = c(34),
                g = c(24),
                h = c(35),
                i = c(36),
                j = c(3)("engine.io-client:polling");
            a.exports = d;
            var k = function() {
                var a = c(19),
                    b = new a({
                        xdomain: !1
                    });
                return null != b.responseType
            }();
            h(d, e), d.prototype.name = "polling", d.prototype.doOpen = function() {
                this.poll()
            }, d.prototype.pause = function(a) {
                function b() {
                    j("paused"), c.readyState = "paused", a()
                }
                var c = this;
                if (this.readyState = "pausing", this.polling || !this.writable) {
                    var d = 0;
                    this.polling && (j("we are currently polling - waiting to pause"), d++, this.once("pollComplete", function() {
                        j("pre-pause polling complete"), --d || b()
                    })), this.writable || (j("we are currently writing - waiting to pause"), d++, this.once("drain", function() {
                        j("pre-pause writing complete"), --d || b()
                    }))
                } else b()
            }, d.prototype.poll = function() {
                j("polling"), this.polling = !0, this.doPoll(), this.emit("poll")
            }, d.prototype.onData = function(a) {
                var b = this;
                j("polling got data %s", a);
                var c = function(a, c, d) {
                    return "opening" == b.readyState && b.onOpen(), "close" == a.type ? (b.onClose(), !1) : void b.onPacket(a)
                };
                g.decodePayload(a, this.socket.binaryType, c), "closed" != this.readyState && (this.polling = !1, this.emit("pollComplete"), "open" == this.readyState ? this.poll() : j('ignoring poll - transport state "%s"', this.readyState))
            }, d.prototype.doClose = function() {
                function a() {
                    j("writing close packet"), b.write([{
                        type: "close"
                    }])
                }
                var b = this;
                "open" == this.readyState ? (j("transport open - closing"), a()) : (j("transport not open - deferring close"), this.once("open", a))
            }, d.prototype.write = function(a) {
                var b = this;
                this.writable = !1;
                var c = function() {
                        b.writable = !0, b.emit("drain")
                    },
                    b = this;
                g.encodePayload(a, this.supportsBinary, function(a) {
                    b.doWrite(a, c)
                })
            }, d.prototype.uri = function() {
                var a = this.query || {},
                    b = this.secure ? "https" : "http",
                    c = "";
                !1 !== this.timestampRequests && (a[this.timestampParam] = i()), this.supportsBinary || a.sid || (a.b64 = 1), a = f.encode(a), this.port && ("https" == b && 443 != this.port || "http" == b && 80 != this.port) && (c = ":" + this.port), a.length && (a = "?" + a);
                var d = this.hostname.indexOf(":") !== -1;
                return b + "://" + (d ? "[" + this.hostname + "]" : this.hostname) + c + this.path + a
            }
        }, function(a, b, c) {
            function d(a) {
                this.path = a.path, this.hostname = a.hostname, this.port = a.port, this.secure = a.secure, this.query = a.query, this.timestampParam = a.timestampParam, this.timestampRequests = a.timestampRequests, this.readyState = "", this.agent = a.agent || !1, this.socket = a.socket, this.enablesXDR = a.enablesXDR, this.pfx = a.pfx, this.key = a.key, this.passphrase = a.passphrase, this.cert = a.cert, this.ca = a.ca, this.ciphers = a.ciphers, this.rejectUnauthorized = a.rejectUnauthorized, this.extraHeaders = a.extraHeaders
            }
            var e = c(24),
                f = c(33);
            a.exports = d, f(d.prototype), d.prototype.onError = function(a, b) {
                var c = new Error(a);
                return c.type = "TransportError", c.description = b, this.emit("error", c), this
            }, d.prototype.open = function() {
                return "closed" != this.readyState && "" != this.readyState || (this.readyState = "opening", this.doOpen()), this
            }, d.prototype.close = function() {
                return "opening" != this.readyState && "open" != this.readyState || (this.doClose(), this.onClose()), this
            }, d.prototype.send = function(a) {
                if ("open" != this.readyState) throw new Error("Transport not open");
                this.write(a)
            }, d.prototype.onOpen = function() {
                this.readyState = "open", this.writable = !0, this.emit("open")
            }, d.prototype.onData = function(a) {
                var b = e.decodePacket(a, this.socket.binaryType);
                this.onPacket(b)
            }, d.prototype.onPacket = function(a) {
                this.emit("packet", a)
            }, d.prototype.onClose = function() {
                this.readyState = "closed", this.emit("close")
            }
        }, function(a, b, c) {
            (function(a) {
                function d(a, c) {
                    var d = "b" + b.packets[a.type] + a.data.data;
                    return c(d)
                }

                function e(a, c, d) {
                    if (!c) return b.encodeBase64Packet(a, d);
                    var e = a.data,
                        f = new Uint8Array(e),
                        g = new Uint8Array(1 + e.byteLength);
                    g[0] = r[a.type];
                    for (var h = 0; h < f.length; h++) g[h + 1] = f[h];
                    return d(g.buffer)
                }

                function f(a, c, d) {
                    if (!c) return b.encodeBase64Packet(a, d);
                    var e = new FileReader;
                    return e.onload = function() {
                        a.data = e.result, b.encodePacket(a, c, !0, d)
                    }, e.readAsArrayBuffer(a.data)
                }

                function g(a, c, d) {
                    if (!c) return b.encodeBase64Packet(a, d);
                    if (q) return f(a, c, d);
                    var e = new Uint8Array(1);
                    e[0] = r[a.type];
                    var g = new u([e.buffer, a.data]);
                    return d(g)
                }

                function h(a, b, c) {
                    for (var d = new Array(a.length), e = m(a.length, c), f = function(a, c, e) {
                            b(c, function(b, c) {
                                d[a] = c, e(b, d)
                            })
                        }, g = 0; g < a.length; g++) f(g, a[g], e)
                }
                var i = c(25),
                    j = c(26),
                    k = c(28),
                    l = c(29),
                    m = c(30),
                    n = c(31),
                    o = navigator.userAgent.match(/Android/i),
                    p = /PhantomJS/i.test(navigator.userAgent),
                    q = o || p;
                b.protocol = 3;
                var r = b.packets = {
                        open: 0,
                        close: 1,
                        ping: 2,
                        pong: 3,
                        message: 4,
                        upgrade: 5,
                        noop: 6
                    },
                    s = i(r),
                    t = {
                        type: "error",
                        data: "parser error"
                    },
                    u = c(32);
                b.encodePacket = function(b, c, f, h) {
                    "function" == typeof c && (h = c, c = !1), "function" == typeof f && (h = f, f = null);
                    var i = void 0 === b.data ? void 0 : b.data.buffer || b.data;
                    if (a.ArrayBuffer && i instanceof ArrayBuffer) return e(b, c, h);
                    if (u && i instanceof a.Blob) return g(b, c, h);
                    if (i && i.base64) return d(b, h);
                    var j = r[b.type];
                    return void 0 !== b.data && (j += f ? n.encode(String(b.data)) : String(b.data)), h("" + j)
                }, b.encodeBase64Packet = function(c, d) {
                    var e = "b" + b.packets[c.type];
                    if (u && c.data instanceof a.Blob) {
                        var f = new FileReader;
                        return f.onload = function() {
                            var a = f.result.split(",")[1];
                            d(e + a)
                        }, f.readAsDataURL(c.data)
                    }
                    var g;
                    try {
                        g = String.fromCharCode.apply(null, new Uint8Array(c.data))
                    } catch (a) {
                        for (var h = new Uint8Array(c.data), i = new Array(h.length), j = 0; j < h.length; j++) i[j] = h[j];
                        g = String.fromCharCode.apply(null, i)
                    }
                    return e += a.btoa(g), d(e)
                }, b.decodePacket = function(a, c, d) {
                    if ("string" == typeof a || void 0 === a) {
                        if ("b" == a.charAt(0)) return b.decodeBase64Packet(a.substr(1), c);
                        if (d) try {
                            a = n.decode(a)
                        } catch (a) {
                            return t
                        }
                        var e = a.charAt(0);
                        return Number(e) == e && s[e] ? a.length > 1 ? {
                            type: s[e],
                            data: a.substring(1)
                        } : {
                            type: s[e]
                        } : t
                    }
                    var f = new Uint8Array(a),
                        e = f[0],
                        g = k(a, 1);
                    return u && "blob" === c && (g = new u([g])), {
                        type: s[e],
                        data: g
                    }
                }, b.decodeBase64Packet = function(b, c) {
                    var d = s[b.charAt(0)];
                    if (!a.ArrayBuffer) return {
                        type: d,
                        data: {
                            base64: !0,
                            data: b.substr(1)
                        }
                    };
                    var e = l.decode(b.substr(1));
                    return "blob" === c && u && (e = new u([e])), {
                        type: d,
                        data: e
                    }
                }, b.encodePayload = function(a, c, d) {
                    function e(a) {
                        return a.length + ":" + a
                    }

                    function f(a, d) {
                        b.encodePacket(a, !!g && c, !0, function(a) {
                            d(null, e(a))
                        })
                    }
                    "function" == typeof c && (d = c, c = null);
                    var g = j(a);
                    return c && g ? u && !q ? b.encodePayloadAsBlob(a, d) : b.encodePayloadAsArrayBuffer(a, d) : a.length ? void h(a, f, function(a, b) {
                        return d(b.join(""))
                    }) : d("0:")
                }, b.decodePayload = function(a, c, d) {
                    if ("string" != typeof a) return b.decodePayloadAsBinary(a, c, d);
                    "function" == typeof c && (d = c, c = null);
                    var e;
                    if ("" == a) return d(t, 0, 1);
                    for (var f, g, h = "", i = 0, j = a.length; i < j; i++) {
                        var k = a.charAt(i);
                        if (":" != k) h += k;
                        else {
                            if ("" == h || h != (f = Number(h))) return d(t, 0, 1);
                            if (g = a.substr(i + 1, f), h != g.length) return d(t, 0, 1);
                            if (g.length) {
                                if (e = b.decodePacket(g, c, !0), t.type == e.type && t.data == e.data) return d(t, 0, 1);
                                var l = d(e, i + f, j);
                                if (!1 === l) return
                            }
                            i += f, h = ""
                        }
                    }
                    return "" != h ? d(t, 0, 1) : void 0
                }, b.encodePayloadAsArrayBuffer = function(a, c) {
                    function d(a, c) {
                        b.encodePacket(a, !0, !0, function(a) {
                            return c(null, a)
                        })
                    }
                    return a.length ? void h(a, d, function(a, b) {
                        var d = b.reduce(function(a, b) {
                                var c;
                                return c = "string" == typeof b ? b.length : b.byteLength, a + c.toString().length + c + 2
                            }, 0),
                            e = new Uint8Array(d),
                            f = 0;
                        return b.forEach(function(a) {
                            var b = "string" == typeof a,
                                c = a;
                            if (b) {
                                for (var d = new Uint8Array(a.length), g = 0; g < a.length; g++) d[g] = a.charCodeAt(g);
                                c = d.buffer
                            }
                            b ? e[f++] = 0 : e[f++] = 1;
                            for (var h = c.byteLength.toString(), g = 0; g < h.length; g++) e[f++] = parseInt(h[g]);
                            e[f++] = 255;
                            for (var d = new Uint8Array(c), g = 0; g < d.length; g++) e[f++] = d[g]
                        }), c(e.buffer)
                    }) : c(new ArrayBuffer(0))
                }, b.encodePayloadAsBlob = function(a, c) {
                    function d(a, c) {
                        b.encodePacket(a, !0, !0, function(a) {
                            var b = new Uint8Array(1);
                            if (b[0] = 1, "string" == typeof a) {
                                for (var d = new Uint8Array(a.length), e = 0; e < a.length; e++) d[e] = a.charCodeAt(e);
                                a = d.buffer, b[0] = 0
                            }
                            for (var f = a instanceof ArrayBuffer ? a.byteLength : a.size, g = f.toString(), h = new Uint8Array(g.length + 1), e = 0; e < g.length; e++) h[e] = parseInt(g[e]);
                            if (h[g.length] = 255, u) {
                                var i = new u([b.buffer, h.buffer, a]);
                                c(null, i)
                            }
                        })
                    }
                    h(a, d, function(a, b) {
                        return c(new u(b))
                    })
                }, b.decodePayloadAsBinary = function(a, c, d) {
                    "function" == typeof c && (d = c, c = null);
                    for (var e = a, f = [], g = !1; e.byteLength > 0;) {
                        for (var h = new Uint8Array(e), i = 0 === h[0], j = "", l = 1; 255 != h[l]; l++) {
                            if (j.length > 310) {
                                g = !0;
                                break
                            }
                            j += h[l]
                        }
                        if (g) return d(t, 0, 1);
                        e = k(e, 2 + j.length), j = parseInt(j);
                        var m = k(e, 0, j);
                        if (i) try {
                            m = String.fromCharCode.apply(null, new Uint8Array(m))
                        } catch (a) {
                            var n = new Uint8Array(m);
                            m = "";
                            for (var l = 0; l < n.length; l++) m += String.fromCharCode(n[l])
                        }
                        f.push(m), e = k(e, j)
                    }
                    var o = f.length;
                    f.forEach(function(a, e) {
                        d(b.decodePacket(a, c, !0), e, o)
                    })
                }
            }).call(b, function() {
                return this
            }())
        }, function(a, b) {
            a.exports = Object.keys || function(a) {
                var b = [],
                    c = Object.prototype.hasOwnProperty;
                for (var d in a) c.call(a, d) && b.push(d);
                return b
            }
        }, function(a, b, c) {
            (function(b) {
                function d(a) {
                    function c(a) {
                        if (!a) return !1;
                        if (b.Buffer && b.Buffer.isBuffer(a) || b.ArrayBuffer && a instanceof ArrayBuffer || b.Blob && a instanceof Blob || b.File && a instanceof File) return !0;
                        if (e(a)) {
                            for (var d = 0; d < a.length; d++)
                                if (c(a[d])) return !0
                        } else if (a && "object" == typeof a) {
                            a.toJSON && (a = a.toJSON());
                            for (var f in a)
                                if (Object.prototype.hasOwnProperty.call(a, f) && c(a[f])) return !0
                        }
                        return !1
                    }
                    return c(a)
                }
                var e = c(27);
                a.exports = d
            }).call(b, function() {
                return this
            }())
        }, function(a, b) {
            a.exports = Array.isArray || function(a) {
                return "[object Array]" == Object.prototype.toString.call(a)
            }
        }, function(a, b) {
            a.exports = function(a, b, c) {
                var d = a.byteLength;
                if (b = b || 0, c = c || d, a.slice) return a.slice(b, c);
                if (b < 0 && (b += d), c < 0 && (c += d), c > d && (c = d), b >= d || b >= c || 0 === d) return new ArrayBuffer(0);
                for (var e = new Uint8Array(a), f = new Uint8Array(c - b), g = b, h = 0; g < c; g++, h++) f[h] = e[g];
                return f.buffer
            }
        }, function(a, b) {
            ! function(a) {
                "use strict";
                b.encode = function(b) {
                    var c, d = new Uint8Array(b),
                        e = d.length,
                        f = "";
                    for (c = 0; c < e; c += 3) f += a[d[c] >> 2], f += a[(3 & d[c]) << 4 | d[c + 1] >> 4], f += a[(15 & d[c + 1]) << 2 | d[c + 2] >> 6], f += a[63 & d[c + 2]];
                    return e % 3 === 2 ? f = f.substring(0, f.length - 1) + "=" : e % 3 === 1 && (f = f.substring(0, f.length - 2) + "=="), f
                }, b.decode = function(b) {
                    var c, d, e, f, g, h = .75 * b.length,
                        i = b.length,
                        j = 0;
                    "=" === b[b.length - 1] && (h--, "=" === b[b.length - 2] && h--);
                    var k = new ArrayBuffer(h),
                        l = new Uint8Array(k);
                    for (c = 0; c < i; c += 4) d = a.indexOf(b[c]), e = a.indexOf(b[c + 1]), f = a.indexOf(b[c + 2]), g = a.indexOf(b[c + 3]), l[j++] = d << 2 | e >> 4, l[j++] = (15 & e) << 4 | f >> 2, l[j++] = (3 & f) << 6 | 63 & g;
                    return k
                }
            }("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")
        }, function(a, b) {
            function c(a, b, c) {
                function e(a, d) {
                    if (e.count <= 0) throw new Error("after called too many times");
                    --e.count, a ? (f = !0, b(a), b = c) : 0 !== e.count || f || b(null, d)
                }
                var f = !1;
                return c = c || d, e.count = a, 0 === a ? b() : e
            }

            function d() {}
            a.exports = c
        }, function(a, b, c) {
            var d;
            (function(a, e) {
                ! function(f) {
                    function g(a) {
                        for (var b, c, d = [], e = 0, f = a.length; e < f;) b = a.charCodeAt(e++), b >= 55296 && b <= 56319 && e < f ? (c = a.charCodeAt(e++), 56320 == (64512 & c) ? d.push(((1023 & b) << 10) + (1023 & c) + 65536) : (d.push(b), e--)) : d.push(b);
                        return d
                    }

                    function h(a) {
                        for (var b, c = a.length, d = -1, e = ""; ++d < c;) b = a[d], b > 65535 && (b -= 65536, e += u(b >>> 10 & 1023 | 55296), b = 56320 | 1023 & b), e += u(b);
                        return e
                    }

                    function i(a) {
                        if (a >= 55296 && a <= 57343) throw Error("Lone surrogate U+" + a.toString(16).toUpperCase() + " is not a scalar value")
                    }

                    function j(a, b) {
                        return u(a >> b & 63 | 128)
                    }

                    function k(a) {
                        if (0 == (4294967168 & a)) return u(a);
                        var b = "";
                        return 0 == (4294965248 & a) ? b = u(a >> 6 & 31 | 192) : 0 == (4294901760 & a) ? (i(a), b = u(a >> 12 & 15 | 224), b += j(a, 6)) : 0 == (4292870144 & a) && (b = u(a >> 18 & 7 | 240), b += j(a, 12), b += j(a, 6)), b += u(63 & a | 128)
                    }

                    function l(a) {
                        for (var b, c = g(a), d = c.length, e = -1, f = ""; ++e < d;) b = c[e], f += k(b);
                        return f
                    }

                    function m() {
                        if (t >= s) throw Error("Invalid byte index");
                        var a = 255 & r[t];
                        if (t++, 128 == (192 & a)) return 63 & a;
                        throw Error("Invalid continuation byte")
                    }

                    function n() {
                        var a, b, c, d, e;
                        if (t > s) throw Error("Invalid byte index");
                        if (t == s) return !1;
                        if (a = 255 & r[t], t++, 0 == (128 & a)) return a;
                        if (192 == (224 & a)) {
                            var b = m();
                            if (e = (31 & a) << 6 | b, e >= 128) return e;
                            throw Error("Invalid continuation byte")
                        }
                        if (224 == (240 & a)) {
                            if (b = m(), c = m(), e = (15 & a) << 12 | b << 6 | c, e >= 2048) return i(e), e;
                            throw Error("Invalid continuation byte")
                        }
                        if (240 == (248 & a) && (b = m(), c = m(), d = m(), e = (15 & a) << 18 | b << 12 | c << 6 | d, e >= 65536 && e <= 1114111)) return e;
                        throw Error("Invalid UTF-8 detected")
                    }

                    function o(a) {
                        r = g(a), s = r.length, t = 0;
                        for (var b, c = [];
                            (b = n()) !== !1;) c.push(b);
                        return h(c)
                    }
                    var p = "object" == typeof b && b,
                        q = ("object" == typeof a && a && a.exports == p && a, "object" == typeof e && e);
                    q.global !== q && q.window !== q || (f = q);
                    var r, s, t, u = String.fromCharCode,
                        v = {
                            version: "2.0.0",
                            encode: l,
                            decode: o
                        };
                    d = function() {
                        return v
                    }.call(b, c, b, a), !(void 0 !== d && (a.exports = d))
                }(this)
            }).call(b, c(8)(a), function() {
                return this
            }())
        }, function(a, b) {
            (function(b) {
                function c(a) {
                    for (var b = 0; b < a.length; b++) {
                        var c = a[b];
                        if (c.buffer instanceof ArrayBuffer) {
                            var d = c.buffer;
                            if (c.byteLength !== d.byteLength) {
                                var e = new Uint8Array(c.byteLength);
                                e.set(new Uint8Array(d, c.byteOffset, c.byteLength)), d = e.buffer
                            }
                            a[b] = d
                        }
                    }
                }

                function d(a, b) {
                    b = b || {};
                    var d = new f;
                    c(a);
                    for (var e = 0; e < a.length; e++) d.append(a[e]);
                    return b.type ? d.getBlob(b.type) : d.getBlob()
                }

                function e(a, b) {
                    return c(a), new Blob(a, b || {})
                }
                var f = b.BlobBuilder || b.WebKitBlobBuilder || b.MSBlobBuilder || b.MozBlobBuilder,
                    g = function() {
                        try {
                            var a = new Blob(["hi"]);
                            return 2 === a.size
                        } catch (a) {
                            return !1
                        }
                    }(),
                    h = g && function() {
                        try {
                            var a = new Blob([new Uint8Array([1, 2])]);
                            return 2 === a.size
                        } catch (a) {
                            return !1
                        }
                    }(),
                    i = f && f.prototype.append && f.prototype.getBlob;
                a.exports = function() {
                    return g ? h ? b.Blob : e : i ? d : void 0
                }()
            }).call(b, function() {
                return this
            }())
        }, function(a, b) {
            function c(a) {
                if (a) return d(a)
            }

            function d(a) {
                for (var b in c.prototype) a[b] = c.prototype[b];
                return a
            }
            a.exports = c, c.prototype.on = c.prototype.addEventListener = function(a, b) {
                return this._callbacks = this._callbacks || {}, (this._callbacks[a] = this._callbacks[a] || []).push(b), this
            }, c.prototype.once = function(a, b) {
                function c() {
                    d.off(a, c), b.apply(this, arguments)
                }
                var d = this;
                return this._callbacks = this._callbacks || {}, c.fn = b, this.on(a, c), this
            }, c.prototype.off = c.prototype.removeListener = c.prototype.removeAllListeners = c.prototype.removeEventListener = function(a, b) {
                if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
                var c = this._callbacks[a];
                if (!c) return this;
                if (1 == arguments.length) return delete this._callbacks[a], this;
                for (var d, e = 0; e < c.length; e++)
                    if (d = c[e], d === b || d.fn === b) {
                        c.splice(e, 1);
                        break
                    }
                return this
            }, c.prototype.emit = function(a) {
                this._callbacks = this._callbacks || {};
                var b = [].slice.call(arguments, 1),
                    c = this._callbacks[a];
                if (c) {
                    c = c.slice(0);
                    for (var d = 0, e = c.length; d < e; ++d) c[d].apply(this, b)
                }
                return this
            }, c.prototype.listeners = function(a) {
                return this._callbacks = this._callbacks || {}, this._callbacks[a] || []
            }, c.prototype.hasListeners = function(a) {
                return !!this.listeners(a).length
            }
        }, function(a, b) {
            b.encode = function(a) {
                var b = "";
                for (var c in a) a.hasOwnProperty(c) && (b.length && (b += "&"), b += encodeURIComponent(c) + "=" + encodeURIComponent(a[c]));
                return b
            }, b.decode = function(a) {
                for (var b = {}, c = a.split("&"), d = 0, e = c.length; d < e; d++) {
                    var f = c[d].split("=");
                    b[decodeURIComponent(f[0])] = decodeURIComponent(f[1])
                }
                return b
            }
        }, function(a, b) {
            a.exports = function(a, b) {
                var c = function() {};
                c.prototype = b.prototype, a.prototype = new c, a.prototype.constructor = a
            }
        }, function(a, b) {
            "use strict";

            function c(a) {
                var b = "";
                do b = g[a % h] + b, a = Math.floor(a / h); while (a > 0);
                return b
            }

            function d(a) {
                var b = 0;
                for (k = 0; k < a.length; k++) b = b * h + i[a.charAt(k)];
                return b
            }

            function e() {
                var a = c(+new Date);
                return a !== f ? (j = 0, f = a) : a + "." + c(j++)
            }
            for (var f, g = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), h = 64, i = {}, j = 0, k = 0; k < h; k++) i[g[k]] = k;
            e.encode = c, e.decode = d, a.exports = e
        }, function(a, b, c) {
            (function(b) {
                function d() {}

                function e(a) {
                    f.call(this, a), this.query = this.query || {}, h || (b.___eio || (b.___eio = []), h = b.___eio), this.index = h.length;
                    var c = this;
                    h.push(function(a) {
                        c.onData(a)
                    }), this.query.j = this.index, b.document && b.addEventListener && b.addEventListener("beforeunload", function() {
                        c.script && (c.script.onerror = d)
                    }, !1)
                }
                var f = c(22),
                    g = c(35);
                a.exports = e;
                var h, i = /\n/g,
                    j = /\\n/g;
                g(e, f), e.prototype.supportsBinary = !1, e.prototype.doClose = function() {
                    this.script && (this.script.parentNode.removeChild(this.script), this.script = null), this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null), f.prototype.doClose.call(this)
                }, e.prototype.doPoll = function() {
                    var a = this,
                        b = document.createElement("script");
                    this.script && (this.script.parentNode.removeChild(this.script), this.script = null), b.async = !0, b.src = this.uri(), b.onerror = function(b) {
                        a.onError("jsonp poll error", b)
                    };
                    var c = document.getElementsByTagName("script")[0];
                    c ? c.parentNode.insertBefore(b, c) : (document.head || document.body).appendChild(b), this.script = b;
                    var d = "undefined" != typeof navigator && /gecko/i.test(navigator.userAgent);
                    d && setTimeout(function() {
                        var a = document.createElement("iframe");
                        document.body.appendChild(a), document.body.removeChild(a)
                    }, 100)
                }, e.prototype.doWrite = function(a, b) {
                    function c() {
                        d(), b()
                    }

                    function d() {
                        if (e.iframe) try {
                            e.form.removeChild(e.iframe)
                        } catch (a) {
                            e.onError("jsonp polling iframe removal error", a)
                        }
                        try {
                            var a = '<iframe src="javascript:0" name="' + e.iframeId + '">';
                            f = document.createElement(a)
                        } catch (a) {
                            f = document.createElement("iframe"), f.name = e.iframeId, f.src = "javascript:0"
                        }
                        f.id = e.iframeId, e.form.appendChild(f), e.iframe = f
                    }
                    var e = this;
                    if (!this.form) {
                        var f, g = document.createElement("form"),
                            h = document.createElement("textarea"),
                            k = this.iframeId = "eio_iframe_" + this.index;
                        g.className = "socketio", g.style.position = "absolute", g.style.top = "-1000px", g.style.left = "-1000px", g.target = k, g.method = "POST", g.setAttribute("accept-charset", "utf-8"), h.name = "d", g.appendChild(h), document.body.appendChild(g), this.form = g, this.area = h
                    }
                    this.form.action = this.uri(), d(), a = a.replace(j, "\\\n"), this.area.value = a.replace(i, "\\n");
                    try {
                        this.form.submit()
                    } catch (a) {}
                    this.iframe.attachEvent ? this.iframe.onreadystatechange = function() {
                        "complete" == e.iframe.readyState && c()
                    } : this.iframe.onload = c
                }
            }).call(b, function() {
                return this
            }())
        }, function(a, b, c) {
            (function(b) {
                function d(a) {
                    var b = a && a.forceBase64;
                    b && (this.supportsBinary = !1), this.perMessageDeflate = a.perMessageDeflate, e.call(this, a)
                }
                var e = c(23),
                    f = c(24),
                    g = c(34),
                    h = c(35),
                    i = c(36),
                    j = c(3)("engine.io-client:websocket"),
                    k = b.WebSocket || b.MozWebSocket,
                    l = k;
                if (!l && "undefined" == typeof window) try {
                    l = c(39)
                } catch (a) {}
                a.exports = d, h(d, e), d.prototype.name = "websocket", d.prototype.supportsBinary = !0, d.prototype.doOpen = function() {
                    if (this.check()) {
                        var a = this.uri(),
                            b = void 0,
                            c = {
                                agent: this.agent,
                                perMessageDeflate: this.perMessageDeflate
                            };
                        c.pfx = this.pfx, c.key = this.key, c.passphrase = this.passphrase, c.cert = this.cert, c.ca = this.ca, c.ciphers = this.ciphers, c.rejectUnauthorized = this.rejectUnauthorized, this.extraHeaders && (c.headers = this.extraHeaders), this.ws = k ? new l(a) : new l(a, b, c), void 0 === this.ws.binaryType && (this.supportsBinary = !1), this.ws.supports && this.ws.supports.binary ? (this.supportsBinary = !0, this.ws.binaryType = "buffer") : this.ws.binaryType = "arraybuffer", this.addEventListeners()
                    }
                }, d.prototype.addEventListeners = function() {
                    var a = this;
                    this.ws.onopen = function() {
                        a.onOpen()
                    }, this.ws.onclose = function() {
                        a.onClose()
                    }, this.ws.onmessage = function(b) {
                        a.onData(b.data)
                    }, this.ws.onerror = function(b) {
                        a.onError("websocket error", b)
                    }
                }, "undefined" != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent) && (d.prototype.onData = function(a) {
                    var b = this;
                    setTimeout(function() {
                        e.prototype.onData.call(b, a)
                    }, 0)
                }), d.prototype.write = function(a) {
                    function c() {
                        d.emit("flush"), setTimeout(function() {
                            d.writable = !0, d.emit("drain")
                        }, 0)
                    }
                    var d = this;
                    this.writable = !1;
                    for (var e = a.length, g = 0, h = e; g < h; g++) ! function(a) {
                        f.encodePacket(a, d.supportsBinary, function(f) {
                            if (!k) {
                                var g = {};
                                if (a.options && (g.compress = a.options.compress), d.perMessageDeflate) {
                                    var h = "string" == typeof f ? b.Buffer.byteLength(f) : f.length;
                                    h < d.perMessageDeflate.threshold && (g.compress = !1)
                                }
                            }
                            try {
                                k ? d.ws.send(f) : d.ws.send(f, g)
                            } catch (a) {
                                j("websocket closed before onclose event")
                            }--e || c()
                        })
                    }(a[g])
                }, d.prototype.onClose = function() {
                    e.prototype.onClose.call(this)
                }, d.prototype.doClose = function() {
                    "undefined" != typeof this.ws && this.ws.close()
                }, d.prototype.uri = function() {
                    var a = this.query || {},
                        b = this.secure ? "wss" : "ws",
                        c = "";
                    this.port && ("wss" == b && 443 != this.port || "ws" == b && 80 != this.port) && (c = ":" + this.port), this.timestampRequests && (a[this.timestampParam] = i()), this.supportsBinary || (a.b64 = 1), a = g.encode(a), a.length && (a = "?" + a);
                    var d = this.hostname.indexOf(":") !== -1;
                    return b + "://" + (d ? "[" + this.hostname + "]" : this.hostname) + c + this.path + a
                }, d.prototype.check = function() {
                    return !(!l || "__initialize" in l && this.name === d.prototype.name)
                }
            }).call(b, function() {
                return this
            }())
        }, function(a, b) {}, function(a, b) {
            var c = [].indexOf;
            a.exports = function(a, b) {
                if (c) return a.indexOf(b);
                for (var d = 0; d < a.length; ++d)
                    if (a[d] === b) return d;
                return -1
            }
        }, function(a, b) {
            (function(b) {
                var c = /^[\],:{}\s]*$/,
                    d = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
                    e = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
                    f = /(?:^|:|,)(?:\s*\[)+/g,
                    g = /^\s+/,
                    h = /\s+$/;
                a.exports = function(a) {
                    return "string" == typeof a && a ? (a = a.replace(g, "").replace(h, ""), b.JSON && JSON.parse ? JSON.parse(a) : c.test(a.replace(d, "@").replace(e, "]").replace(f, "")) ? new Function("return " + a)() : void 0) : null
                }
            }).call(b, function() {
                return this
            }())
        }, function(a, b, c) {
            "use strict";

            function d(a, b, c) {
                this.io = a, this.nsp = b, this.json = this, this.ids = 0, this.acks = {}, this.receiveBuffer = [], this.sendBuffer = [], this.connected = !1, this.disconnected = !0, c && c.query && (this.query = c.query), this.io.autoConnect && this.open()
            }
            var e = c(6),
                f = c(43),
                g = c(44),
                h = c(45),
                i = c(46),
                j = c(3)("socket.io-client:socket"),
                k = c(47);
            a.exports = b = d;
            var l = {
                    connect: 1,
                    connect_error: 1,
                    connect_timeout: 1,
                    connecting: 1,
                    disconnect: 1,
                    error: 1,
                    reconnect: 1,
                    reconnect_attempt: 1,
                    reconnect_failed: 1,
                    reconnect_error: 1,
                    reconnecting: 1,
                    ping: 1,
                    pong: 1
                },
                m = f.prototype.emit;
            f(d.prototype), d.prototype.subEvents = function() {
                if (!this.subs) {
                    var a = this.io;
                    this.subs = [h(a, "open", i(this, "onopen")), h(a, "packet", i(this, "onpacket")), h(a, "close", i(this, "onclose"))]
                }
            }, d.prototype.open = d.prototype.connect = function() {
                return this.connected ? this : (this.subEvents(), this.io.open(), "open" === this.io.readyState && this.onopen(), this.emit("connecting"), this)
            }, d.prototype.send = function() {
                var a = g(arguments);
                return a.unshift("message"), this.emit.apply(this, a), this
            }, d.prototype.emit = function(a) {
                if (l.hasOwnProperty(a)) return m.apply(this, arguments), this;
                var b = g(arguments),
                    c = e.EVENT;
                k(b) && (c = e.BINARY_EVENT);
                var d = {
                    type: c,
                    data: b
                };
                return d.options = {}, d.options.compress = !this.flags || !1 !== this.flags.compress, "function" == typeof b[b.length - 1] && (j("emitting packet with ack id %d", this.ids), this.acks[this.ids] = b.pop(), d.id = this.ids++), this.connected ? this.packet(d) : this.sendBuffer.push(d), delete this.flags, this
            }, d.prototype.packet = function(a) {
                a.nsp = this.nsp, this.io.packet(a)
            }, d.prototype.onopen = function() {
                j("transport is open - connecting"), "/" !== this.nsp && (this.query ? this.packet({
                    type: e.CONNECT,
                    query: this.query
                }) : this.packet({
                    type: e.CONNECT
                }))
            }, d.prototype.onclose = function(a) {
                j("close (%s)", a), this.connected = !1, this.disconnected = !0, delete this.id, this.emit("disconnect", a)
            }, d.prototype.onpacket = function(a) {
                if (a.nsp === this.nsp) switch (a.type) {
                    case e.CONNECT:
                        this.onconnect();
                        break;
                    case e.EVENT:
                        this.onevent(a);
                        break;
                    case e.BINARY_EVENT:
                        this.onevent(a);
                        break;
                    case e.ACK:
                        this.onack(a);
                        break;
                    case e.BINARY_ACK:
                        this.onack(a);
                        break;
                    case e.DISCONNECT:
                        this.ondisconnect();
                        break;
                    case e.ERROR:
                        this.emit("error", a.data)
                }
            }, d.prototype.onevent = function(a) {
                var b = a.data || [];
                j("emitting event %j", b), null != a.id && (j("attaching ack callback to event"), b.push(this.ack(a.id))), this.connected ? m.apply(this, b) : this.receiveBuffer.push(b)
            }, d.prototype.ack = function(a) {
                var b = this,
                    c = !1;
                return function() {
                    if (!c) {
                        c = !0;
                        var d = g(arguments);
                        j("sending ack %j", d);
                        var f = k(d) ? e.BINARY_ACK : e.ACK;
                        b.packet({
                            type: f,
                            id: a,
                            data: d
                        })
                    }
                }
            }, d.prototype.onack = function(a) {
                var b = this.acks[a.id];
                "function" == typeof b ? (j("calling ack %s with %j", a.id, a.data), b.apply(this, a.data), delete this.acks[a.id]) : j("bad ack %s", a.id)
            }, d.prototype.onconnect = function() {
                this.connected = !0, this.disconnected = !1, this.emit("connect"), this.emitBuffered()
            }, d.prototype.emitBuffered = function() {
                var a;
                for (a = 0; a < this.receiveBuffer.length; a++) m.apply(this, this.receiveBuffer[a]);
                for (this.receiveBuffer = [], a = 0; a < this.sendBuffer.length; a++) this.packet(this.sendBuffer[a]);
                this.sendBuffer = []
            }, d.prototype.ondisconnect = function() {
                j("server disconnect (%s)", this.nsp), this.destroy(), this.onclose("io server disconnect")
            }, d.prototype.destroy = function() {
                if (this.subs) {
                    for (var a = 0; a < this.subs.length; a++) this.subs[a].destroy();
                    this.subs = null
                }
                this.io.destroy(this);
            }, d.prototype.close = d.prototype.disconnect = function() {
                return this.connected && (j("performing disconnect (%s)", this.nsp), this.packet({
                    type: e.DISCONNECT
                })), this.destroy(), this.connected && this.onclose("io client disconnect"), this
            }, d.prototype.compress = function(a) {
                return this.flags = this.flags || {}, this.flags.compress = a, this
            }
        }, function(a, b) {
            function c(a) {
                if (a) return d(a)
            }

            function d(a) {
                for (var b in c.prototype) a[b] = c.prototype[b];
                return a
            }
            a.exports = c, c.prototype.on = c.prototype.addEventListener = function(a, b) {
                return this._callbacks = this._callbacks || {}, (this._callbacks["$" + a] = this._callbacks["$" + a] || []).push(b), this
            }, c.prototype.once = function(a, b) {
                function c() {
                    this.off(a, c), b.apply(this, arguments)
                }
                return c.fn = b, this.on(a, c), this
            }, c.prototype.off = c.prototype.removeListener = c.prototype.removeAllListeners = c.prototype.removeEventListener = function(a, b) {
                if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
                var c = this._callbacks["$" + a];
                if (!c) return this;
                if (1 == arguments.length) return delete this._callbacks["$" + a], this;
                for (var d, e = 0; e < c.length; e++)
                    if (d = c[e], d === b || d.fn === b) {
                        c.splice(e, 1);
                        break
                    }
                return this
            }, c.prototype.emit = function(a) {
                this._callbacks = this._callbacks || {};
                var b = [].slice.call(arguments, 1),
                    c = this._callbacks["$" + a];
                if (c) {
                    c = c.slice(0);
                    for (var d = 0, e = c.length; d < e; ++d) c[d].apply(this, b)
                }
                return this
            }, c.prototype.listeners = function(a) {
                return this._callbacks = this._callbacks || {}, this._callbacks["$" + a] || []
            }, c.prototype.hasListeners = function(a) {
                return !!this.listeners(a).length
            }
        }, function(a, b) {
            function c(a, b) {
                var c = [];
                b = b || 0;
                for (var d = b || 0; d < a.length; d++) c[d - b] = a[d];
                return c
            }
            a.exports = c
        }, function(a, b) {
            "use strict";

            function c(a, b, c) {
                return a.on(b, c), {
                    destroy: function() {
                        a.removeListener(b, c)
                    }
                }
            }
            a.exports = c
        }, function(a, b) {
            var c = [].slice;
            a.exports = function(a, b) {
                if ("string" == typeof b && (b = a[b]), "function" != typeof b) throw new Error("bind() requires a function");
                var d = c.call(arguments, 2);
                return function() {
                    return b.apply(a, d.concat(c.call(arguments)))
                }
            }
        }, function(a, b, c) {
            (function(b) {
                function d(a) {
                    function c(a) {
                        if (!a) return !1;
                        if (b.Buffer && b.Buffer.isBuffer && b.Buffer.isBuffer(a) || b.ArrayBuffer && a instanceof ArrayBuffer || b.Blob && a instanceof Blob || b.File && a instanceof File) return !0;
                        if (e(a)) {
                            for (var d = 0; d < a.length; d++)
                                if (c(a[d])) return !0
                        } else if (a && "object" == typeof a) {
                            a.toJSON && "function" == typeof a.toJSON && (a = a.toJSON());
                            for (var f in a)
                                if (Object.prototype.hasOwnProperty.call(a, f) && c(a[f])) return !0
                        }
                        return !1
                    }
                    return c(a)
                }
                var e = c(48);
                a.exports = d
            }).call(b, function() {
                return this
            }())
        }, function(a, b) {
            a.exports = Array.isArray || function(a) {
                return "[object Array]" == Object.prototype.toString.call(a)
            }
        }, function(a, b) {
            function c(a) {
                a = a || {}, this.ms = a.min || 100, this.max = a.max || 1e4, this.factor = a.factor || 2, this.jitter = a.jitter > 0 && a.jitter <= 1 ? a.jitter : 0, this.attempts = 0
            }
            a.exports = c, c.prototype.duration = function() {
                var a = this.ms * Math.pow(this.factor, this.attempts++);
                if (this.jitter) {
                    var b = Math.random(),
                        c = Math.floor(b * this.jitter * a);
                    a = 0 == (1 & Math.floor(10 * b)) ? a - c : a + c
                }
                return 0 | Math.min(a, this.max)
            }, c.prototype.reset = function() {
                this.attempts = 0
            }, c.prototype.setMin = function(a) {
                this.ms = a
            }, c.prototype.setMax = function(a) {
                this.max = a
            }, c.prototype.setJitter = function(a) {
                this.jitter = a
            }
        }])
    }),
    function(a, b) {
        "object" == typeof exports && "undefined" != typeof module ? b(exports) : "function" == typeof define && define.amd ? define(["exports"], b) : b(a.THREE = a.THREE || {})
    }(this, function(a) {
        function b() {}

        function c(a, b) {
            this.x = a || 0, this.y = b || 0
        }

        function d(b, e, f, g, h, i, j, k, l, m) {
            Object.defineProperty(this, "id", {
                value: Md++
            }), this.uuid = a.Math.generateUUID(), this.sourceFile = this.name = "", this.image = void 0 !== b ? b : d.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : d.DEFAULT_MAPPING, this.wrapS = void 0 !== f ? f : 1001, this.wrapT = void 0 !== g ? g : 1001, this.magFilter = void 0 !== h ? h : 1006, this.minFilter = void 0 !== i ? i : 1008, this.anisotropy = void 0 !== l ? l : 1, this.format = void 0 !== j ? j : 1023, this.type = void 0 !== k ? k : 1009, this.offset = new c(0, 0), this.repeat = new c(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== m ? m : 3e3, this.version = 0, this.onUpdate = null
        }

        function e(a, b, c, d) {
            this.x = a || 0, this.y = b || 0, this.z = c || 0, this.w = void 0 !== d ? d : 1
        }

        function f(b, c, f) {
            this.uuid = a.Math.generateUUID(), this.width = b, this.height = c, this.scissor = new e(0, 0, b, c), this.scissorTest = !1, this.viewport = new e(0, 0, b, c), f = f || {}, void 0 === f.minFilter && (f.minFilter = 1006), this.texture = new d(void 0, void 0, f.wrapS, f.wrapT, f.magFilter, f.minFilter, f.format, f.type, f.anisotropy, f.encoding), this.depthBuffer = void 0 === f.depthBuffer || f.depthBuffer, this.stencilBuffer = void 0 === f.stencilBuffer || f.stencilBuffer, this.depthTexture = void 0 !== f.depthTexture ? f.depthTexture : null
        }

        function g(a, b, c) {
            f.call(this, a, b, c), this.activeMipMapLevel = this.activeCubeFace = 0
        }

        function h(a, b, c, d) {
            this._x = a || 0, this._y = b || 0, this._z = c || 0, this._w = void 0 !== d ? d : 1
        }

        function i(a, b, c) {
            this.x = a || 0, this.y = b || 0, this.z = c || 0
        }

        function j() {
            this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }

        function k(a, b, c, e, f, g, h, i, j, k) {
            a = void 0 !== a ? a : [], d.call(this, a, void 0 !== b ? b : 301, c, e, f, g, h, i, j, k), this.flipY = !1
        }

        function l(a, b, c) {
            var d = a[0];
            if (0 >= d || 0 < d) return a;
            var e = b * c,
                f = Pd[e];
            if (void 0 === f && (f = new Float32Array(e), Pd[e] = f), 0 !== b)
                for (d.toArray(f, 0), d = 1, e = 0; d !== b; ++d) e += c, a[d].toArray(f, e);
            return f
        }

        function m(a, b) {
            var c = Qd[b];
            void 0 === c && (c = new Int32Array(b), Qd[b] = c);
            for (var d = 0; d !== b; ++d) c[d] = a.allocTextureUnit();
            return c
        }

        function n(a, b) {
            a.uniform1f(this.addr, b)
        }

        function o(a, b) {
            a.uniform1i(this.addr, b)
        }

        function p(a, b) {
            void 0 === b.x ? a.uniform2fv(this.addr, b) : a.uniform2f(this.addr, b.x, b.y)
        }

        function q(a, b) {
            void 0 !== b.x ? a.uniform3f(this.addr, b.x, b.y, b.z) : void 0 !== b.r ? a.uniform3f(this.addr, b.r, b.g, b.b) : a.uniform3fv(this.addr, b)
        }

        function r(a, b) {
            void 0 === b.x ? a.uniform4fv(this.addr, b) : a.uniform4f(this.addr, b.x, b.y, b.z, b.w)
        }

        function s(a, b) {
            a.uniformMatrix2fv(this.addr, !1, b.elements || b)
        }

        function t(a, b) {
            a.uniformMatrix3fv(this.addr, !1, b.elements || b)
        }

        function u(a, b) {
            a.uniformMatrix4fv(this.addr, !1, b.elements || b)
        }

        function v(a, b, c) {
            var d = c.allocTextureUnit();
            a.uniform1i(this.addr, d), c.setTexture2D(b || Nd, d)
        }

        function w(a, b, c) {
            var d = c.allocTextureUnit();
            a.uniform1i(this.addr, d), c.setTextureCube(b || Od, d)
        }

        function x(a, b) {
            a.uniform2iv(this.addr, b)
        }

        function y(a, b) {
            a.uniform3iv(this.addr, b)
        }

        function z(a, b) {
            a.uniform4iv(this.addr, b)
        }

        function A(a) {
            switch (a) {
                case 5126:
                    return n;
                case 35664:
                    return p;
                case 35665:
                    return q;
                case 35666:
                    return r;
                case 35674:
                    return s;
                case 35675:
                    return t;
                case 35676:
                    return u;
                case 35678:
                    return v;
                case 35680:
                    return w;
                case 5124:
                case 35670:
                    return o;
                case 35667:
                case 35671:
                    return x;
                case 35668:
                case 35672:
                    return y;
                case 35669:
                case 35673:
                    return z
            }
        }

        function B(a, b) {
            a.uniform1fv(this.addr, b)
        }

        function C(a, b) {
            a.uniform1iv(this.addr, b)
        }

        function D(a, b) {
            a.uniform2fv(this.addr, l(b, this.size, 2))
        }

        function E(a, b) {
            a.uniform3fv(this.addr, l(b, this.size, 3))
        }

        function F(a, b) {
            a.uniform4fv(this.addr, l(b, this.size, 4))
        }

        function G(a, b) {
            a.uniformMatrix2fv(this.addr, !1, l(b, this.size, 4))
        }

        function H(a, b) {
            a.uniformMatrix3fv(this.addr, !1, l(b, this.size, 9))
        }

        function I(a, b) {
            a.uniformMatrix4fv(this.addr, !1, l(b, this.size, 16))
        }

        function J(a, b, c) {
            var d = b.length,
                e = m(c, d);
            for (a.uniform1iv(this.addr, e), a = 0; a !== d; ++a) c.setTexture2D(b[a] || Nd, e[a])
        }

        function K(a, b, c) {
            var d = b.length,
                e = m(c, d);
            for (a.uniform1iv(this.addr, e), a = 0; a !== d; ++a) c.setTextureCube(b[a] || Od, e[a])
        }

        function L(a) {
            switch (a) {
                case 5126:
                    return B;
                case 35664:
                    return D;
                case 35665:
                    return E;
                case 35666:
                    return F;
                case 35674:
                    return G;
                case 35675:
                    return H;
                case 35676:
                    return I;
                case 35678:
                    return J;
                case 35680:
                    return K;
                case 5124:
                case 35670:
                    return C;
                case 35667:
                case 35671:
                    return x;
                case 35668:
                case 35672:
                    return y;
                case 35669:
                case 35673:
                    return z
            }
        }

        function M(a, b, c) {
            this.id = a, this.addr = c, this.setValue = A(b.type)
        }

        function N(a, b, c) {
            this.id = a, this.addr = c, this.size = b.size, this.setValue = L(b.type)
        }

        function O(a) {
            this.id = a, this.seq = [], this.map = {}
        }

        function P(a, b, c) {
            this.seq = [], this.map = {}, this.renderer = c, c = a.getProgramParameter(b, a.ACTIVE_UNIFORMS);
            for (var d = 0; d !== c; ++d) {
                var e = a.getActiveUniform(b, d),
                    f = a.getUniformLocation(b, e.name),
                    g = this,
                    h = e.name,
                    i = h.length;
                for (Rd.lastIndex = 0;;) {
                    var j = Rd.exec(h),
                        k = Rd.lastIndex,
                        l = j[1],
                        m = j[3];
                    if ("]" === j[2] && (l |= 0), void 0 === m || "[" === m && k + 2 === i) {
                        h = g, e = void 0 === m ? new M(l, e, f) : new N(l, e, f), h.seq.push(e), h.map[e.id] = e;
                        break
                    }
                    m = g.map[l], void 0 === m && (m = new O(l), l = g, g = m, l.seq.push(g), l.map[g.id] = g), g = m
                }
            }
        }

        function Q(a, b, c) {
            return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c)
        }

        function R(a, b) {
            this.min = void 0 !== a ? a : new c(1 / 0, 1 / 0), this.max = void 0 !== b ? b : new c(-(1 / 0), -(1 / 0))
        }

        function S(a, b) {
            var d, e, f, g, h, j, k, l, m, n, o, p, q, r, s, t, u = a.context,
                v = a.state;
            this.render = function(w, x, y) {
                if (0 !== b.length) {
                    w = new i;
                    var z = y.w / y.z,
                        A = .5 * y.z,
                        B = .5 * y.w,
                        C = 16 / y.w,
                        D = new c(C * z, C),
                        E = new i(1, 1, 0),
                        F = new c(1, 1),
                        G = new R;
                    if (G.min.set(0, 0), G.max.set(y.z - 16, y.w - 16), void 0 === r) {
                        var C = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
                            H = new Uint16Array([0, 1, 2, 0, 2, 3]);
                        o = u.createBuffer(), p = u.createBuffer(), u.bindBuffer(u.ARRAY_BUFFER, o), u.bufferData(u.ARRAY_BUFFER, C, u.STATIC_DRAW), u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, p), u.bufferData(u.ELEMENT_ARRAY_BUFFER, H, u.STATIC_DRAW), s = u.createTexture(), t = u.createTexture(), v.bindTexture(u.TEXTURE_2D, s), u.texImage2D(u.TEXTURE_2D, 0, u.RGB, 16, 16, 0, u.RGB, u.UNSIGNED_BYTE, null), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, u.NEAREST), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, u.NEAREST), v.bindTexture(u.TEXTURE_2D, t), u.texImage2D(u.TEXTURE_2D, 0, u.RGBA, 16, 16, 0, u.RGBA, u.UNSIGNED_BYTE, null), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, u.NEAREST), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, u.NEAREST);
                        var C = q = {
                                vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                                fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                            },
                            H = u.createProgram(),
                            I = u.createShader(u.FRAGMENT_SHADER),
                            J = u.createShader(u.VERTEX_SHADER),
                            K = "precision " + a.getPrecision() + " float;\n";
                        u.shaderSource(I, K + C.fragmentShader), u.shaderSource(J, K + C.vertexShader), u.compileShader(I), u.compileShader(J), u.attachShader(H, I), u.attachShader(H, J), u.linkProgram(H), r = H, m = u.getAttribLocation(r, "position"), n = u.getAttribLocation(r, "uv"), d = u.getUniformLocation(r, "renderType"), e = u.getUniformLocation(r, "map"), f = u.getUniformLocation(r, "occlusionMap"), g = u.getUniformLocation(r, "opacity"), h = u.getUniformLocation(r, "color"), j = u.getUniformLocation(r, "scale"), k = u.getUniformLocation(r, "rotation"), l = u.getUniformLocation(r, "screenPosition")
                    }
                    for (u.useProgram(r), v.initAttributes(), v.enableAttribute(m), v.enableAttribute(n), v.disableUnusedAttributes(), u.uniform1i(f, 0), u.uniform1i(e, 1), u.bindBuffer(u.ARRAY_BUFFER, o), u.vertexAttribPointer(m, 2, u.FLOAT, !1, 16, 0), u.vertexAttribPointer(n, 2, u.FLOAT, !1, 16, 8), u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, p), v.disable(u.CULL_FACE), v.setDepthWrite(!1), H = 0, I = b.length; H < I; H++)
                        if (C = 16 / y.w, D.set(C * z, C), J = b[H], w.set(J.matrixWorld.elements[12], J.matrixWorld.elements[13], J.matrixWorld.elements[14]), w.applyMatrix4(x.matrixWorldInverse), w.applyProjection(x.projectionMatrix), E.copy(w), F.x = y.x + E.x * A + A - 8, F.y = y.y + E.y * B + B - 8, !0 === G.containsPoint(F)) {
                            v.activeTexture(u.TEXTURE0), v.bindTexture(u.TEXTURE_2D, null), v.activeTexture(u.TEXTURE1), v.bindTexture(u.TEXTURE_2D, s), u.copyTexImage2D(u.TEXTURE_2D, 0, u.RGB, F.x, F.y, 16, 16, 0), u.uniform1i(d, 0), u.uniform2f(j, D.x, D.y), u.uniform3f(l, E.x, E.y, E.z), v.disable(u.BLEND), v.enable(u.DEPTH_TEST), u.drawElements(u.TRIANGLES, 6, u.UNSIGNED_SHORT, 0), v.activeTexture(u.TEXTURE0), v.bindTexture(u.TEXTURE_2D, t), u.copyTexImage2D(u.TEXTURE_2D, 0, u.RGBA, F.x, F.y, 16, 16, 0), u.uniform1i(d, 1), v.disable(u.DEPTH_TEST), v.activeTexture(u.TEXTURE1), v.bindTexture(u.TEXTURE_2D, s), u.drawElements(u.TRIANGLES, 6, u.UNSIGNED_SHORT, 0), J.positionScreen.copy(E), J.customUpdateCallback ? J.customUpdateCallback(J) : J.updateLensFlares(), u.uniform1i(d, 2), v.enable(u.BLEND);
                            for (var K = 0, L = J.lensFlares.length; K < L; K++) {
                                var M = J.lensFlares[K];
                                .001 < M.opacity && .001 < M.scale && (E.x = M.x, E.y = M.y, E.z = M.z, C = M.size * M.scale / y.w, D.x = C * z, D.y = C, u.uniform3f(l, E.x, E.y, E.z), u.uniform2f(j, D.x, D.y), u.uniform1f(k, M.rotation), u.uniform1f(g, M.opacity), u.uniform3f(h, M.color.r, M.color.g, M.color.b), v.setBlending(M.blending, M.blendEquation, M.blendSrc, M.blendDst), a.setTexture2D(M.texture, 1), u.drawElements(u.TRIANGLES, 6, u.UNSIGNED_SHORT, 0))
                            }
                        }
                    v.enable(u.CULL_FACE), v.enable(u.DEPTH_TEST), v.setDepthWrite(!0), a.resetGLState()
                }
            }
        }

        function T(a, b) {
            function c(a, b) {
                return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : b.id - a.id
            }
            var e, f, g, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B = a.context,
                C = a.state,
                D = new i,
                E = new h,
                F = new i;
            this.render = function(h, i) {
                if (0 !== b.length) {
                    if (void 0 === z) {
                        var G = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                            H = new Uint16Array([0, 1, 2, 0, 2, 3]);
                        x = B.createBuffer(), y = B.createBuffer(), B.bindBuffer(B.ARRAY_BUFFER, x), B.bufferData(B.ARRAY_BUFFER, G, B.STATIC_DRAW), B.bindBuffer(B.ELEMENT_ARRAY_BUFFER, y), B.bufferData(B.ELEMENT_ARRAY_BUFFER, H, B.STATIC_DRAW);
                        var G = B.createProgram(),
                            H = B.createShader(B.VERTEX_SHADER),
                            I = B.createShader(B.FRAGMENT_SHADER);
                        B.shaderSource(H, ["precision " + a.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n")), B.shaderSource(I, ["precision " + a.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n")), B.compileShader(H), B.compileShader(I), B.attachShader(G, H), B.attachShader(G, I), B.linkProgram(G), z = G, v = B.getAttribLocation(z, "position"), w = B.getAttribLocation(z, "uv"), e = B.getUniformLocation(z, "uvOffset"), f = B.getUniformLocation(z, "uvScale"), g = B.getUniformLocation(z, "rotation"), j = B.getUniformLocation(z, "scale"), k = B.getUniformLocation(z, "color"), l = B.getUniformLocation(z, "map"), m = B.getUniformLocation(z, "opacity"), n = B.getUniformLocation(z, "modelViewMatrix"), o = B.getUniformLocation(z, "projectionMatrix"), p = B.getUniformLocation(z, "fogType"), q = B.getUniformLocation(z, "fogDensity"), r = B.getUniformLocation(z, "fogNear"), s = B.getUniformLocation(z, "fogFar"), t = B.getUniformLocation(z, "fogColor"), u = B.getUniformLocation(z, "alphaTest"), G = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), G.width = 8, G.height = 8, H = G.getContext("2d"), H.fillStyle = "white", H.fillRect(0, 0, 8, 8), A = new d(G), A.needsUpdate = !0
                    }
                    B.useProgram(z), C.initAttributes(), C.enableAttribute(v), C.enableAttribute(w), C.disableUnusedAttributes(), C.disable(B.CULL_FACE), C.enable(B.BLEND), B.bindBuffer(B.ARRAY_BUFFER, x), B.vertexAttribPointer(v, 2, B.FLOAT, !1, 16, 0), B.vertexAttribPointer(w, 2, B.FLOAT, !1, 16, 8), B.bindBuffer(B.ELEMENT_ARRAY_BUFFER, y), B.uniformMatrix4fv(o, !1, i.projectionMatrix.elements), C.activeTexture(B.TEXTURE0), B.uniform1i(l, 0), H = G = 0, (I = h.fog) ? (B.uniform3f(t, I.color.r, I.color.g, I.color.b), I && I.isFog ? (B.uniform1f(r, I.near), B.uniform1f(s, I.far), B.uniform1i(p, 1), H = G = 1) : I && I.isFogExp2 && (B.uniform1f(q, I.density), B.uniform1i(p, 2), H = G = 2)) : (B.uniform1i(p, 0), H = G = 0);
                    for (var I = 0, J = b.length; I < J; I++) {
                        var K = b[I];
                        K.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, K.matrixWorld), K.z = -K.modelViewMatrix.elements[14]
                    }
                    b.sort(c);
                    for (var L = [], I = 0, J = b.length; I < J; I++) {
                        var K = b[I],
                            M = K.material;
                        !1 !== M.visible && (B.uniform1f(u, M.alphaTest), B.uniformMatrix4fv(n, !1, K.modelViewMatrix.elements), K.matrixWorld.decompose(D, E, F), L[0] = F.x, L[1] = F.y, K = 0, h.fog && M.fog && (K = H), G !== K && (B.uniform1i(p, K), G = K), null !== M.map ? (B.uniform2f(e, M.map.offset.x, M.map.offset.y), B.uniform2f(f, M.map.repeat.x, M.map.repeat.y)) : (B.uniform2f(e, 0, 0), B.uniform2f(f, 1, 1)), B.uniform1f(m, M.opacity), B.uniform3f(k, M.color.r, M.color.g, M.color.b), B.uniform1f(g, M.rotation), B.uniform2fv(j, L), C.setBlending(M.blending, M.blendEquation, M.blendSrc, M.blendDst), C.setDepthTest(M.depthTest), C.setDepthWrite(M.depthWrite), M.map ? a.setTexture2D(M.map, 0) : a.setTexture2D(A, 0), B.drawElements(B.TRIANGLES, 6, B.UNSIGNED_SHORT, 0))
                    }
                    C.enable(B.CULL_FACE), a.resetGLState()
                }
            }
        }

        function U() {
            Object.defineProperty(this, "id", {
                value: Vd++
            }), this.uuid = a.Math.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = !0, this.blending = 1, this.side = 0, this.shading = 2, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, this.clipShadows = !1, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this._needsUpdate = this.visible = !0
        }

        function V(a) {
            U.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = {
                derivatives: !1,
                fragDepth: !1,
                drawBuffers: !1,
                shaderTextureLOD: !1
            }, this.defaultAttributeValues = {
                color: [1, 1, 1],
                uv: [0, 0],
                uv2: [0, 0]
            }, this.index0AttributeName = void 0, void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(a))
        }

        function W(a) {
            U.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.setValues(a)
        }

        function X(a, b) {
            this.min = void 0 !== a ? a : new i(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== b ? b : new i(-(1 / 0), -(1 / 0), -(1 / 0))
        }

        function Y(a, b) {
            this.center = void 0 !== a ? a : new i, this.radius = void 0 !== b ? b : 0
        }

        function Z() {
            this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }

        function $(a, b) {
            this.normal = void 0 !== a ? a : new i(1, 0, 0), this.constant = void 0 !== b ? b : 0
        }

        function _(a, b, c, d, e, f) {
            this.planes = [void 0 !== a ? a : new $, void 0 !== b ? b : new $, void 0 !== c ? c : new $, void 0 !== d ? d : new $, void 0 !== e ? e : new $, void 0 !== f ? f : new $]
        }

        function aa(b, d, g, h) {
            function k(a, c, d, e) {
                var f, g = a.geometry;
                f = w;
                var h = a.customDepthMaterial;
                return d && (f = x, h = a.customDistanceMaterial), h ? f = h : (h = !1, c.morphTargets && (g && g.isBufferGeometry ? h = g.morphAttributes && g.morphAttributes.position && 0 < g.morphAttributes.position.length : g && g.isGeometry && (h = g.morphTargets && 0 < g.morphTargets.length)), a = a.isSkinnedMesh && c.skinning, g = 0, h && (g |= 1), a && (g |= 2), f = f[g]), b.localClippingEnabled && !0 === c.clipShadows && 0 !== c.clippingPlanes.length && (g = f.uuid, h = c.uuid, a = y[g], void 0 === a && (a = {}, y[g] = a), g = a[h], void 0 === g && (g = f.clone(), a[h] = g), f = g), f.visible = c.visible, f.wireframe = c.wireframe, h = c.side, H.renderSingleSided && 2 == h && (h = 0), H.renderReverseSided && (0 === h ? h = 1 : 1 === h && (h = 0)), f.side = h, f.clipShadows = c.clipShadows, f.clippingPlanes = c.clippingPlanes, f.wireframeLinewidth = c.wireframeLinewidth, f.linewidth = c.linewidth, d && void 0 !== f.uniforms.lightPos && f.uniforms.lightPos.value.copy(e), f
            }

            function l(a, b, c) {
                if (!1 !== a.visible) {
                    0 !== (a.layers.mask & b.layers.mask) && (a.isMesh || a.isLine || a.isPoints) && a.castShadow && (!1 === a.frustumCulled || !0 === o.intersectsObject(a)) && !0 === a.material.visible && (a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse, a.matrixWorld), v.push(a)), a = a.children;
                    for (var d = 0, e = a.length; d < e; d++) l(a[d], b, c)
                }
            }
            var m = b.context,
                n = b.state,
                o = new _,
                p = new j,
                q = d.shadows,
                r = new c,
                s = new c(h.maxTextureSize, h.maxTextureSize),
                t = new i,
                u = new i,
                v = [],
                w = Array(4),
                x = Array(4),
                y = {},
                z = [new i(1, 0, 0), new i(-1, 0, 0), new i(0, 0, 1), new i(0, 0, -1), new i(0, 1, 0), new i(0, -1, 0)],
                A = [new i(0, 1, 0), new i(0, 1, 0), new i(0, 1, 0), new i(0, 1, 0), new i(0, 0, 1), new i(0, 0, -1)],
                B = [new e, new e, new e, new e, new e, new e];
            d = new W, d.depthPacking = 3201, d.clipping = !0, h = Ud.distanceRGBA;
            for (var C = a.UniformsUtils.clone(h.uniforms), D = 0; 4 !== D; ++D) {
                var E = 0 !== (1 & D),
                    F = 0 !== (2 & D),
                    G = d.clone();
                G.morphTargets = E, G.skinning = F, w[D] = G, E = new V({
                    defines: {
                        USE_SHADOWMAP: ""
                    },
                    uniforms: C,
                    vertexShader: h.vertexShader,
                    fragmentShader: h.fragmentShader,
                    morphTargets: E,
                    skinning: F,
                    clipping: !0
                }), x[D] = E
            }
            var H = this;
            this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.renderSingleSided = this.renderReverseSided = !0, this.render = function(a, c) {
                if (!1 !== H.enabled && (!1 !== H.autoUpdate || !1 !== H.needsUpdate) && 0 !== q.length) {
                    n.clearColor(1, 1, 1, 1), n.disable(m.BLEND), n.setDepthTest(!0), n.setScissorTest(!1);
                    for (var d, e, h = 0, i = q.length; h < i; h++) {
                        var j = q[h],
                            w = j.shadow;
                        if (void 0 === w) console.warn("THREE.WebGLShadowMap:", j, "has no shadow.");
                        else {
                            var x = w.camera;
                            if (r.copy(w.mapSize), r.min(s), j && j.isPointLight) {
                                d = 6, e = !0;
                                var y = r.x,
                                    C = r.y;
                                B[0].set(2 * y, C, y, C), B[1].set(0, C, y, C), B[2].set(3 * y, C, y, C), B[3].set(y, C, y, C), B[4].set(3 * y, 0, y, C), B[5].set(y, 0, y, C), r.x *= 4, r.y *= 2
                            } else d = 1, e = !1;
                            for (null === w.map && (w.map = new f(r.x, r.y, {
                                    minFilter: 1003,
                                    magFilter: 1003,
                                    format: 1023
                                }), x.updateProjectionMatrix()), w && w.isSpotLightShadow && w.update(j), y = w.map, w = w.matrix, u.setFromMatrixPosition(j.matrixWorld), x.position.copy(u), b.setRenderTarget(y), b.clear(), y = 0; y < d; y++) {
                                e ? (t.copy(x.position), t.add(z[y]), x.up.copy(A[y]), x.lookAt(t), n.viewport(B[y])) : (t.setFromMatrixPosition(j.target.matrixWorld), x.lookAt(t)), x.updateMatrixWorld(), x.matrixWorldInverse.getInverse(x.matrixWorld), w.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), w.multiply(x.projectionMatrix), w.multiply(x.matrixWorldInverse), p.multiplyMatrices(x.projectionMatrix, x.matrixWorldInverse), o.setFromMatrix(p), v.length = 0, l(a, c, x);
                                for (var C = 0, D = v.length; C < D; C++) {
                                    var E = v[C],
                                        F = g.update(E),
                                        G = E.material;
                                    if (G && G.isMultiMaterial)
                                        for (var I = F.groups, G = G.materials, J = 0, K = I.length; J < K; J++) {
                                            var L = I[J],
                                                M = G[L.materialIndex];
                                            !0 === M.visible && (M = k(E, M, e, u), b.renderBufferDirect(x, null, F, M, E, L))
                                        } else M = k(E, G, e, u), b.renderBufferDirect(x, null, F, M, E, null)
                                }
                            }
                        }
                    }
                    d = b.getClearColor(), e = b.getClearAlpha(), b.setClearColor(d, e), H.needsUpdate = !1
                }
            }
        }

        function ba(a, b) {
            this.origin = void 0 !== a ? a : new i, this.direction = void 0 !== b ? b : new i
        }

        function ca(a, b, c, d) {
            this._x = a || 0, this._y = b || 0, this._z = c || 0, this._order = d || ca.DefaultOrder
        }

        function da() {
            this.mask = 1
        }

        function ea() {
            Object.defineProperty(this, "id", {
                value: Wd++
            }), this.uuid = a.Math.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ea.DefaultUp.clone();
            var b = new i,
                c = new ca,
                d = new h,
                e = new i(1, 1, 1);
            c.onChange(function() {
                d.setFromEuler(c, !1)
            }), d.onChange(function() {
                c.setFromQuaternion(d, void 0, !1)
            }), Object.defineProperties(this, {
                position: {
                    enumerable: !0,
                    value: b
                },
                rotation: {
                    enumerable: !0,
                    value: c
                },
                quaternion: {
                    enumerable: !0,
                    value: d
                },
                scale: {
                    enumerable: !0,
                    value: e
                },
                modelViewMatrix: {
                    value: new j
                },
                normalMatrix: {
                    value: new Z
                }
            }), this.matrix = new j, this.matrixWorld = new j, this.matrixAutoUpdate = ea.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new da, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}, this.onBeforeRender = null
        }

        function fa(a, b) {
            this.start = void 0 !== a ? a : new i, this.end = void 0 !== b ? b : new i
        }

        function ga(a, b, c) {
            this.a = void 0 !== a ? a : new i, this.b = void 0 !== b ? b : new i, this.c = void 0 !== c ? c : new i
        }

        function ha(a, b, c, d, e, f) {
            this.a = a, this.b = b, this.c = c, this.normal = d && d.isVector3 ? d : new i, this.vertexNormals = Array.isArray(d) ? d : [], this.color = e && e.isColor ? e : new Q, this.vertexColors = Array.isArray(e) ? e : [], this.materialIndex = void 0 !== f ? f : 0
        }

        function ia(a) {
            U.call(this), this.type = "MeshBasicMaterial", this.color = new Q(16777215), this.aoMap = this.map = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.lights = this.morphTargets = this.skinning = !1, this.setValues(a)
        }

        function ja(b, c, d) {
            if (Array.isArray(b)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            this.uuid = a.Math.generateUUID(), this.array = b, this.itemSize = c, this.count = void 0 !== b ? b.length / c : 0, this.normalized = !0 === d, this.dynamic = !1, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }

        function ka(a, b) {
            return new ja(new Uint16Array(a), b)
        }

        function la(a, b) {
            return new ja(new Uint32Array(a), b)
        }

        function ma(a, b) {
            return new ja(new Float32Array(a), b)
        }

        function na() {
            Object.defineProperty(this, "id", {
                value: Xd++
            }), this.uuid = a.Math.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                []
            ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
        }

        function oa() {
            Object.defineProperty(this, "id", {
                value: Xd++
            }), this.uuid = a.Math.generateUUID(), this.name = "", this.type = "DirectGeometry", this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
        }

        function pa() {
            Object.defineProperty(this, "id", {
                value: Xd++
            }), this.uuid = a.Math.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = {
                start: 0,
                count: 1 / 0
            }
        }

        function qa(a, b) {
            ea.call(this), this.type = "Mesh", this.geometry = void 0 !== a ? a : new pa, this.material = void 0 !== b ? b : new ia({
                color: 16777215 * Math.random()
            }), this.drawMode = 0, this.updateMorphTargets()
        }

        function ra(a, b, c, d, e, f) {
            function g(a, b, c, d, e, f, g, j, k, u, v) {
                var w = f / k,
                    x = g / u,
                    y = f / 2,
                    z = g / 2,
                    A = j / 2;
                g = k + 1;
                for (var B = u + 1, C = f = 0, D = new i, E = 0; E < B; E++)
                    for (var F = E * x - z, G = 0; G < g; G++) D[a] = (G * w - y) * d, D[b] = F * e, D[c] = A, m[p] = D.x, m[p + 1] = D.y, m[p + 2] = D.z, D[a] = 0, D[b] = 0, D[c] = 0 < j ? 1 : -1, n[p] = D.x, n[p + 1] = D.y, n[p + 2] = D.z, o[q] = G / k, o[q + 1] = 1 - E / u, p += 3, q += 2, f += 1;
                for (E = 0; E < u; E++)
                    for (G = 0; G < k; G++) a = s + G + g * (E + 1), b = s + (G + 1) + g * (E + 1), c = s + (G + 1) + g * E, l[r] = s + G + g * E, l[r + 1] = a, l[r + 2] = c, l[r + 3] = a, l[r + 4] = b, l[r + 5] = c, r += 6, C += 6;
                h.addGroup(t, C, v), t += C, s += f
            }
            pa.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                width: a,
                height: b,
                depth: c,
                widthSegments: d,
                heightSegments: e,
                depthSegments: f
            };
            var h = this;
            d = Math.floor(d) || 1, e = Math.floor(e) || 1, f = Math.floor(f) || 1;
            var j = function(a, b, c) {
                    return a = 0 + (a + 1) * (b + 1) * 2 + (a + 1) * (c + 1) * 2 + (c + 1) * (b + 1) * 2
                }(d, e, f),
                k = function(a, b, c) {
                    return a = 0 + a * b * 2 + a * c * 2 + c * b * 2, 6 * a
                }(d, e, f),
                l = new(65535 < k ? Uint32Array : Uint16Array)(k),
                m = new Float32Array(3 * j),
                n = new Float32Array(3 * j),
                o = new Float32Array(2 * j),
                p = 0,
                q = 0,
                r = 0,
                s = 0,
                t = 0;
            g("z", "y", "x", -1, -1, c, b, a, f, e, 0), g("z", "y", "x", 1, -1, c, b, -a, f, e, 1), g("x", "z", "y", 1, 1, a, c, b, d, f, 2), g("x", "z", "y", 1, -1, a, c, -b, d, f, 3), g("x", "y", "z", 1, -1, a, b, c, d, e, 4), g("x", "y", "z", -1, -1, a, b, -c, d, e, 5), this.setIndex(new ja(l, 1)), this.addAttribute("position", new ja(m, 3)), this.addAttribute("normal", new ja(n, 3)), this.addAttribute("uv", new ja(o, 2))
        }

        function sa(a, b, c, d) {
            pa.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                width: a,
                height: b,
                widthSegments: c,
                heightSegments: d
            };
            var e = a / 2,
                f = b / 2;
            c = Math.floor(c) || 1, d = Math.floor(d) || 1;
            var g = c + 1,
                h = d + 1,
                i = a / c,
                j = b / d;
            b = new Float32Array(g * h * 3), a = new Float32Array(g * h * 3);
            for (var k = new Float32Array(g * h * 2), l = 0, m = 0, n = 0; n < h; n++)
                for (var o = n * j - f, p = 0; p < g; p++) b[l] = p * i - e, b[l + 1] = -o, a[l + 2] = 1, k[m] = p / c, k[m + 1] = 1 - n / d, l += 3, m += 2;
            for (l = 0, e = new(65535 < b.length / 3 ? Uint32Array : Uint16Array)(c * d * 6), n = 0; n < d; n++)
                for (p = 0; p < c; p++) f = p + g * (n + 1), h = p + 1 + g * (n + 1), i = p + 1 + g * n, e[l] = p + g * n, e[l + 1] = f, e[l + 2] = i, e[l + 3] = f, e[l + 4] = h, e[l + 5] = i, l += 6;
            this.setIndex(new ja(e, 1)), this.addAttribute("position", new ja(b, 3)), this.addAttribute("normal", new ja(a, 3)), this.addAttribute("uv", new ja(k, 2))
        }

        function ta() {
            ea.call(this), this.type = "Camera", this.matrixWorldInverse = new j, this.projectionMatrix = new j
        }

        function ua(a, b, c, d) {
            ta.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== a ? a : 50, this.zoom = 1, this.near = void 0 !== c ? c : .1, this.far = void 0 !== d ? d : 2e3, this.focus = 10, this.aspect = void 0 !== b ? b : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
        }

        function va(a, b, c, d, e, f) {
            ta.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = a, this.right = b, this.top = c, this.bottom = d, this.near = void 0 !== e ? e : .1, this.far = void 0 !== f ? f : 2e3, this.updateProjectionMatrix()
        }

        function wa(a, b, c) {
            var d, e, f;
            return {
                setMode: function(a) {
                    d = a
                },
                setIndex: function(c) {
                    c.array instanceof Uint32Array && b.get("OES_element_index_uint") ? (e = a.UNSIGNED_INT, f = 4) : (e = a.UNSIGNED_SHORT, f = 2)
                },
                render: function(b, g) {
                    a.drawElements(d, g, e, b * f), c.calls++, c.vertices += g, d === a.TRIANGLES && (c.faces += g / 3)
                },
                renderInstances: function(g, h, i) {
                    var j = b.get("ANGLE_instanced_arrays");
                    null === j ? console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (j.drawElementsInstancedANGLE(d, i, e, h * f, g.maxInstancedCount),
                        c.calls++, c.vertices += i * g.maxInstancedCount, d === a.TRIANGLES && (c.faces += g.maxInstancedCount * i / 3))
                }
            }
        }

        function xa(a, b, c) {
            var d;
            return {
                setMode: function(a) {
                    d = a
                },
                render: function(b, e) {
                    a.drawArrays(d, b, e), c.calls++, c.vertices += e, d === a.TRIANGLES && (c.faces += e / 3)
                },
                renderInstances: function(e) {
                    var f = b.get("ANGLE_instanced_arrays");
                    if (null === f) console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    else {
                        var g = e.attributes.position,
                            g = g && g.isInterleavedBufferAttribute ? g.data.count : g.count;
                        f.drawArraysInstancedANGLE(d, 0, g, e.maxInstancedCount), c.calls++, c.vertices += g * e.maxInstancedCount, d === a.TRIANGLES && (c.faces += e.maxInstancedCount * g / 3)
                    }
                }
            }
        }

        function ya() {
            var a = {};
            return {
                get: function(b) {
                    if (void 0 !== a[b.id]) return a[b.id];
                    var d;
                    switch (b.type) {
                        case "DirectionalLight":
                            d = {
                                direction: new i,
                                color: new Q,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new c
                            };
                            break;
                        case "SpotLight":
                            d = {
                                position: new i,
                                direction: new i,
                                color: new Q,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new c
                            };
                            break;
                        case "PointLight":
                            d = {
                                position: new i,
                                color: new Q,
                                distance: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new c
                            };
                            break;
                        case "HemisphereLight":
                            d = {
                                direction: new i,
                                skyColor: new Q,
                                groundColor: new Q
                            }
                    }
                    return a[b.id] = d
                }
            }
        }

        function za(a) {
            a = a.split("\n");
            for (var b = 0; b < a.length; b++) a[b] = b + 1 + ": " + a[b];
            return a.join("\n")
        }

        function Aa(a, b, c) {
            var d = a.createShader(b);
            return a.shaderSource(d, c), a.compileShader(d), !1 === a.getShaderParameter(d, a.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== a.getShaderInfoLog(d) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", b === a.VERTEX_SHADER ? "vertex" : "fragment", a.getShaderInfoLog(d), za(c)), d
        }

        function Ba(a) {
            switch (a) {
                case 3e3:
                    return ["Linear", "( value )"];
                case 3001:
                    return ["sRGB", "( value )"];
                case 3002:
                    return ["RGBE", "( value )"];
                case 3004:
                    return ["RGBM", "( value, 7.0 )"];
                case 3005:
                    return ["RGBM", "( value, 16.0 )"];
                case 3006:
                    return ["RGBD", "( value, 256.0 )"];
                case 3007:
                    return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                default:
                    throw Error("unsupported encoding: " + a)
            }
        }

        function Ca(a, b) {
            var c = Ba(b);
            return "vec4 " + a + "( vec4 value ) { return " + c[0] + "ToLinear" + c[1] + "; }"
        }

        function Da(a, b) {
            var c = Ba(b);
            return "vec4 " + a + "( vec4 value ) { return LinearTo" + c[0] + c[1] + "; }"
        }

        function Ea(a, b) {
            var c;
            switch (b) {
                case 1:
                    c = "Linear";
                    break;
                case 2:
                    c = "Reinhard";
                    break;
                case 3:
                    c = "Uncharted2";
                    break;
                case 4:
                    c = "OptimizedCineon";
                    break;
                default:
                    throw Error("unsupported toneMapping: " + b)
            }
            return "vec3 " + a + "( vec3 color ) { return " + c + "ToneMapping( color ); }"
        }

        function Fa(a, b, c) {
            return a = a || {}, [a.derivatives || b.envMapCubeUV || b.bumpMap || b.normalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ha).join("\n")
        }

        function Ga(a) {
            var b, c = [];
            for (b in a) {
                var d = a[b];
                !1 !== d && c.push("#define " + b + " " + d)
            }
            return c.join("\n")
        }

        function Ha(a) {
            return "" !== a
        }

        function Ia(a, b) {
            return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights)
        }

        function Ja(a) {
            return a.replace(/#include +<([\w\d.]+)>/g, function(a, b) {
                var c = Sd[b];
                if (void 0 === c) throw Error("Can not resolve #include <" + b + ">");
                return Ja(c)
            })
        }

        function Ka(a) {
            return a.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(a, b, c, d) {
                for (a = "", b = parseInt(b); b < parseInt(c); b++) a += d.replace(/\[ i \]/g, "[ " + b + " ]");
                return a
            })
        }

        function La(a, b, c, d) {
            var e = a.context,
                f = c.extensions,
                g = c.defines,
                h = c.__webglShader.vertexShader,
                i = c.__webglShader.fragmentShader,
                j = "SHADOWMAP_TYPE_BASIC";
            1 === d.shadowMapType ? j = "SHADOWMAP_TYPE_PCF" : 2 === d.shadowMapType && (j = "SHADOWMAP_TYPE_PCF_SOFT");
            var k = "ENVMAP_TYPE_CUBE",
                l = "ENVMAP_MODE_REFLECTION",
                m = "ENVMAP_BLENDING_MULTIPLY";
            if (d.envMap) {
                switch (c.envMap.mapping) {
                    case 301:
                    case 302:
                        k = "ENVMAP_TYPE_CUBE";
                        break;
                    case 306:
                    case 307:
                        k = "ENVMAP_TYPE_CUBE_UV";
                        break;
                    case 303:
                    case 304:
                        k = "ENVMAP_TYPE_EQUIREC";
                        break;
                    case 305:
                        k = "ENVMAP_TYPE_SPHERE"
                }
                switch (c.envMap.mapping) {
                    case 302:
                    case 304:
                        l = "ENVMAP_MODE_REFRACTION"
                }
                switch (c.combine) {
                    case 0:
                        m = "ENVMAP_BLENDING_MULTIPLY";
                        break;
                    case 1:
                        m = "ENVMAP_BLENDING_MIX";
                        break;
                    case 2:
                        m = "ENVMAP_BLENDING_ADD"
                }
            }
            var n = 0 < a.gammaFactor ? a.gammaFactor : 1,
                f = Fa(f, d, a.extensions),
                o = Ga(g),
                p = e.createProgram();
            c.isRawShaderMaterial ? (g = [o, "\n"].filter(Ha).join("\n"), j = [f, o, "\n"].filter(Ha).join("\n")) : (g = ["precision " + d.precision + " float;", "precision " + d.precision + " int;", "#define SHADER_NAME " + c.__webglShader.name, o, d.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + n, "#define MAX_BONES " + d.maxBones, d.map ? "#define USE_MAP" : "", d.envMap ? "#define USE_ENVMAP" : "", d.envMap ? "#define " + l : "", d.lightMap ? "#define USE_LIGHTMAP" : "", d.aoMap ? "#define USE_AOMAP" : "", d.emissiveMap ? "#define USE_EMISSIVEMAP" : "", d.bumpMap ? "#define USE_BUMPMAP" : "", d.normalMap ? "#define USE_NORMALMAP" : "", d.displacementMap && d.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", d.specularMap ? "#define USE_SPECULARMAP" : "", d.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", d.metalnessMap ? "#define USE_METALNESSMAP" : "", d.alphaMap ? "#define USE_ALPHAMAP" : "", d.vertexColors ? "#define USE_COLOR" : "", d.flatShading ? "#define FLAT_SHADED" : "", d.skinning ? "#define USE_SKINNING" : "", d.useVertexTexture ? "#define BONE_TEXTURE" : "", d.morphTargets ? "#define USE_MORPHTARGETS" : "", d.morphNormals && !1 === d.flatShading ? "#define USE_MORPHNORMALS" : "", d.doubleSided ? "#define DOUBLE_SIDED" : "", d.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + d.numClippingPlanes, d.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", d.shadowMapEnabled ? "#define " + j : "", d.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", d.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", d.logarithmicDepthBuffer && a.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ha).join("\n"), j = [f, "precision " + d.precision + " float;", "precision " + d.precision + " int;", "#define SHADER_NAME " + c.__webglShader.name, o, d.alphaTest ? "#define ALPHATEST " + d.alphaTest : "", "#define GAMMA_FACTOR " + n, d.useFog && d.fog ? "#define USE_FOG" : "", d.useFog && d.fogExp ? "#define FOG_EXP2" : "", d.map ? "#define USE_MAP" : "", d.envMap ? "#define USE_ENVMAP" : "", d.envMap ? "#define " + k : "", d.envMap ? "#define " + l : "", d.envMap ? "#define " + m : "", d.lightMap ? "#define USE_LIGHTMAP" : "", d.aoMap ? "#define USE_AOMAP" : "", d.emissiveMap ? "#define USE_EMISSIVEMAP" : "", d.bumpMap ? "#define USE_BUMPMAP" : "", d.normalMap ? "#define USE_NORMALMAP" : "", d.specularMap ? "#define USE_SPECULARMAP" : "", d.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", d.metalnessMap ? "#define USE_METALNESSMAP" : "", d.alphaMap ? "#define USE_ALPHAMAP" : "", d.vertexColors ? "#define USE_COLOR" : "", d.flatShading ? "#define FLAT_SHADED" : "", d.doubleSided ? "#define DOUBLE_SIDED" : "", d.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + d.numClippingPlanes, d.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", d.shadowMapEnabled ? "#define " + j : "", d.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", d.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", d.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", d.logarithmicDepthBuffer && a.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", d.envMap && a.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== d.toneMapping ? "#define TONE_MAPPING" : "", 0 !== d.toneMapping ? Sd.tonemapping_pars_fragment : "", 0 !== d.toneMapping ? Ea("toneMapping", d.toneMapping) : "", d.outputEncoding || d.mapEncoding || d.envMapEncoding || d.emissiveMapEncoding ? Sd.encodings_pars_fragment : "", d.mapEncoding ? Ca("mapTexelToLinear", d.mapEncoding) : "", d.envMapEncoding ? Ca("envMapTexelToLinear", d.envMapEncoding) : "", d.emissiveMapEncoding ? Ca("emissiveMapTexelToLinear", d.emissiveMapEncoding) : "", d.outputEncoding ? Da("linearToOutputTexel", d.outputEncoding) : "", d.depthPacking ? "#define DEPTH_PACKING " + c.depthPacking : "", "\n"].filter(Ha).join("\n")), h = Ja(h, d), h = Ia(h, d), i = Ja(i, d), i = Ia(i, d), c.isShaderMaterial || (h = Ka(h), i = Ka(i)), i = j + i, h = Aa(e, e.VERTEX_SHADER, g + h), i = Aa(e, e.FRAGMENT_SHADER, i), e.attachShader(p, h), e.attachShader(p, i), void 0 !== c.index0AttributeName ? e.bindAttribLocation(p, 0, c.index0AttributeName) : !0 === d.morphTargets && e.bindAttribLocation(p, 0, "position"), e.linkProgram(p), d = e.getProgramInfoLog(p), k = e.getShaderInfoLog(h), l = e.getShaderInfoLog(i), n = m = !0, !1 === e.getProgramParameter(p, e.LINK_STATUS) ? (m = !1, console.error("THREE.WebGLProgram: shader error: ", e.getError(), "gl.VALIDATE_STATUS", e.getProgramParameter(p, e.VALIDATE_STATUS), "gl.getProgramInfoLog", d, k, l)) : "" !== d ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", d) : "" !== k && "" !== l || (n = !1), n && (this.diagnostics = {
                runnable: m,
                material: c,
                programLog: d,
                vertexShader: {
                    log: k,
                    prefix: g
                },
                fragmentShader: {
                    log: l,
                    prefix: j
                }
            }), e.deleteShader(h), e.deleteShader(i);
            var q;
            this.getUniforms = function() {
                return void 0 === q && (q = new P(e, p, a)), q
            };
            var r;
            return this.getAttributes = function() {
                if (void 0 === r) {
                    for (var a = {}, b = e.getProgramParameter(p, e.ACTIVE_ATTRIBUTES), c = 0; c < b; c++) {
                        var d = e.getActiveAttrib(p, c).name;
                        a[d] = e.getAttribLocation(p, d)
                    }
                    r = a
                }
                return r
            }, this.destroy = function() {
                e.deleteProgram(p), this.program = void 0
            }, Object.defineProperties(this, {
                uniforms: {
                    get: function() {
                        return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                    }
                },
                attributes: {
                    get: function() {
                        return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                    }
                }
            }), this.id = Yd++, this.code = b, this.usedTimes = 1, this.program = p, this.vertexShader = h, this.fragmentShader = i, this
        }

        function Ma(a, b) {
            function c(a, b) {
                var c;
                return a ? a && a.isTexture ? c = a.encoding : a && a.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), c = a.texture.encoding) : c = 3e3, 3e3 === c && b && (c = 3007), c
            }
            var d = [],
                e = {
                    MeshDepthMaterial: "depth",
                    MeshNormalMaterial: "normal",
                    MeshBasicMaterial: "basic",
                    MeshLambertMaterial: "lambert",
                    MeshPhongMaterial: "phong",
                    MeshStandardMaterial: "physical",
                    MeshPhysicalMaterial: "physical",
                    LineBasicMaterial: "basic",
                    LineDashedMaterial: "dashed",
                    PointsMaterial: "points"
                },
                f = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes depthPacking".split(" ");
            this.getParameters = function(d, f, g, h, i) {
                var j, k = e[d.type];
                b.floatVertexTextures && i && i.skeleton && i.skeleton.useVertexTexture ? j = 1024 : (j = Math.floor((b.maxVertexUniforms - 20) / 4), void 0 !== i && i && i.isSkinnedMesh && (j = Math.min(i.skeleton.bones.length, j), j < i.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + i.skeleton.bones.length + ", this GPU supports just " + j + " (try OpenGL instead of ANGLE)")));
                var l = a.getPrecision();
                null !== d.precision && (l = b.getMaxPrecision(d.precision), l !== d.precision && console.warn("THREE.WebGLProgram.getParameters:", d.precision, "not supported, using", l, "instead."));
                var m = a.getCurrentRenderTarget();
                return {
                    shaderID: k,
                    precision: l,
                    supportsVertexTextures: b.vertexTextures,
                    outputEncoding: c(m ? m.texture : null, a.gammaOutput),
                    map: !!d.map,
                    mapEncoding: c(d.map, a.gammaInput),
                    envMap: !!d.envMap,
                    envMapMode: d.envMap && d.envMap.mapping,
                    envMapEncoding: c(d.envMap, a.gammaInput),
                    envMapCubeUV: !!d.envMap && (306 === d.envMap.mapping || 307 === d.envMap.mapping),
                    lightMap: !!d.lightMap,
                    aoMap: !!d.aoMap,
                    emissiveMap: !!d.emissiveMap,
                    emissiveMapEncoding: c(d.emissiveMap, a.gammaInput),
                    bumpMap: !!d.bumpMap,
                    normalMap: !!d.normalMap,
                    displacementMap: !!d.displacementMap,
                    roughnessMap: !!d.roughnessMap,
                    metalnessMap: !!d.metalnessMap,
                    specularMap: !!d.specularMap,
                    alphaMap: !!d.alphaMap,
                    combine: d.combine,
                    vertexColors: d.vertexColors,
                    fog: !!g,
                    useFog: d.fog,
                    fogExp: g && g.isFogExp2,
                    flatShading: 1 === d.shading,
                    sizeAttenuation: d.sizeAttenuation,
                    logarithmicDepthBuffer: b.logarithmicDepthBuffer,
                    skinning: d.skinning,
                    maxBones: j,
                    useVertexTexture: b.floatVertexTextures && i && i.skeleton && i.skeleton.useVertexTexture,
                    morphTargets: d.morphTargets,
                    morphNormals: d.morphNormals,
                    maxMorphTargets: a.maxMorphTargets,
                    maxMorphNormals: a.maxMorphNormals,
                    numDirLights: f.directional.length,
                    numPointLights: f.point.length,
                    numSpotLights: f.spot.length,
                    numHemiLights: f.hemi.length,
                    numClippingPlanes: h,
                    shadowMapEnabled: a.shadowMap.enabled && i.receiveShadow && 0 < f.shadows.length,
                    shadowMapType: a.shadowMap.type,
                    toneMapping: a.toneMapping,
                    physicallyCorrectLights: a.physicallyCorrectLights,
                    premultipliedAlpha: d.premultipliedAlpha,
                    alphaTest: d.alphaTest,
                    doubleSided: 2 === d.side,
                    flipSided: 1 === d.side,
                    depthPacking: void 0 !== d.depthPacking && d.depthPacking
                }
            }, this.getProgramCode = function(a, b) {
                var c = [];
                if (b.shaderID ? c.push(b.shaderID) : (c.push(a.fragmentShader), c.push(a.vertexShader)), void 0 !== a.defines)
                    for (var d in a.defines) c.push(d), c.push(a.defines[d]);
                for (d = 0; d < f.length; d++) c.push(b[f[d]]);
                return c.join()
            }, this.acquireProgram = function(b, c, e) {
                for (var f, g = 0, h = d.length; g < h; g++) {
                    var i = d[g];
                    if (i.code === e) {
                        f = i, ++f.usedTimes;
                        break
                    }
                }
                return void 0 === f && (f = new La(a, e, b, c), d.push(f)), f
            }, this.releaseProgram = function(a) {
                if (0 === --a.usedTimes) {
                    var b = d.indexOf(a);
                    d[b] = d[d.length - 1], d.pop(), a.destroy()
                }
            }, this.programs = d
        }

        function Na(a, b, c) {
            function d(a) {
                var g = a.target;
                a = f[g.id], null !== a.index && e(a.index);
                var h, i = a.attributes;
                for (h in i) e(i[h]);
                g.removeEventListener("dispose", d), delete f[g.id], h = b.get(g), h.wireframe && e(h.wireframe), b.delete(g), g = b.get(a), g.wireframe && e(g.wireframe), b.delete(a), c.memory.geometries--
            }

            function e(c) {
                var d;
                d = c.isInterleavedBufferAttribute ? b.get(c.data).__webglBuffer : b.get(c).__webglBuffer, void 0 !== d && (a.deleteBuffer(d), c.isInterleavedBufferAttribute ? b.delete(c.data) : b.delete(c))
            }
            var f = {};
            return {
                get: function(a) {
                    var b = a.geometry;
                    if (void 0 !== f[b.id]) return f[b.id];
                    b.addEventListener("dispose", d);
                    var e;
                    return b.isBufferGeometry ? e = b : b.isGeometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new pa).setFromObject(a)), e = b._bufferGeometry), f[b.id] = e, c.memory.geometries++, e
                }
            }
        }

        function Oa(a, b, c) {
            function d(c, d) {
                var e = c.isInterleavedBufferAttribute ? c.data : c,
                    f = b.get(e);
                void 0 === f.__webglBuffer ? (f.__webglBuffer = a.createBuffer(), a.bindBuffer(d, f.__webglBuffer), a.bufferData(d, e.array, e.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW), f.version = e.version) : f.version !== e.version && (a.bindBuffer(d, f.__webglBuffer), !1 === e.dynamic || -1 === e.updateRange.count ? a.bufferSubData(d, 0, e.array) : 0 === e.updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (a.bufferSubData(d, e.updateRange.offset * e.array.BYTES_PER_ELEMENT, e.array.subarray(e.updateRange.offset, e.updateRange.offset + e.updateRange.count)), e.updateRange.count = 0), f.version = e.version)
            }
            var e = new Na(a, b, c);
            return {
                getAttributeBuffer: function(a) {
                    return a.isInterleavedBufferAttribute ? b.get(a.data).__webglBuffer : b.get(a).__webglBuffer
                },
                getWireframeAttribute: function(c) {
                    var e = b.get(c);
                    if (void 0 !== e.wireframe) return e.wireframe;
                    var f = [],
                        g = c.index,
                        h = c.attributes;
                    if (c = h.position, null !== g)
                        for (var g = g.array, h = 0, i = g.length; h < i; h += 3) {
                            var j = g[h + 0],
                                k = g[h + 1],
                                l = g[h + 2];
                            f.push(j, k, k, l, l, j)
                        } else
                            for (g = h.position.array, h = 0, i = g.length / 3 - 1; h < i; h += 3) j = h + 0, k = h + 1, l = h + 2, f.push(j, k, k, l, l, j);
                    return f = new ja(new(65535 < c.count ? Uint32Array : Uint16Array)(f), 1), d(f, a.ELEMENT_ARRAY_BUFFER), e.wireframe = f
                },
                update: function(b) {
                    var c = e.get(b);
                    b.geometry.isGeometry && c.updateFromObject(b), b = c.index;
                    var f = c.attributes;
                    null !== b && d(b, a.ELEMENT_ARRAY_BUFFER);
                    for (var g in f) d(f[g], a.ARRAY_BUFFER);
                    b = c.morphAttributes;
                    for (g in b)
                        for (var f = b[g], h = 0, i = f.length; h < i; h++) d(f[h], a.ARRAY_BUFFER);
                    return c
                }
            }
        }

        function Pa(b, c, d, e, f, g, h) {
            function i(a, b) {
                if (a.width > b || a.height > b) {
                    var c = b / Math.max(a.width, a.height),
                        d = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                    return d.width = Math.floor(a.width * c), d.height = Math.floor(a.height * c), d.getContext("2d").drawImage(a, 0, 0, a.width, a.height, 0, 0, d.width, d.height), console.warn("THREE.WebGLRenderer: image is too big (" + a.width + "x" + a.height + "). Resized to " + d.width + "x" + d.height, a), d
                }
                return a
            }

            function j(b) {
                return a.Math.isPowerOfTwo(b.width) && a.Math.isPowerOfTwo(b.height)
            }

            function k(a) {
                return 1003 === a || 1004 === a || 1005 === a ? b.NEAREST : b.LINEAR
            }

            function l(a) {
                a = a.target, a.removeEventListener("dispose", l);
                a: {
                    var c = e.get(a);
                    if (a.image && c.__image__webglTextureCube) b.deleteTexture(c.__image__webglTextureCube);
                    else {
                        if (void 0 === c.__webglInit) break a;
                        b.deleteTexture(c.__webglTexture)
                    }
                    e.delete(a)
                }
                r.textures--
            }

            function m(a) {
                a = a.target, a.removeEventListener("dispose", m);
                var c = e.get(a),
                    d = e.get(a.texture);
                if (a) {
                    if (void 0 !== d.__webglTexture && b.deleteTexture(d.__webglTexture), a.depthTexture && a.depthTexture.dispose(), a && a.isWebGLRenderTargetCube)
                        for (d = 0; 6 > d; d++) b.deleteFramebuffer(c.__webglFramebuffer[d]), c.__webglDepthbuffer && b.deleteRenderbuffer(c.__webglDepthbuffer[d]);
                    else b.deleteFramebuffer(c.__webglFramebuffer), c.__webglDepthbuffer && b.deleteRenderbuffer(c.__webglDepthbuffer);
                    e.delete(a.texture), e.delete(a)
                }
                r.textures--
            }

            function n(c, h) {
                var k = e.get(c);
                if (0 < c.version && k.__version !== c.version) {
                    var m = c.image;
                    if (void 0 === m) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", c);
                    else {
                        if (!1 !== m.complete) {
                            void 0 === k.__webglInit && (k.__webglInit = !0, c.addEventListener("dispose", l), k.__webglTexture = b.createTexture(), r.textures++), d.activeTexture(b.TEXTURE0 + h), d.bindTexture(b.TEXTURE_2D, k.__webglTexture), b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, c.flipY), b.pixelStorei(b.UNPACK_PREMULTIPLY_ALPHA_WEBGL, c.premultiplyAlpha), b.pixelStorei(b.UNPACK_ALIGNMENT, c.unpackAlignment);
                            var n = i(c.image, f.maxTextureSize);
                            if ((1001 !== c.wrapS || 1001 !== c.wrapT || 1003 !== c.minFilter && 1006 !== c.minFilter) && !1 === j(n))
                                if (m = n, m instanceof HTMLImageElement || m instanceof HTMLCanvasElement) {
                                    var p = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
                                    p.width = a.Math.nearestPowerOfTwo(m.width), p.height = a.Math.nearestPowerOfTwo(m.height), p.getContext("2d").drawImage(m, 0, 0, p.width, p.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + m.width + "x" + m.height + "). Resized to " + p.width + "x" + p.height, m), n = p
                                } else n = m;
                            var m = j(n),
                                p = g(c.format),
                                q = g(c.type);
                            o(b.TEXTURE_2D, c, m);
                            var t = c.mipmaps;
                            if (c && c.isDepthTexture) {
                                if (t = b.DEPTH_COMPONENT, 1015 === c.type) {
                                    if (!s) throw Error("Float Depth Texture only supported in WebGL2.0");
                                    t = b.DEPTH_COMPONENT32F
                                } else s && (t = b.DEPTH_COMPONENT16);
                                1027 === c.format && (t = b.DEPTH_STENCIL), d.texImage2D(b.TEXTURE_2D, 0, t, n.width, n.height, 0, p, q, null)
                            } else if (c && c.isDataTexture)
                                if (0 < t.length && m) {
                                    for (var u = 0, v = t.length; u < v; u++) n = t[u], d.texImage2D(b.TEXTURE_2D, u, p, n.width, n.height, 0, p, q, n.data);
                                    c.generateMipmaps = !1
                                } else d.texImage2D(b.TEXTURE_2D, 0, p, n.width, n.height, 0, p, q, n.data);
                            else if (c && c.isCompressedTexture)
                                for (u = 0, v = t.length; u < v; u++) n = t[u], 1023 !== c.format && 1022 !== c.format ? -1 < d.getCompressedTextureFormats().indexOf(p) ? d.compressedTexImage2D(b.TEXTURE_2D, u, p, n.width, n.height, 0, n.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : d.texImage2D(b.TEXTURE_2D, u, p, n.width, n.height, 0, p, q, n.data);
                            else if (0 < t.length && m) {
                                for (u = 0, v = t.length; u < v; u++) n = t[u], d.texImage2D(b.TEXTURE_2D, u, p, p, q, n);
                                c.generateMipmaps = !1
                            } else d.texImage2D(b.TEXTURE_2D, 0, p, p, q, n);
                            return c.generateMipmaps && m && b.generateMipmap(b.TEXTURE_2D), k.__version = c.version, void(c.onUpdate && c.onUpdate(c))
                        }
                        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", c)
                    }
                }
                d.activeTexture(b.TEXTURE0 + h), d.bindTexture(b.TEXTURE_2D, k.__webglTexture)
            }

            function o(a, d, h) {
                h ? (b.texParameteri(a, b.TEXTURE_WRAP_S, g(d.wrapS)), b.texParameteri(a, b.TEXTURE_WRAP_T, g(d.wrapT)), b.texParameteri(a, b.TEXTURE_MAG_FILTER, g(d.magFilter)), b.texParameteri(a, b.TEXTURE_MIN_FILTER, g(d.minFilter))) : (b.texParameteri(a, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(a, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE), 1001 === d.wrapS && 1001 === d.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", d), b.texParameteri(a, b.TEXTURE_MAG_FILTER, k(d.magFilter)), b.texParameteri(a, b.TEXTURE_MIN_FILTER, k(d.minFilter)), 1003 !== d.minFilter && 1006 !== d.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", d)), !(h = c.get("EXT_texture_filter_anisotropic")) || 1015 === d.type && null === c.get("OES_texture_float_linear") || 1016 === d.type && null === c.get("OES_texture_half_float_linear") || !(1 < d.anisotropy || e.get(d).__currentAnisotropy) || (b.texParameterf(a, h.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(d.anisotropy, f.getMaxAnisotropy())), e.get(d).__currentAnisotropy = d.anisotropy)
            }

            function p(a, c, f, h) {
                var i = g(c.texture.format),
                    j = g(c.texture.type);
                d.texImage2D(h, 0, i, c.width, c.height, 0, i, j, null), b.bindFramebuffer(b.FRAMEBUFFER, a), b.framebufferTexture2D(b.FRAMEBUFFER, f, h, e.get(c.texture).__webglTexture, 0), b.bindFramebuffer(b.FRAMEBUFFER, null)
            }

            function q(a, c) {
                b.bindRenderbuffer(b.RENDERBUFFER, a), c.depthBuffer && !c.stencilBuffer ? (b.renderbufferStorage(b.RENDERBUFFER, b.DEPTH_COMPONENT16, c.width, c.height), b.framebufferRenderbuffer(b.FRAMEBUFFER, b.DEPTH_ATTACHMENT, b.RENDERBUFFER, a)) : c.depthBuffer && c.stencilBuffer ? (b.renderbufferStorage(b.RENDERBUFFER, b.DEPTH_STENCIL, c.width, c.height), b.framebufferRenderbuffer(b.FRAMEBUFFER, b.DEPTH_STENCIL_ATTACHMENT, b.RENDERBUFFER, a)) : b.renderbufferStorage(b.RENDERBUFFER, b.RGBA4, c.width, c.height), b.bindRenderbuffer(b.RENDERBUFFER, null)
            }
            var r = h.memory,
                s = "undefined" != typeof WebGL2RenderingContext && b instanceof WebGL2RenderingContext;
            this.setTexture2D = n, this.setTextureCube = function(a, c) {
                var h = e.get(a);
                if (6 === a.image.length)
                    if (0 < a.version && h.__version !== a.version) {
                        h.__image__webglTextureCube || (a.addEventListener("dispose", l), h.__image__webglTextureCube = b.createTexture(), r.textures++), d.activeTexture(b.TEXTURE0 + c), d.bindTexture(b.TEXTURE_CUBE_MAP, h.__image__webglTextureCube), b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, a.flipY);
                        for (var k = a && a.isCompressedTexture, m = a.image[0] && a.image[0].isDataTexture, n = [], p = 0; 6 > p; p++) n[p] = k || m ? m ? a.image[p].image : a.image[p] : i(a.image[p], f.maxCubemapSize);
                        var q = j(n[0]),
                            s = g(a.format),
                            t = g(a.type);
                        for (o(b.TEXTURE_CUBE_MAP, a, q), p = 0; 6 > p; p++)
                            if (k)
                                for (var u, v = n[p].mipmaps, w = 0, x = v.length; w < x; w++) u = v[w], 1023 !== a.format && 1022 !== a.format ? -1 < d.getCompressedTextureFormats().indexOf(s) ? d.compressedTexImage2D(b.TEXTURE_CUBE_MAP_POSITIVE_X + p, w, s, u.width, u.height, 0, u.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : d.texImage2D(b.TEXTURE_CUBE_MAP_POSITIVE_X + p, w, s, u.width, u.height, 0, s, t, u.data);
                            else m ? d.texImage2D(b.TEXTURE_CUBE_MAP_POSITIVE_X + p, 0, s, n[p].width, n[p].height, 0, s, t, n[p].data) : d.texImage2D(b.TEXTURE_CUBE_MAP_POSITIVE_X + p, 0, s, s, t, n[p]);
                        a.generateMipmaps && q && b.generateMipmap(b.TEXTURE_CUBE_MAP), h.__version = a.version, a.onUpdate && a.onUpdate(a)
                    } else d.activeTexture(b.TEXTURE0 + c), d.bindTexture(b.TEXTURE_CUBE_MAP, h.__image__webglTextureCube)
            }, this.setTextureCubeDynamic = function(a, c) {
                d.activeTexture(b.TEXTURE0 + c), d.bindTexture(b.TEXTURE_CUBE_MAP, e.get(a).__webglTexture)
            }, this.setupRenderTarget = function(a) {
                var c = e.get(a),
                    f = e.get(a.texture);
                a.addEventListener("dispose", m), f.__webglTexture = b.createTexture(), r.textures++;
                var g = a && a.isWebGLRenderTargetCube,
                    h = j(a);
                if (g) {
                    c.__webglFramebuffer = [];
                    for (var i = 0; 6 > i; i++) c.__webglFramebuffer[i] = b.createFramebuffer()
                } else c.__webglFramebuffer = b.createFramebuffer();
                if (g) {
                    for (d.bindTexture(b.TEXTURE_CUBE_MAP, f.__webglTexture), o(b.TEXTURE_CUBE_MAP, a.texture, h), i = 0; 6 > i; i++) p(c.__webglFramebuffer[i], a, b.COLOR_ATTACHMENT0, b.TEXTURE_CUBE_MAP_POSITIVE_X + i);
                    a.texture.generateMipmaps && h && b.generateMipmap(b.TEXTURE_CUBE_MAP), d.bindTexture(b.TEXTURE_CUBE_MAP, null)
                } else d.bindTexture(b.TEXTURE_2D, f.__webglTexture), o(b.TEXTURE_2D, a.texture, h), p(c.__webglFramebuffer, a, b.COLOR_ATTACHMENT0, b.TEXTURE_2D), a.texture.generateMipmaps && h && b.generateMipmap(b.TEXTURE_2D), d.bindTexture(b.TEXTURE_2D, null);
                if (a.depthBuffer) {
                    if (c = e.get(a), f = a && a.isWebGLRenderTargetCube, a.depthTexture) {
                        if (f) throw Error("target.depthTexture not supported in Cube render targets");
                        if (a && a.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported!");
                        if (b.bindFramebuffer(b.FRAMEBUFFER, c.__webglFramebuffer), !a.depthTexture || !a.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                        if (e.get(a.depthTexture).__webglTexture && a.depthTexture.image.width === a.width && a.depthTexture.image.height === a.height || (a.depthTexture.image.width = a.width, a.depthTexture.image.height = a.height, a.depthTexture.needsUpdate = !0), n(a.depthTexture, 0), c = e.get(a.depthTexture).__webglTexture, 1026 === a.depthTexture.format) b.framebufferTexture2D(b.FRAMEBUFFER, b.DEPTH_ATTACHMENT, b.TEXTURE_2D, c, 0);
                        else {
                            if (1027 !== a.depthTexture.format) throw Error("Unknown depthTexture format");
                            b.framebufferTexture2D(b.FRAMEBUFFER, b.DEPTH_STENCIL_ATTACHMENT, b.TEXTURE_2D, c, 0)
                        }
                    } else if (f)
                        for (c.__webglDepthbuffer = [], f = 0; 6 > f; f++) b.bindFramebuffer(b.FRAMEBUFFER, c.__webglFramebuffer[f]), c.__webglDepthbuffer[f] = b.createRenderbuffer(), q(c.__webglDepthbuffer[f], a);
                    else b.bindFramebuffer(b.FRAMEBUFFER, c.__webglFramebuffer), c.__webglDepthbuffer = b.createRenderbuffer(), q(c.__webglDepthbuffer, a);
                    b.bindFramebuffer(b.FRAMEBUFFER, null)
                }
            }, this.updateRenderTargetMipmap = function(a) {
                var c = a.texture;
                c.generateMipmaps && j(a) && 1003 !== c.minFilter && 1006 !== c.minFilter && (a = a && a.isWebGLRenderTargetCube ? b.TEXTURE_CUBE_MAP : b.TEXTURE_2D, c = e.get(c).__webglTexture, d.bindTexture(a, c), b.generateMipmap(a), d.bindTexture(a, null))
            }
        }

        function Qa() {
            var a = {};
            return {
                get: function(b) {
                    b = b.uuid;
                    var c = a[b];
                    return void 0 === c && (c = {}, a[b] = c), c
                },
                delete: function(b) {
                    delete a[b.uuid]
                },
                clear: function() {
                    a = {}
                }
            }
        }

        function Ra(a, b, c) {
            function d(b, c, d) {
                var e = new Uint8Array(4),
                    f = a.createTexture();
                for (a.bindTexture(b, f), a.texParameteri(b, a.TEXTURE_MIN_FILTER, a.NEAREST), a.texParameteri(b, a.TEXTURE_MAG_FILTER, a.NEAREST), b = 0; b < d; b++) a.texImage2D(c + b, 0, a.RGBA, 1, 1, 0, a.RGBA, a.UNSIGNED_BYTE, e);
                return f
            }

            function f(b) {
                !0 !== w[b] && (a.enable(b), w[b] = !0)
            }

            function g(b) {
                !1 !== w[b] && (a.disable(b), w[b] = !1)
            }

            function h(b, d, e, h, i, j, k, l) {
                0 !== b ? (f(a.BLEND), b === y && l === F || (2 === b ? l ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE, a.ONE, a.ONE)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.SRC_ALPHA, a.ONE)) : 3 === b ? l ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR)) : 4 === b ? l ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.SRC_COLOR, a.ZERO, a.SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.SRC_COLOR)) : l ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)), y = b, F = l), 5 === b ? (i = i || d, j = j || e, k = k || h, d === z && i === C || (a.blendEquationSeparate(c(d), c(i)), z = d, C = i), e === A && h === B && j === D && k === E || (a.blendFuncSeparate(c(e), c(h), c(j), c(k)), A = e, B = h, D = j, E = k)) : E = D = C = B = A = z = null) : (g(a.BLEND), y = b)
            }

            function i(a) {
                q.setFunc(a)
            }

            function j(b) {
                G !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), G = b)
            }

            function k(b) {
                0 !== b ? (f(a.CULL_FACE), b !== H && (1 === b ? a.cullFace(a.BACK) : 2 === b ? a.cullFace(a.FRONT) : a.cullFace(a.FRONT_AND_BACK))) : g(a.CULL_FACE), H = b
            }

            function l(b) {
                void 0 === b && (b = a.TEXTURE0 + M - 1), N !== b && (a.activeTexture(b), N = b)
            }

            function m(a, b, c, d) {
                p.setClear(a, b, c, d)
            }

            function n(a) {
                q.setClear(a)
            }

            function o(a) {
                r.setClear(a)
            }
            var p = new function() {
                    var b = !1,
                        c = new e,
                        d = null,
                        f = new e;
                    return {
                        setMask: function(c) {
                            d === c || b || (a.colorMask(c, c, c, c), d = c)
                        },
                        setLocked: function(a) {
                            b = a
                        },
                        setClear: function(b, d, e, g) {
                            c.set(b, d, e, g), !1 === f.equals(c) && (a.clearColor(b, d, e, g), f.copy(c))
                        },
                        reset: function() {
                            b = !1, d = null, f.set(0, 0, 0, 1)
                        }
                    }
                },
                q = new function() {
                    var b = !1,
                        c = null,
                        d = null,
                        e = null;
                    return {
                        setTest: function(b) {
                            b ? f(a.DEPTH_TEST) : g(a.DEPTH_TEST)
                        },
                        setMask: function(d) {
                            c === d || b || (a.depthMask(d), c = d)
                        },
                        setFunc: function(b) {
                            if (d !== b) {
                                if (b) switch (b) {
                                    case 0:
                                        a.depthFunc(a.NEVER);
                                        break;
                                    case 1:
                                        a.depthFunc(a.ALWAYS);
                                        break;
                                    case 2:
                                        a.depthFunc(a.LESS);
                                        break;
                                    case 3:
                                        a.depthFunc(a.LEQUAL);
                                        break;
                                    case 4:
                                        a.depthFunc(a.EQUAL);
                                        break;
                                    case 5:
                                        a.depthFunc(a.GEQUAL);
                                        break;
                                    case 6:
                                        a.depthFunc(a.GREATER);
                                        break;
                                    case 7:
                                        a.depthFunc(a.NOTEQUAL);
                                        break;
                                    default:
                                        a.depthFunc(a.LEQUAL)
                                } else a.depthFunc(a.LEQUAL);
                                d = b
                            }
                        },
                        setLocked: function(a) {
                            b = a
                        },
                        setClear: function(b) {
                            e !== b && (a.clearDepth(b), e = b)
                        },
                        reset: function() {
                            b = !1, e = d = c = null
                        }
                    }
                },
                r = new function() {
                    var b = !1,
                        c = null,
                        d = null,
                        e = null,
                        h = null,
                        i = null,
                        j = null,
                        k = null,
                        l = null;
                    return {
                        setTest: function(b) {
                            b ? f(a.STENCIL_TEST) : g(a.STENCIL_TEST)
                        },
                        setMask: function(d) {
                            c === d || b || (a.stencilMask(d), c = d)
                        },
                        setFunc: function(b, c, f) {
                            d === b && e === c && h === f || (a.stencilFunc(b, c, f), d = b, e = c, h = f)
                        },
                        setOp: function(b, c, d) {
                            i === b && j === c && k === d || (a.stencilOp(b, c, d), i = b, j = c, k = d)
                        },
                        setLocked: function(a) {
                            b = a
                        },
                        setClear: function(b) {
                            l !== b && (a.clearStencil(b), l = b)
                        },
                        reset: function() {
                            b = !1, l = k = j = i = h = e = d = c = null
                        }
                    }
                },
                s = a.getParameter(a.MAX_VERTEX_ATTRIBS),
                t = new Uint8Array(s),
                u = new Uint8Array(s),
                v = new Uint8Array(s),
                w = {},
                x = null,
                y = null,
                z = null,
                A = null,
                B = null,
                C = null,
                D = null,
                E = null,
                F = !1,
                G = null,
                H = null,
                I = null,
                J = null,
                K = null,
                L = null,
                M = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),
                N = null,
                O = {},
                P = new e,
                Q = new e,
                R = {};
            return R[a.TEXTURE_2D] = d(a.TEXTURE_2D, a.TEXTURE_2D, 1), R[a.TEXTURE_CUBE_MAP] = d(a.TEXTURE_CUBE_MAP, a.TEXTURE_CUBE_MAP_POSITIVE_X, 6), {
                buffers: {
                    color: p,
                    depth: q,
                    stencil: r
                },
                init: function() {
                    m(0, 0, 0, 1), n(1), o(0), f(a.DEPTH_TEST), i(3), j(!1), k(1), f(a.CULL_FACE), f(a.BLEND), h(1)
                },
                initAttributes: function() {
                    for (var a = 0, b = t.length; a < b; a++) t[a] = 0
                },
                enableAttribute: function(c) {
                    t[c] = 1, 0 === u[c] && (a.enableVertexAttribArray(c), u[c] = 1), 0 !== v[c] && (b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c, 0), v[c] = 0)
                },
                enableAttributeAndDivisor: function(b, c, d) {
                    t[b] = 1, 0 === u[b] && (a.enableVertexAttribArray(b), u[b] = 1), v[b] !== c && (d.vertexAttribDivisorANGLE(b, c), v[b] = c)
                },
                disableUnusedAttributes: function() {
                    for (var b = 0, c = u.length; b !== c; ++b) u[b] !== t[b] && (a.disableVertexAttribArray(b), u[b] = 0)
                },
                enable: f,
                disable: g,
                getCompressedTextureFormats: function() {
                    if (null === x && (x = [], b.get("WEBGL_compressed_texture_pvrtc") || b.get("WEBGL_compressed_texture_s3tc") || b.get("WEBGL_compressed_texture_etc1")))
                        for (var c = a.getParameter(a.COMPRESSED_TEXTURE_FORMATS), d = 0; d < c.length; d++) x.push(c[d]);
                    return x
                },
                setBlending: h,
                setColorWrite: function(a) {
                    p.setMask(a)
                },
                setDepthTest: function(a) {
                    q.setTest(a)
                },
                setDepthWrite: function(a) {
                    q.setMask(a)
                },
                setDepthFunc: i,
                setStencilTest: function(a) {
                    r.setTest(a)
                },
                setStencilWrite: function(a) {
                    r.setMask(a)
                },
                setStencilFunc: function(a, b, c) {
                    r.setFunc(a, b, c)
                },
                setStencilOp: function(a, b, c) {
                    r.setOp(a, b, c)
                },
                setFlipSided: j,
                setCullFace: k,
                setLineWidth: function(b) {
                    b !== I && (a.lineWidth(b), I = b)
                },
                setPolygonOffset: function(b, c, d) {
                    b ? (f(a.POLYGON_OFFSET_FILL), (J !== c || K !== d) && (a.polygonOffset(c, d), J = c, K = d)) : g(a.POLYGON_OFFSET_FILL)
                },
                getScissorTest: function() {
                    return L
                },
                setScissorTest: function(b) {
                    (L = b) ? f(a.SCISSOR_TEST): g(a.SCISSOR_TEST)
                },
                activeTexture: l,
                bindTexture: function(b, c) {
                    null === N && l();
                    var d = O[N];
                    void 0 === d && (d = {
                        type: void 0,
                        texture: void 0
                    }, O[N] = d), d.type === b && d.texture === c || (a.bindTexture(b, c || R[b]), d.type = b, d.texture = c)
                },
                compressedTexImage2D: function() {
                    try {
                        a.compressedTexImage2D.apply(a, arguments)
                    } catch (a) {
                        console.error(a)
                    }
                },
                texImage2D: function() {
                    try {
                        a.texImage2D.apply(a, arguments)
                    } catch (a) {
                        console.error(a)
                    }
                },
                clearColor: m,
                clearDepth: n,
                clearStencil: o,
                scissor: function(b) {
                    !1 === P.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), P.copy(b))
                },
                viewport: function(b) {
                    !1 === Q.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), Q.copy(b))
                },
                reset: function() {
                    for (var b = 0; b < u.length; b++) 1 === u[b] && (a.disableVertexAttribArray(b), u[b] = 0);
                    w = {}, N = x = null, O = {}, H = G = y = null, p.reset(), q.reset(), r.reset()
                }
            }
        }

        function Sa(a, b, c) {
            function d(b) {
                if ("highp" === b) {
                    if (0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision) return "highp";
                    b = "mediump"
                }
                return "mediump" === b && 0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT).precision ? "mediump" : "lowp"
            }
            var e, f = void 0 !== c.precision ? c.precision : "highp",
                g = d(f);
            g !== f && (console.warn("THREE.WebGLRenderer:", f, "not supported, using", g, "instead."), f = g), c = !0 === c.logarithmicDepthBuffer && !!b.get("EXT_frag_depth");
            var g = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),
                h = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                i = a.getParameter(a.MAX_TEXTURE_SIZE),
                j = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE),
                k = a.getParameter(a.MAX_VERTEX_ATTRIBS),
                l = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS),
                m = a.getParameter(a.MAX_VARYING_VECTORS),
                n = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS),
                o = 0 < h,
                p = !!b.get("OES_texture_float");
            return {
                getMaxAnisotropy: function() {
                    if (void 0 !== e) return e;
                    var c = b.get("EXT_texture_filter_anisotropic");
                    return e = null !== c ? a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                },
                getMaxPrecision: d,
                precision: f,
                logarithmicDepthBuffer: c,
                maxTextures: g,
                maxVertexTextures: h,
                maxTextureSize: i,
                maxCubemapSize: j,
                maxAttributes: k,
                maxVertexUniforms: l,
                maxVaryings: m,
                maxFragmentUniforms: n,
                vertexTextures: o,
                floatFragmentTextures: p,
                floatVertexTextures: o && p
            }
        }

        function Ta(a) {
            var b = {};
            return {
                get: function(c) {
                    if (void 0 !== b[c]) return b[c];
                    var d;
                    switch (c) {
                        case "WEBGL_depth_texture":
                            d = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            d = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        case "WEBGL_compressed_texture_etc1":
                            d = a.getExtension("WEBGL_compressed_texture_etc1");
                            break;
                        default:
                            d = a.getExtension(c)
                    }
                    return null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported."), b[c] = d
                }
            }
        }

        function Ua() {
            function a() {
                j.value !== d && (j.value = d, j.needsUpdate = 0 < e), c.numPlanes = e
            }

            function b(a, b, d, e) {
                var f = null !== a ? a.length : 0,
                    g = null;
                if (0 !== f) {
                    if (g = j.value, !0 !== e || null === g)
                        for (e = d + 4 * f, b = b.matrixWorldInverse, i.getNormalMatrix(b), (null === g || g.length < e) && (g = new Float32Array(e)), e = 0; e !== f; ++e, d += 4) h.copy(a[e]).applyMatrix4(b, i), h.normal.toArray(g, d), g[d + 3] = h.constant;
                    j.value = g, j.needsUpdate = !0
                }
                return c.numPlanes = f, g
            }
            var c = this,
                d = null,
                e = 0,
                f = !1,
                g = !1,
                h = new $,
                i = new Z,
                j = {
                    value: null,
                    needsUpdate: !1
                };
            this.uniform = j, this.numPlanes = 0, this.init = function(a, c, g) {
                var h = 0 !== a.length || c || 0 !== e || f;
                return f = c, d = b(a, g, 0), e = a.length, h
            }, this.beginShadows = function() {
                g = !0, b(null)
            }, this.endShadows = function() {
                g = !1, a()
            }, this.setState = function(c, h, i, k, l) {
                if (!f || null === c || 0 === c.length || g && !h) g ? b(null) : a();
                else {
                    h = g ? 0 : e;
                    var m = 4 * h,
                        n = k.clippingState || null;
                    for (j.value = n, n = b(c, i, m, l), c = 0; c !== m; ++c) n[c] = d[c];
                    k.clippingState = n, this.numPlanes += h
                }
            }
        }

        function Va(b) {
            function c(a, b, c, d) {
                !0 === C && (a *= d, b *= d, c *= d), Ha.clearColor(a, b, c, d)
            }

            function d() {
                Ha.init(), Ha.scissor(Z.copy(ja).multiplyScalar(ha)), Ha.viewport(ba.copy(la).multiplyScalar(ha)), c(da.r, da.g, da.b, ea)
            }

            function f() {
                X = N = null, W = "", U = -1, Ha.reset()
            }

            function g(a) {
                a.preventDefault(), f(), d(), Ia.clear()
            }

            function h(a) {
                a = a.target, a.removeEventListener("dispose", h), k(a), Ia.delete(a)
            }

            function k(a) {
                var b = Ia.get(a).program;
                a.program = void 0, void 0 !== b && La.releaseProgram(b)
            }

            function l(a, b) {
                return Math.abs(b[0]) - Math.abs(a[0])
            }

            function m(a, b) {
                return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.material.program && b.material.program && a.material.program !== b.material.program ? a.material.program.id - b.material.program.id : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
            }

            function n(a, b) {
                return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
            }

            function o(a, b, c, d, e) {
                var f;
                c.transparent ? (d = H, f = ++I) : (d = F, f = ++G), f = d[f], void 0 !== f ? (f.id = a.id, f.object = a, f.geometry = b, f.material = c, f.z = Ba.z, f.group = e) : (f = {
                    id: a.id,
                    object: a,
                    geometry: b,
                    material: c,
                    z: Ba.z,
                    group: e
                }, d.push(f))
            }

            function p(a) {
                if (!ma.intersectsSphere(a)) return !1;
                var b = na.numPlanes;
                if (0 === b) return !0;
                var c = M.clippingPlanes,
                    d = a.center;
                a = -a.radius;
                var e = 0;
                do
                    if (c[e].distanceToPoint(d) < a) return !1; while (++e !== b);
                return !0
            }

            function q(a, b) {
                if (!1 !== a.visible) {
                    if (0 !== (a.layers.mask & b.layers.mask))
                        if (a.isLight) E.push(a);
                        else if (a.isSprite) {
                        var c;
                        (c = !1 === a.frustumCulled) || (za.center.set(0, 0, 0), za.radius = .7071067811865476, za.applyMatrix4(a.matrixWorld), c = !0 === p(za)), c && K.push(a)
                    } else if (a.isLensFlare) L.push(a);
                    else if (a.isImmediateRenderObject) !0 === M.sortObjects && (Ba.setFromMatrixPosition(a.matrixWorld), Ba.applyProjection(Aa)), o(a, null, a.material, Ba.z, null);
                    else if ((a.isMesh || a.isLine || a.isPoints) && (a.isSkinnedMesh && a.skeleton.update(), (c = !1 === a.frustumCulled) || (c = a.geometry, null === c.boundingSphere && c.computeBoundingSphere(), za.copy(c.boundingSphere).applyMatrix4(a.matrixWorld), c = !0 === p(za)), c)) {
                        var d = a.material;
                        if (!0 === d.visible)
                            if (!0 === M.sortObjects && (Ba.setFromMatrixPosition(a.matrixWorld), Ba.applyProjection(Aa)), c = Ka.update(a), d.isMultiMaterial)
                                for (var e = c.groups, f = d.materials, d = 0, g = e.length; d < g; d++) {
                                    var h = e[d],
                                        i = f[h.materialIndex];
                                    !0 === i.visible && o(a, c, i, Ba.z, h)
                                } else o(a, c, d, Ba.z, null)
                    }
                    for (c = a.children, d = 0, g = c.length; d < g; d++) q(c[d], b)
                }
            }

            function r(a, b, c, d) {
                for (var e = 0, f = a.length; e < f; e++) {
                    var g = a[e],
                        h = g.object,
                        i = g.geometry,
                        j = void 0 === d ? g.material : d,
                        g = g.group;
                    if (h.modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, h.matrixWorld), h.normalMatrix.getNormalMatrix(h.modelViewMatrix), h.isImmediateRenderObject) {
                        s(j);
                        var k = t(b, c, j, h);
                        W = "", h.render(function(a) {
                            M.renderBufferImmediate(a, k, j)
                        })
                    } else null !== h.onBeforeRender && h.onBeforeRender(), M.renderBufferDirect(b, c, i, j, h, g)
                }
            }

            function s(a) {
                2 === a.side ? Ha.disable(Ea.CULL_FACE) : Ha.enable(Ea.CULL_FACE), Ha.setFlipSided(1 === a.side), !0 === a.transparent ? Ha.setBlending(a.blending, a.blendEquation, a.blendSrc, a.blendDst, a.blendEquationAlpha, a.blendSrcAlpha, a.blendDstAlpha, a.premultipliedAlpha) : Ha.setBlending(0), Ha.setDepthFunc(a.depthFunc), Ha.setDepthTest(a.depthTest), Ha.setDepthWrite(a.depthWrite), Ha.setColorWrite(a.colorWrite), Ha.setPolygonOffset(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits)
            }

            function t(b, c, d, e) {
                ca = 0;
                var f = Ia.get(d);
                if (oa && (ta || b !== X) && na.setState(d.clippingPlanes, d.clipShadows, b, f, b === X && d.id === U), !1 === d.needsUpdate && (void 0 === f.program ? d.needsUpdate = !0 : d.fog && f.fog !== c ? d.needsUpdate = !0 : d.lights && f.lightsHash !== Ca.hash ? d.needsUpdate = !0 : void 0 !== f.numClippingPlanes && f.numClippingPlanes !== na.numPlanes && (d.needsUpdate = !0)), d.needsUpdate) {
                    a: {
                        var g = Ia.get(d),
                            i = La.getParameters(d, Ca, c, na.numPlanes, e),
                            j = La.getProgramCode(d, i),
                            l = g.program,
                            m = !0;
                        if (void 0 === l) d.addEventListener("dispose", h);
                        else if (l.code !== j) k(d);
                        else {
                            if (void 0 !== i.shaderID) break a;
                            m = !1
                        }
                        if (m && (i.shaderID ? (l = Ud[i.shaderID], g.__webglShader = {
                                name: d.type,
                                uniforms: a.UniformsUtils.clone(l.uniforms),
                                vertexShader: l.vertexShader,
                                fragmentShader: l.fragmentShader
                            }) : g.__webglShader = {
                                name: d.type,
                                uniforms: d.uniforms,
                                vertexShader: d.vertexShader,
                                fragmentShader: d.fragmentShader
                            }, d.__webglShader = g.__webglShader, l = La.acquireProgram(d, i, j), g.program = l, d.program = l), i = l.getAttributes(), d.morphTargets)
                            for (j = d.numSupportedMorphTargets = 0; j < M.maxMorphTargets; j++) 0 <= i["morphTarget" + j] && d.numSupportedMorphTargets++;
                        if (d.morphNormals)
                            for (j = d.numSupportedMorphNormals = 0; j < M.maxMorphNormals; j++) 0 <= i["morphNormal" + j] && d.numSupportedMorphNormals++;i = g.__webglShader.uniforms,
                        (d.isShaderMaterial || d.isRawShaderMaterial) && !0 !== d.clipping || (g.numClippingPlanes = na.numPlanes, i.clippingPlanes = na.uniform),
                        g.fog = c,
                        g.lightsHash = Ca.hash,
                        d.lights && (i.ambientLightColor.value = Ca.ambient, i.directionalLights.value = Ca.directional, i.spotLights.value = Ca.spot, i.pointLights.value = Ca.point, i.hemisphereLights.value = Ca.hemi, i.directionalShadowMap.value = Ca.directionalShadowMap, i.directionalShadowMatrix.value = Ca.directionalShadowMatrix, i.spotShadowMap.value = Ca.spotShadowMap, i.spotShadowMatrix.value = Ca.spotShadowMatrix, i.pointShadowMap.value = Ca.pointShadowMap, i.pointShadowMatrix.value = Ca.pointShadowMatrix),
                        j = g.program.getUniforms(),
                        j = P.seqWithValue(j.seq, i),
                        g.uniformsList = j,
                        g.dynamicUniforms = P.splitDynamic(j, i)
                    }
                    d.needsUpdate = !1
                }
                var n = !1,
                    m = l = !1,
                    g = f.program,
                    j = g.getUniforms(),
                    i = f.__webglShader.uniforms;
                if (g.id !== N && (Ea.useProgram(g.program), N = g.id, m = l = n = !0), d.id !== U && (U = d.id, l = !0), (n || b !== X) && (j.set(Ea, b, "projectionMatrix"), Ga.logarithmicDepthBuffer && j.setValue(Ea, "logDepthBufFC", 2 / (Math.log(b.far + 1) / Math.LN2)), b !== X && (X = b, m = l = !0), (d.isShaderMaterial || d.isMeshPhongMaterial || d.isMeshStandardMaterial || d.envMap) && (n = j.map.cameraPosition, void 0 !== n && n.setValue(Ea, Ba.setFromMatrixPosition(b.matrixWorld))), (d.isMeshPhongMaterial || d.isMeshLambertMaterial || d.isMeshBasicMaterial || d.isMeshStandardMaterial || d.isShaderMaterial || d.skinning) && j.setValue(Ea, "viewMatrix", b.matrixWorldInverse), j.set(Ea, M, "toneMappingExposure"), j.set(Ea, M, "toneMappingWhitePoint")), d.skinning && (j.setOptional(Ea, e, "bindMatrix"), j.setOptional(Ea, e, "bindMatrixInverse"), n = e.skeleton) && (Ga.floatVertexTextures && n.useVertexTexture ? (j.set(Ea, n, "boneTexture"), j.set(Ea, n, "boneTextureWidth"), j.set(Ea, n, "boneTextureHeight")) : j.setOptional(Ea, n, "boneMatrices")), l) {
                    if (d.lights && (l = m, i.ambientLightColor.needsUpdate = l, i.directionalLights.needsUpdate = l, i.pointLights.needsUpdate = l, i.spotLights.needsUpdate = l, i.hemisphereLights.needsUpdate = l), c && d.fog && (i.fogColor.value = c.color, c.isFog ? (i.fogNear.value = c.near, i.fogFar.value = c.far) : c.isFogExp2 && (i.fogDensity.value = c.density)), d.isMeshBasicMaterial || d.isMeshLambertMaterial || d.isMeshPhongMaterial || d.isMeshStandardMaterial || d.isMeshDepthMaterial) {
                        i.opacity.value = d.opacity, i.diffuse.value = d.color, d.emissive && i.emissive.value.copy(d.emissive).multiplyScalar(d.emissiveIntensity), i.map.value = d.map, i.specularMap.value = d.specularMap, i.alphaMap.value = d.alphaMap, d.aoMap && (i.aoMap.value = d.aoMap, i.aoMapIntensity.value = d.aoMapIntensity);
                        var o;
                        d.map ? o = d.map : d.specularMap ? o = d.specularMap : d.displacementMap ? o = d.displacementMap : d.normalMap ? o = d.normalMap : d.bumpMap ? o = d.bumpMap : d.roughnessMap ? o = d.roughnessMap : d.metalnessMap ? o = d.metalnessMap : d.alphaMap ? o = d.alphaMap : d.emissiveMap && (o = d.emissiveMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), c = o.offset, o = o.repeat, i.offsetRepeat.value.set(c.x, c.y, o.x, o.y)), i.envMap.value = d.envMap, i.flipEnvMap.value = d.envMap && d.envMap.isCubeTexture ? -1 : 1, i.reflectivity.value = d.reflectivity, i.refractionRatio.value = d.refractionRatio
                    }
                    d.isLineBasicMaterial ? (i.diffuse.value = d.color, i.opacity.value = d.opacity) : d.isLineDashedMaterial ? (i.diffuse.value = d.color, i.opacity.value = d.opacity, i.dashSize.value = d.dashSize, i.totalSize.value = d.dashSize + d.gapSize, i.scale.value = d.scale) : d.isPointsMaterial ? (i.diffuse.value = d.color, i.opacity.value = d.opacity, i.size.value = d.size * ha, i.scale.value = .5 * w.clientHeight, i.map.value = d.map, null !== d.map && (o = d.map.offset, c = d.map.repeat, i.offsetRepeat.value.set(o.x, o.y, c.x, c.y))) : d.isMeshLambertMaterial ? (d.lightMap && (i.lightMap.value = d.lightMap, i.lightMapIntensity.value = d.lightMapIntensity), d.emissiveMap && (i.emissiveMap.value = d.emissiveMap)) : d.isMeshPhongMaterial ? (i.specular.value = d.specular, i.shininess.value = Math.max(d.shininess, 1e-4), d.lightMap && (i.lightMap.value = d.lightMap, i.lightMapIntensity.value = d.lightMapIntensity), d.emissiveMap && (i.emissiveMap.value = d.emissiveMap), d.bumpMap && (i.bumpMap.value = d.bumpMap, i.bumpScale.value = d.bumpScale), d.normalMap && (i.normalMap.value = d.normalMap, i.normalScale.value.copy(d.normalScale)), d.displacementMap && (i.displacementMap.value = d.displacementMap, i.displacementScale.value = d.displacementScale, i.displacementBias.value = d.displacementBias)) : d.isMeshPhysicalMaterial ? (i.clearCoat.value = d.clearCoat, i.clearCoatRoughness.value = d.clearCoatRoughness, u(i, d)) : d.isMeshStandardMaterial ? u(i, d) : d.isMeshDepthMaterial ? d.displacementMap && (i.displacementMap.value = d.displacementMap, i.displacementScale.value = d.displacementScale, i.displacementBias.value = d.displacementBias) : d.isMeshNormalMaterial && (i.opacity.value = d.opacity), P.upload(Ea, f.uniformsList, i, M)
                }
                return j.set(Ea, e, "modelViewMatrix"), j.set(Ea, e, "normalMatrix"), j.setValue(Ea, "modelMatrix", e.matrixWorld), f = f.dynamicUniforms, null !== f && (P.evalDynamic(f, i, e, d, b), P.upload(Ea, f, i, M)), g
            }

            function u(a, b) {
                a.roughness.value = b.roughness, a.metalness.value = b.metalness, b.roughnessMap && (a.roughnessMap.value = b.roughnessMap), b.metalnessMap && (a.metalnessMap.value = b.metalnessMap), b.lightMap && (a.lightMap.value = b.lightMap, a.lightMapIntensity.value = b.lightMapIntensity), b.emissiveMap && (a.emissiveMap.value = b.emissiveMap), b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale), b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale)), b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale, a.displacementBias.value = b.displacementBias), b.envMap && (a.envMapIntensity.value = b.envMapIntensity)
            }

            function v(a) {
                var b;
                if (1e3 === a) return Ea.REPEAT;
                if (1001 === a) return Ea.CLAMP_TO_EDGE;
                if (1002 === a) return Ea.MIRRORED_REPEAT;
                if (1003 === a) return Ea.NEAREST;
                if (1004 === a) return Ea.NEAREST_MIPMAP_NEAREST;
                if (1005 === a) return Ea.NEAREST_MIPMAP_LINEAR;
                if (1006 === a) return Ea.LINEAR;
                if (1007 === a) return Ea.LINEAR_MIPMAP_NEAREST;
                if (1008 === a) return Ea.LINEAR_MIPMAP_LINEAR;
                if (1009 === a) return Ea.UNSIGNED_BYTE;
                if (1017 === a) return Ea.UNSIGNED_SHORT_4_4_4_4;
                if (1018 === a) return Ea.UNSIGNED_SHORT_5_5_5_1;
                if (1019 === a) return Ea.UNSIGNED_SHORT_5_6_5;
                if (1010 === a) return Ea.BYTE;
                if (1011 === a) return Ea.SHORT;
                if (1012 === a) return Ea.UNSIGNED_SHORT;
                if (1013 === a) return Ea.INT;
                if (1014 === a) return Ea.UNSIGNED_INT;
                if (1015 === a) return Ea.FLOAT;
                if (b = Fa.get("OES_texture_half_float"), null !== b && 1016 === a) return b.HALF_FLOAT_OES;
                if (1021 === a) return Ea.ALPHA;
                if (1022 === a) return Ea.RGB;
                if (1023 === a) return Ea.RGBA;
                if (1024 === a) return Ea.LUMINANCE;
                if (1025 === a) return Ea.LUMINANCE_ALPHA;
                if (1026 === a) return Ea.DEPTH_COMPONENT;
                if (1027 === a) return Ea.DEPTH_STENCIL;
                if (100 === a) return Ea.FUNC_ADD;
                if (101 === a) return Ea.FUNC_SUBTRACT;
                if (102 === a) return Ea.FUNC_REVERSE_SUBTRACT;
                if (200 === a) return Ea.ZERO;
                if (201 === a) return Ea.ONE;
                if (202 === a) return Ea.SRC_COLOR;
                if (203 === a) return Ea.ONE_MINUS_SRC_COLOR;
                if (204 === a) return Ea.SRC_ALPHA;
                if (205 === a) return Ea.ONE_MINUS_SRC_ALPHA;
                if (206 === a) return Ea.DST_ALPHA;
                if (207 === a) return Ea.ONE_MINUS_DST_ALPHA;
                if (208 === a) return Ea.DST_COLOR;
                if (209 === a) return Ea.ONE_MINUS_DST_COLOR;
                if (210 === a) return Ea.SRC_ALPHA_SATURATE;
                if (b = Fa.get("WEBGL_compressed_texture_s3tc"), null !== b) {
                    if (2001 === a) return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (2002 === a) return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (2003 === a) return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (2004 === a) return b.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (b = Fa.get("WEBGL_compressed_texture_pvrtc"), null !== b) {
                    if (2100 === a) return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (2101 === a) return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (2102 === a) return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (2103 === a) return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (b = Fa.get("WEBGL_compressed_texture_etc1"), null !== b && 2151 === a) return b.COMPRESSED_RGB_ETC1_WEBGL;
                if (b = Fa.get("EXT_blend_minmax"), null !== b) {
                    if (103 === a) return b.MIN_EXT;
                    if (104 === a) return b.MAX_EXT
                }
                return b = Fa.get("WEBGL_depth_texture"), null !== b && 1020 === a ? b.UNSIGNED_INT_24_8_WEBGL : 0
            }
            console.log("THREE.WebGLRenderer", "81"), b = b || {};
            var w = void 0 !== b.canvas ? b.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                x = void 0 !== b.context ? b.context : null,
                y = void 0 !== b.alpha && b.alpha,
                z = void 0 === b.depth || b.depth,
                A = void 0 === b.stencil || b.stencil,
                B = void 0 !== b.antialias && b.antialias,
                C = void 0 === b.premultipliedAlpha || b.premultipliedAlpha,
                D = void 0 !== b.preserveDrawingBuffer && b.preserveDrawingBuffer,
                E = [],
                F = [],
                G = -1,
                H = [],
                I = -1,
                J = new Float32Array(8),
                K = [],
                L = [];
            this.domElement = w, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
            var M = this,
                N = null,
                O = null,
                R = null,
                U = -1,
                W = "",
                X = null,
                Z = new e,
                $ = null,
                ba = new e,
                ca = 0,
                da = new Q(0),
                ea = 0,
                fa = w.width,
                ga = w.height,
                ha = 1,
                ja = new e(0, 0, fa, ga),
                ka = !1,
                la = new e(0, 0, fa, ga),
                ma = new _,
                na = new Ua,
                oa = !1,
                ta = !1,
                za = new Y,
                Aa = new j,
                Ba = new i,
                Ca = {
                    hash: "",
                    ambient: [0, 0, 0],
                    directional: [],
                    directionalShadowMap: [],
                    directionalShadowMatrix: [],
                    spot: [],
                    spotShadowMap: [],
                    spotShadowMatrix: [],
                    point: [],
                    pointShadowMap: [],
                    pointShadowMatrix: [],
                    hemi: [],
                    shadows: []
                },
                Da = {
                    calls: 0,
                    vertices: 0,
                    faces: 0,
                    points: 0
                };
            this.info = {
                render: Da,
                memory: {
                    geometries: 0,
                    textures: 0
                },
                programs: null
            };
            var Ea;
            try {
                if (y = {
                        alpha: y,
                        depth: z,
                        stencil: A,
                        antialias: B,
                        premultipliedAlpha: C,
                        preserveDrawingBuffer: D
                    }, Ea = x || w.getContext("webgl", y) || w.getContext("experimental-webgl", y), null === Ea) {
                    if (null !== w.getContext("webgl")) throw "Error creating WebGL context with your selected attributes.";
                    throw "Error creating WebGL context."
                }
                void 0 === Ea.getShaderPrecisionFormat && (Ea.getShaderPrecisionFormat = function() {
                    return {
                        rangeMin: 1,
                        rangeMax: 1,
                        precision: 1
                    }
                }), w.addEventListener("webglcontextlost", g, !1)
            } catch (a) {
                console.error("THREE.WebGLRenderer: " + a)
            }
            var Fa = new Ta(Ea);
            Fa.get("WEBGL_depth_texture"), Fa.get("OES_texture_float"), Fa.get("OES_texture_float_linear"), Fa.get("OES_texture_half_float"), Fa.get("OES_texture_half_float_linear"), Fa.get("OES_standard_derivatives"), Fa.get("ANGLE_instanced_arrays"), Fa.get("OES_element_index_uint") && (pa.MaxIndex = 4294967296);
            var Ga = new Sa(Ea, Fa, b),
                Ha = new Ra(Ea, Fa, v),
                Ia = new Qa,
                Ja = new Pa(Ea, Fa, Ha, Ia, Ga, v, this.info),
                Ka = new Oa(Ea, Ia, this.info),
                La = new Ma(this, Ga),
                Na = new ya;
            this.info.programs = La.programs;
            var Va = new xa(Ea, Fa, Da),
                Wa = new wa(Ea, Fa, Da),
                Xa = new va(-1, 1, 1, -1, 0, 1),
                Ya = new ua,
                Za = new qa(new sa(2, 2), new ia({
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                }));
            b = Ud.cube;
            var $a = new qa(new ra(5, 5, 5), new V({
                uniforms: b.uniforms,
                vertexShader: b.vertexShader,
                fragmentShader: b.fragmentShader,
                side: 1,
                depthTest: !1,
                depthWrite: !1,
                fog: !1
            }));
            d(), this.context = Ea, this.capabilities = Ga, this.extensions = Fa, this.properties = Ia, this.state = Ha;
            var _a = new aa(this, Ca, Ka, Ga);
            this.shadowMap = _a;
            var ab = new T(this, K),
                bb = new S(this, L);
            this.getContext = function() {
                return Ea
            }, this.getContextAttributes = function() {
                return Ea.getContextAttributes()
            }, this.forceContextLoss = function() {
                Fa.get("WEBGL_lose_context").loseContext()
            }, this.getMaxAnisotropy = function() {
                return Ga.getMaxAnisotropy()
            }, this.getPrecision = function() {
                return Ga.precision
            }, this.getPixelRatio = function() {
                return ha
            }, this.setPixelRatio = function(a) {
                void 0 !== a && (ha = a, this.setSize(la.z, la.w, !1))
            }, this.getSize = function() {
                return {
                    width: fa,
                    height: ga
                }
            }, this.setSize = function(a, b, c) {
                fa = a, ga = b, w.width = a * ha, w.height = b * ha, !1 !== c && (w.style.width = a + "px", w.style.height = b + "px"), this.setViewport(0, 0, a, b)
            }, this.setViewport = function(a, b, c, d) {
                Ha.viewport(la.set(a, b, c, d))
            }, this.setScissor = function(a, b, c, d) {
                Ha.scissor(ja.set(a, b, c, d))
            }, this.setScissorTest = function(a) {
                Ha.setScissorTest(ka = a)
            }, this.getClearColor = function() {
                return da
            }, this.setClearColor = function(a, b) {
                da.set(a), ea = void 0 !== b ? b : 1, c(da.r, da.g, da.b, ea)
            }, this.getClearAlpha = function() {
                return ea
            }, this.setClearAlpha = function(a) {
                ea = a, c(da.r, da.g, da.b, ea)
            }, this.clear = function(a, b, c) {
                var d = 0;
                (void 0 === a || a) && (d |= Ea.COLOR_BUFFER_BIT), (void 0 === b || b) && (d |= Ea.DEPTH_BUFFER_BIT), (void 0 === c || c) && (d |= Ea.STENCIL_BUFFER_BIT), Ea.clear(d)
            }, this.clearColor = function() {
                this.clear(!0, !1, !1)
            }, this.clearDepth = function() {
                this.clear(!1, !0, !1)
            }, this.clearStencil = function() {
                this.clear(!1, !1, !0)
            }, this.clearTarget = function(a, b, c, d) {
                this.setRenderTarget(a), this.clear(b, c, d)
            }, this.resetGLState = f, this.dispose = function() {
                H = [], I = -1, F = [], G = -1, w.removeEventListener("webglcontextlost", g, !1)
            }, this.renderBufferImmediate = function(a, b, c) {
                Ha.initAttributes();
                var d = Ia.get(a);
                if (a.hasPositions && !d.position && (d.position = Ea.createBuffer()), a.hasNormals && !d.normal && (d.normal = Ea.createBuffer()), a.hasUvs && !d.uv && (d.uv = Ea.createBuffer()), a.hasColors && !d.color && (d.color = Ea.createBuffer()), b = b.getAttributes(), a.hasPositions && (Ea.bindBuffer(Ea.ARRAY_BUFFER, d.position), Ea.bufferData(Ea.ARRAY_BUFFER, a.positionArray, Ea.DYNAMIC_DRAW), Ha.enableAttribute(b.position), Ea.vertexAttribPointer(b.position, 3, Ea.FLOAT, !1, 0, 0)), a.hasNormals) {
                    if (Ea.bindBuffer(Ea.ARRAY_BUFFER, d.normal), !c.isMeshPhongMaterial && !c.isMeshStandardMaterial && 1 === c.shading)
                        for (var e = 0, f = 3 * a.count; e < f; e += 9) {
                            var g = a.normalArray,
                                h = (g[e + 0] + g[e + 3] + g[e + 6]) / 3,
                                i = (g[e + 1] + g[e + 4] + g[e + 7]) / 3,
                                j = (g[e + 2] + g[e + 5] + g[e + 8]) / 3;
                            g[e + 0] = h, g[e + 1] = i, g[e + 2] = j, g[e + 3] = h, g[e + 4] = i, g[e + 5] = j, g[e + 6] = h, g[e + 7] = i, g[e + 8] = j
                        }
                    Ea.bufferData(Ea.ARRAY_BUFFER, a.normalArray, Ea.DYNAMIC_DRAW), Ha.enableAttribute(b.normal), Ea.vertexAttribPointer(b.normal, 3, Ea.FLOAT, !1, 0, 0)
                }
                a.hasUvs && c.map && (Ea.bindBuffer(Ea.ARRAY_BUFFER, d.uv), Ea.bufferData(Ea.ARRAY_BUFFER, a.uvArray, Ea.DYNAMIC_DRAW), Ha.enableAttribute(b.uv), Ea.vertexAttribPointer(b.uv, 2, Ea.FLOAT, !1, 0, 0)), a.hasColors && 0 !== c.vertexColors && (Ea.bindBuffer(Ea.ARRAY_BUFFER, d.color), Ea.bufferData(Ea.ARRAY_BUFFER, a.colorArray, Ea.DYNAMIC_DRAW), Ha.enableAttribute(b.color), Ea.vertexAttribPointer(b.color, 3, Ea.FLOAT, !1, 0, 0)), Ha.disableUnusedAttributes(), Ea.drawArrays(Ea.TRIANGLES, 0, a.count), a.count = 0
            }, this.renderBufferDirect = function(a, b, c, d, e, f) {
                s(d);
                var g = t(a, b, d, e),
                    h = !1;
                if (a = c.id + "_" + g.id + "_" + d.wireframe, a !== W && (W = a, h = !0), b = e.morphTargetInfluences, void 0 !== b) {
                    var i = [];
                    a = 0;
                    for (var j = b.length; a < j; a++) h = b[a], i.push([h, a]);
                    i.sort(l), 8 < i.length && (i.length = 8);
                    var k = c.morphAttributes;
                    for (a = 0, j = i.length; a < j; a++) h = i[a], J[a] = h[0], 0 !== h[0] ? (b = h[1], !0 === d.morphTargets && k.position && c.addAttribute("morphTarget" + a, k.position[b]), !0 === d.morphNormals && k.normal && c.addAttribute("morphNormal" + a, k.normal[b])) : (!0 === d.morphTargets && c.removeAttribute("morphTarget" + a), !0 === d.morphNormals && c.removeAttribute("morphNormal" + a));
                    for (a = i.length, b = J.length; a < b; a++) J[a] = 0;
                    g.getUniforms().setValue(Ea, "morphTargetInfluences", J), h = !0
                }
                if (b = c.index, j = c.attributes.position, i = 1, !0 === d.wireframe && (b = Ka.getWireframeAttribute(c), i = 2), null !== b ? (a = Wa, a.setIndex(b)) : a = Va, h) {
                    var m, h = void 0;
                    if (c && c.isInstancedBufferGeometry && (m = Fa.get("ANGLE_instanced_arrays"), null === m)) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    else {
                        void 0 === h && (h = 0), Ha.initAttributes();
                        var n, k = c.attributes,
                            g = g.getAttributes(),
                            o = d.defaultAttributeValues;
                        for (n in g) {
                            var p = g[n];
                            if (0 <= p) {
                                var q = k[n];
                                if (void 0 !== q) {
                                    var r = Ea.FLOAT,
                                        u = q.array,
                                        v = q.normalized;
                                    u instanceof Float32Array ? r = Ea.FLOAT : u instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : u instanceof Uint16Array ? r = Ea.UNSIGNED_SHORT : u instanceof Int16Array ? r = Ea.SHORT : u instanceof Uint32Array ? r = Ea.UNSIGNED_INT : u instanceof Int32Array ? r = Ea.INT : u instanceof Int8Array ? r = Ea.BYTE : u instanceof Uint8Array && (r = Ea.UNSIGNED_BYTE);
                                    var u = q.itemSize,
                                        w = Ka.getAttributeBuffer(q);
                                    if (q && q.isInterleavedBufferAttribute) {
                                        var x = q.data,
                                            y = x.stride,
                                            q = q.offset;
                                        x && x.isInstancedInterleavedBuffer ? (Ha.enableAttributeAndDivisor(p, x.meshPerAttribute, m), void 0 === c.maxInstancedCount && (c.maxInstancedCount = x.meshPerAttribute * x.count)) : Ha.enableAttribute(p), Ea.bindBuffer(Ea.ARRAY_BUFFER, w), Ea.vertexAttribPointer(p, u, r, v, y * x.array.BYTES_PER_ELEMENT, (h * y + q) * x.array.BYTES_PER_ELEMENT)
                                    } else q && q.isInstancedBufferAttribute ? (Ha.enableAttributeAndDivisor(p, q.meshPerAttribute, m), void 0 === c.maxInstancedCount && (c.maxInstancedCount = q.meshPerAttribute * q.count)) : Ha.enableAttribute(p), Ea.bindBuffer(Ea.ARRAY_BUFFER, w), Ea.vertexAttribPointer(p, u, r, v, 0, h * u * q.array.BYTES_PER_ELEMENT)
                                } else if (void 0 !== o && (r = o[n], void 0 !== r)) switch (r.length) {
                                    case 2:
                                        Ea.vertexAttrib2fv(p, r);
                                        break;
                                    case 3:
                                        Ea.vertexAttrib3fv(p, r);
                                        break;
                                    case 4:
                                        Ea.vertexAttrib4fv(p, r);
                                        break;
                                    default:
                                        Ea.vertexAttrib1fv(p, r)
                                }
                            }
                        }
                        Ha.disableUnusedAttributes()
                    }
                    null !== b && Ea.bindBuffer(Ea.ELEMENT_ARRAY_BUFFER, Ka.getAttributeBuffer(b))
                }
                if (m = 0, null !== b ? m = b.count : void 0 !== j && (m = j.count), b = c.drawRange.start * i, j = null !== f ? f.start * i : 0, n = Math.max(b, j), f = Math.max(0, Math.min(m, b + c.drawRange.count * i, j + (null !== f ? f.count * i : 1 / 0)) - 1 - n + 1), 0 !== f) {
                    if (e.isMesh)
                        if (!0 === d.wireframe) Ha.setLineWidth(d.wireframeLinewidth * (null === O ? ha : 1)), a.setMode(Ea.LINES);
                        else switch (e.drawMode) {
                            case 0:
                                a.setMode(Ea.TRIANGLES);
                                break;
                            case 1:
                                a.setMode(Ea.TRIANGLE_STRIP);
                                break;
                            case 2:
                                a.setMode(Ea.TRIANGLE_FAN)
                        } else e.isLine ? (d = d.linewidth, void 0 === d && (d = 1), Ha.setLineWidth(d * (null === O ? ha : 1)), e.isLineSegments ? a.setMode(Ea.LINES) : a.setMode(Ea.LINE_STRIP)) : e.isPoints && a.setMode(Ea.POINTS);
                    c && c.isInstancedBufferGeometry ? 0 < c.maxInstancedCount && a.renderInstances(c, n, f) : a.render(n, f)
                }
            }, this.render = function(a, b, d, e) {
                if (void 0 !== b && !0 !== b.isCamera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                else {
                    var f = a.fog;
                    W = "", U = -1, X = null, !0 === a.autoUpdate && a.updateMatrixWorld(), null === b.parent && b.updateMatrixWorld(), b.matrixWorldInverse.getInverse(b.matrixWorld), Aa.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), ma.setFromMatrix(Aa), E.length = 0, I = G = -1, K.length = 0, L.length = 0, ta = this.localClippingEnabled, oa = na.init(this.clippingPlanes, ta, b), q(a, b), F.length = G + 1, H.length = I + 1, !0 === M.sortObjects && (F.sort(m), H.sort(n)), oa && na.beginShadows();
                    for (var g = E, h = 0, i = 0, k = g.length; i < k; i++) {
                        var l = g[i];
                        l.castShadow && (Ca.shadows[h++] = l)
                    }
                    Ca.shadows.length = h, _a.render(a, b);
                    for (var o, p, s, t, g = E, u = l = 0, v = 0, w = b.matrixWorldInverse, x = 0, y = 0, z = 0, A = 0, h = 0, i = g.length; h < i; h++)
                        if (k = g[h], o = k.color, p = k.intensity, s = k.distance, t = k.shadow && k.shadow.map ? k.shadow.map.texture : null, k.isAmbientLight) l += o.r * p, u += o.g * p, v += o.b * p;
                        else if (k.isDirectionalLight) {
                        var B = Na.get(k);
                        B.color.copy(k.color).multiplyScalar(k.intensity), B.direction.setFromMatrixPosition(k.matrixWorld), Ba.setFromMatrixPosition(k.target.matrixWorld), B.direction.sub(Ba), B.direction.transformDirection(w), (B.shadow = k.castShadow) && (B.shadowBias = k.shadow.bias, B.shadowRadius = k.shadow.radius, B.shadowMapSize = k.shadow.mapSize), Ca.directionalShadowMap[x] = t, Ca.directionalShadowMatrix[x] = k.shadow.matrix, Ca.directional[x++] = B
                    } else k.isSpotLight ? (B = Na.get(k), B.position.setFromMatrixPosition(k.matrixWorld), B.position.applyMatrix4(w), B.color.copy(o).multiplyScalar(p), B.distance = s, B.direction.setFromMatrixPosition(k.matrixWorld), Ba.setFromMatrixPosition(k.target.matrixWorld), B.direction.sub(Ba), B.direction.transformDirection(w), B.coneCos = Math.cos(k.angle), B.penumbraCos = Math.cos(k.angle * (1 - k.penumbra)), B.decay = 0 === k.distance ? 0 : k.decay, (B.shadow = k.castShadow) && (B.shadowBias = k.shadow.bias, B.shadowRadius = k.shadow.radius, B.shadowMapSize = k.shadow.mapSize), Ca.spotShadowMap[z] = t, Ca.spotShadowMatrix[z] = k.shadow.matrix, Ca.spot[z++] = B) : k.isPointLight ? (B = Na.get(k), B.position.setFromMatrixPosition(k.matrixWorld), B.position.applyMatrix4(w), B.color.copy(k.color).multiplyScalar(k.intensity), B.distance = k.distance, B.decay = 0 === k.distance ? 0 : k.decay, (B.shadow = k.castShadow) && (B.shadowBias = k.shadow.bias, B.shadowRadius = k.shadow.radius, B.shadowMapSize = k.shadow.mapSize), Ca.pointShadowMap[y] = t, void 0 === Ca.pointShadowMatrix[y] && (Ca.pointShadowMatrix[y] = new j), Ba.setFromMatrixPosition(k.matrixWorld).negate(), Ca.pointShadowMatrix[y].identity().setPosition(Ba), Ca.point[y++] = B) : k.isHemisphereLight && (B = Na.get(k), B.direction.setFromMatrixPosition(k.matrixWorld), B.direction.transformDirection(w), B.direction.normalize(), B.skyColor.copy(k.color).multiplyScalar(p), B.groundColor.copy(k.groundColor).multiplyScalar(p), Ca.hemi[A++] = B);
                    Ca.ambient[0] = l, Ca.ambient[1] = u, Ca.ambient[2] = v, Ca.directional.length = x, Ca.spot.length = z, Ca.point.length = y, Ca.hemi.length = A, Ca.hash = x + "," + y + "," + z + "," + A + "," + Ca.shadows.length, oa && na.endShadows(), Da.calls = 0, Da.vertices = 0, Da.faces = 0, Da.points = 0, void 0 === d && (d = null), this.setRenderTarget(d), g = a.background, null === g ? c(da.r, da.g, da.b, ea) : g && g.isColor && (c(g.r, g.g, g.b, 1), e = !0), (this.autoClear || e) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), g && g.isCubeTexture ? (Ya.projectionMatrix.copy(b.projectionMatrix), Ya.matrixWorld.extractRotation(b.matrixWorld), Ya.matrixWorldInverse.getInverse(Ya.matrixWorld), $a.material.uniforms.tCube.value = g, $a.modelViewMatrix.multiplyMatrices(Ya.matrixWorldInverse, $a.matrixWorld), Ka.update($a), M.renderBufferDirect(Ya, null, $a.geometry, $a.material, $a, null)) : g && g.isTexture && (Za.material.map = g, Ka.update(Za), M.renderBufferDirect(Xa, null, Za.geometry, Za.material, Za, null)), a.overrideMaterial ? (e = a.overrideMaterial, r(F, b, f, e), r(H, b, f, e)) : (Ha.setBlending(0), r(F, b, f), r(H, b, f)), ab.render(a, b), bb.render(a, b, ba), d && Ja.updateRenderTargetMipmap(d), Ha.setDepthTest(!0), Ha.setDepthWrite(!0), Ha.setColorWrite(!0)
                }
            }, this.setFaceCulling = function(a, b) {
                Ha.setCullFace(a), Ha.setFlipSided(0 === b)
            }, this.allocTextureUnit = function() {
                var a = ca;
                return a >= Ga.maxTextures && console.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " + Ga.maxTextures), ca += 1, a
            }, this.setTexture2D = function() {
                var a = !1;
                return function(b, c) {
                    b && b.isWebGLRenderTarget && (a || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), a = !0), b = b.texture), Ja.setTexture2D(b, c)
                }
            }(), this.setTexture = function() {
                var a = !1;
                return function(b, c) {
                    a || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), a = !0), Ja.setTexture2D(b, c)
                }
            }(), this.setTextureCube = function() {
                var a = !1;
                return function(b, c) {
                    b && b.isWebGLRenderTargetCube && (a || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), a = !0), b = b.texture), b && b.isCubeTexture || Array.isArray(b.image) && 6 === b.image.length ? Ja.setTextureCube(b, c) : Ja.setTextureCubeDynamic(b, c)
                }
            }(), this.getCurrentRenderTarget = function() {
                return O
            }, this.setRenderTarget = function(a) {
                (O = a) && void 0 === Ia.get(a).__webglFramebuffer && Ja.setupRenderTarget(a);
                var b, c = a && a.isWebGLRenderTargetCube;
                a ? (b = Ia.get(a), b = c ? b.__webglFramebuffer[a.activeCubeFace] : b.__webglFramebuffer, Z.copy(a.scissor), $ = a.scissorTest, ba.copy(a.viewport)) : (b = null, Z.copy(ja).multiplyScalar(ha), $ = ka, ba.copy(la).multiplyScalar(ha)), R !== b && (Ea.bindFramebuffer(Ea.FRAMEBUFFER, b), R = b), Ha.scissor(Z), Ha.setScissorTest($), Ha.viewport(ba), c && (c = Ia.get(a.texture), Ea.framebufferTexture2D(Ea.FRAMEBUFFER, Ea.COLOR_ATTACHMENT0, Ea.TEXTURE_CUBE_MAP_POSITIVE_X + a.activeCubeFace, c.__webglTexture, a.activeMipMapLevel));
            }, this.readRenderTargetPixels = function(a, b, c, d, e, f) {
                if (!1 === (a && a.isWebGLRenderTarget)) console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                else {
                    var g = Ia.get(a).__webglFramebuffer;
                    if (g) {
                        var h = !1;
                        g !== R && (Ea.bindFramebuffer(Ea.FRAMEBUFFER, g), h = !0);
                        try {
                            var i = a.texture,
                                j = i.format,
                                k = i.type;
                            1023 !== j && v(j) !== Ea.getParameter(Ea.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === k || v(k) === Ea.getParameter(Ea.IMPLEMENTATION_COLOR_READ_TYPE) || 1015 === k && (Fa.get("OES_texture_float") || Fa.get("WEBGL_color_buffer_float")) || 1016 === k && Fa.get("EXT_color_buffer_half_float") ? Ea.checkFramebufferStatus(Ea.FRAMEBUFFER) === Ea.FRAMEBUFFER_COMPLETE ? 0 <= b && b <= a.width - d && 0 <= c && c <= a.height - e && Ea.readPixels(b, c, d, e, v(j), v(k), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                        } finally {
                            h && Ea.bindFramebuffer(Ea.FRAMEBUFFER, R)
                        }
                    }
                }
            }
        }

        function Wa(a, b) {
            this.name = "", this.color = new Q(a), this.density = void 0 !== b ? b : 25e-5
        }

        function Xa(a, b, c) {
            this.name = "", this.color = new Q(a), this.near = void 0 !== b ? b : 1, this.far = void 0 !== c ? c : 1e3
        }

        function Ya() {
            ea.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0
        }

        function Za(a, b, c, d, e) {
            ea.call(this), this.lensFlares = [], this.positionScreen = new i, this.customUpdateCallback = void 0, void 0 !== a && this.add(a, b, c, d, e)
        }

        function $a(a) {
            U.call(this), this.type = "SpriteMaterial", this.color = new Q(16777215), this.map = null, this.rotation = 0, this.lights = this.fog = !1, this.setValues(a)
        }

        function _a(a) {
            ea.call(this), this.type = "Sprite", this.material = void 0 !== a ? a : new $a
        }

        function ab() {
            ea.call(this), this.type = "LOD", Object.defineProperties(this, {
                levels: {
                    enumerable: !0,
                    value: []
                }
            })
        }

        function bb(a, b, c, e, f, g, h, i, j, k, l, m) {
            d.call(this, null, g, h, i, j, k, e, f, l, m), this.image = {
                data: a,
                width: b,
                height: c
            }, this.magFilter = void 0 !== j ? j : 1003, this.minFilter = void 0 !== k ? k : 1003, this.generateMipmaps = this.flipY = !1
        }

        function cb(b, c, d) {
            if (this.useVertexTexture = void 0 === d || d, this.identityMatrix = new j, b = b || [], this.bones = b.slice(0), this.useVertexTexture ? (b = Math.sqrt(4 * this.bones.length), b = a.Math.nextPowerOfTwo(Math.ceil(b)), this.boneTextureHeight = this.boneTextureWidth = b = Math.max(b, 4), this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new bb(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, 1023, 1015)) : this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === c) this.calculateInverses();
            else if (this.bones.length === c.length) this.boneInverses = c.slice(0);
            else
                for (console.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [], c = 0, b = this.bones.length; c < b; c++) this.boneInverses.push(new j)
        }

        function db(a) {
            ea.call(this), this.type = "Bone", this.skin = a
        }

        function eb(a, b, c) {
            if (qa.call(this, a, b), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new j, this.bindMatrixInverse = new j, a = [], this.geometry && void 0 !== this.geometry.bones) {
                for (var d, e = 0, f = this.geometry.bones.length; e < f; ++e) d = this.geometry.bones[e], b = new db(this), a.push(b), b.name = d.name, b.position.fromArray(d.pos), b.quaternion.fromArray(d.rotq), void 0 !== d.scl && b.scale.fromArray(d.scl);
                for (e = 0, f = this.geometry.bones.length; e < f; ++e) d = this.geometry.bones[e], -1 !== d.parent && null !== d.parent && void 0 !== a[d.parent] ? a[d.parent].add(a[e]) : this.add(a[e])
            }
            this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new cb(a, void 0, c), this.matrixWorld)
        }

        function fb(a) {
            U.call(this), this.type = "LineBasicMaterial", this.color = new Q(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(a)
        }

        function gb(a, b, c) {
            return 1 === c ? (console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new hb(a, b)) : (ea.call(this), this.type = "Line", this.geometry = void 0 !== a ? a : new pa, void(this.material = void 0 !== b ? b : new fb({
                color: 16777215 * Math.random()
            })))
        }

        function hb(a, b) {
            gb.call(this, a, b), this.type = "LineSegments"
        }

        function ib(a) {
            U.call(this), this.type = "PointsMaterial", this.color = new Q(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = !1, this.setValues(a)
        }

        function jb(a, b) {
            ea.call(this), this.type = "Points", this.geometry = void 0 !== a ? a : new pa, this.material = void 0 !== b ? b : new ib({
                color: 16777215 * Math.random()
            })
        }

        function kb() {
            ea.call(this), this.type = "Group"
        }

        function lb(a, b, c, e, f, g, h, i, j) {
            function k() {
                requestAnimationFrame(k), a.readyState >= a.HAVE_CURRENT_DATA && (l.needsUpdate = !0)
            }
            d.call(this, a, b, c, e, f, g, h, i, j), this.generateMipmaps = !1;
            var l = this;
            k()
        }

        function mb(a, b, c, e, f, g, h, i, j, k, l, m) {
            d.call(this, null, g, h, i, j, k, e, f, l, m), this.image = {
                width: b,
                height: c
            }, this.mipmaps = a, this.generateMipmaps = this.flipY = !1
        }

        function nb(a, b, c, e, f, g, h, i, j) {
            d.call(this, a, b, c, e, f, g, h, i, j), this.needsUpdate = !0
        }

        function ob(a, b, c, e, f, g, h, i, j, k) {
            if (k = void 0 !== k ? k : 1026, 1026 !== k && 1027 !== k) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
            d.call(this, null, e, f, g, h, i, k, c, j), this.image = {
                width: a,
                height: b
            }, this.type = void 0 !== c ? c : 1012, this.magFilter = void 0 !== h ? h : 1003, this.minFilter = void 0 !== i ? i : 1003, this.generateMipmaps = this.flipY = !1
        }

        function pb(a) {
            function b(a, b) {
                return a - b
            }
            pa.call(this);
            var c = [0, 0],
                d = {},
                e = ["a", "b", "c"];
            if (a && a.isGeometry) {
                var f = a.vertices,
                    g = a.faces,
                    h = 0,
                    i = new Uint32Array(6 * g.length);
                a = 0;
                for (var j = g.length; a < j; a++)
                    for (var k = g[a], l = 0; 3 > l; l++) {
                        c[0] = k[e[l]], c[1] = k[e[(l + 1) % 3]], c.sort(b);
                        var m = c.toString();
                        void 0 === d[m] && (i[2 * h] = c[0], i[2 * h + 1] = c[1], d[m] = !0, h++)
                    }
                for (c = new Float32Array(6 * h), a = 0, j = h; a < j; a++)
                    for (l = 0; 2 > l; l++) d = f[i[2 * a + l]], h = 6 * a + 3 * l, c[h + 0] = d.x, c[h + 1] = d.y, c[h + 2] = d.z;
                this.addAttribute("position", new ja(c, 3))
            } else if (a && a.isBufferGeometry) {
                if (null !== a.index) {
                    for (j = a.index.array, f = a.attributes.position, e = a.groups, h = 0, 0 === e.length && a.addGroup(0, j.length), i = new Uint32Array(2 * j.length), g = 0, k = e.length; g < k; ++g) {
                        a = e[g], l = a.start, m = a.count, a = l;
                        for (var n = l + m; a < n; a += 3)
                            for (l = 0; 3 > l; l++) c[0] = j[a + l], c[1] = j[a + (l + 1) % 3], c.sort(b), m = c.toString(), void 0 === d[m] && (i[2 * h] = c[0], i[2 * h + 1] = c[1], d[m] = !0, h++)
                    }
                    for (c = new Float32Array(6 * h), a = 0, j = h; a < j; a++)
                        for (l = 0; 2 > l; l++) h = 6 * a + 3 * l, d = i[2 * a + l], c[h + 0] = f.getX(d), c[h + 1] = f.getY(d), c[h + 2] = f.getZ(d)
                } else
                    for (f = a.attributes.position.array, h = f.length / 3, i = h / 3, c = new Float32Array(6 * h), a = 0, j = i; a < j; a++)
                        for (l = 0; 3 > l; l++) h = 18 * a + 6 * l, i = 9 * a + 3 * l, c[h + 0] = f[i], c[h + 1] = f[i + 1], c[h + 2] = f[i + 2], d = 9 * a + (l + 1) % 3 * 3, c[h + 3] = f[d], c[h + 4] = f[d + 1], c[h + 5] = f[d + 2];
                this.addAttribute("position", new ja(c, 3))
            }
        }

        function qb(a, b, d) {
            na.call(this), this.type = "ParametricGeometry", this.parameters = {
                func: a,
                slices: b,
                stacks: d
            };
            var e, f, g, h, i = this.vertices,
                j = this.faces,
                k = this.faceVertexUvs[0],
                l = b + 1;
            for (e = 0; e <= d; e++)
                for (h = e / d, f = 0; f <= b; f++) g = f / b, g = a(g, h), i.push(g);
            var m, n, o, p;
            for (e = 0; e < d; e++)
                for (f = 0; f < b; f++) a = e * l + f, i = e * l + f + 1, h = (e + 1) * l + f + 1, g = (e + 1) * l + f, m = new c(f / b, e / d), n = new c((f + 1) / b, e / d), o = new c((f + 1) / b, (e + 1) / d), p = new c(f / b, (e + 1) / d), j.push(new ha(a, i, g)), k.push([m, n, p]), j.push(new ha(i, h, g)), k.push([n.clone(), o, p.clone()]);
            this.computeFaceNormals(), this.computeVertexNormals()
        }

        function rb(a, b, d, e) {
            function f(a) {
                var b = a.normalize().clone();
                return b.index = k.vertices.push(b) - 1, b.uv = new c(Math.atan2(a.z, -a.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5)), b
            }

            function g(a, b, c) {
                var d = new ha(a.index, b.index, c.index, [a.clone(), b.clone(), c.clone()]);
                k.faces.push(d), s.copy(a).add(b).add(c).divideScalar(3), d = Math.atan2(s.z, -s.x), k.faceVertexUvs[0].push([j(a.uv, a, d), j(b.uv, b, d), j(c.uv, c, d)])
            }

            function h(a, b) {
                for (var c = Math.pow(2, b), d = f(k.vertices[a.a]), e = f(k.vertices[a.b]), h = f(k.vertices[a.c]), i = [], j = 0; j <= c; j++) {
                    i[j] = [];
                    for (var l = f(d.clone().lerp(h, j / c)), m = f(e.clone().lerp(h, j / c)), n = c - j, o = 0; o <= n; o++) i[j][o] = 0 === o && j === c ? l : f(l.clone().lerp(m, o / n))
                }
                for (j = 0; j < c; j++)
                    for (o = 0; o < 2 * (c - j) - 1; o++) d = Math.floor(o / 2), 0 === o % 2 ? g(i[j][d + 1], i[j + 1][d], i[j][d]) : g(i[j][d + 1], i[j + 1][d + 1], i[j + 1][d])
            }

            function j(a, b, d) {
                return 0 > d && 1 === a.x && (a = new c(a.x - 1, a.y)), 0 === b.x && 0 === b.z && (a = new c(d / 2 / Math.PI + .5, a.y)), a.clone()
            }
            na.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                vertices: a,
                indices: b,
                radius: d,
                detail: e
            }, d = d || 1, e = e || 0;
            for (var k = this, l = 0, m = a.length; l < m; l += 3) f(new i(a[l], a[l + 1], a[l + 2]));
            a = this.vertices;
            for (var n = [], o = l = 0, m = b.length; l < m; l += 3, o++) {
                var p = a[b[l]],
                    q = a[b[l + 1]],
                    r = a[b[l + 2]];
                n[o] = new ha(p.index, q.index, r.index, [p.clone(), q.clone(), r.clone()])
            }
            for (var s = new i, l = 0, m = n.length; l < m; l++) h(n[l], e);
            for (l = 0, m = this.faceVertexUvs[0].length; l < m; l++) b = this.faceVertexUvs[0][l], e = b[0].x, a = b[1].x, n = b[2].x, o = Math.min(e, a, n), .9 < Math.max(e, a, n) && .1 > o && (.2 > e && (b[0].x += 1), .2 > a && (b[1].x += 1), .2 > n && (b[2].x += 1));
            for (l = 0, m = this.vertices.length; l < m; l++) this.vertices[l].multiplyScalar(d);
            this.mergeVertices(), this.computeFaceNormals(), this.boundingSphere = new Y(new i, d)
        }

        function sb(a, b) {
            rb.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b), this.type = "TetrahedronGeometry", this.parameters = {
                radius: a,
                detail: b
            }
        }

        function tb(a, b) {
            rb.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], a, b), this.type = "OctahedronGeometry", this.parameters = {
                radius: a,
                detail: b
            }
        }

        function ub(a, b) {
            var c = (1 + Math.sqrt(5)) / 2;
            rb.call(this, [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a, b), this.type = "IcosahedronGeometry", this.parameters = {
                radius: a,
                detail: b
            }
        }

        function vb(a, b) {
            var c = (1 + Math.sqrt(5)) / 2,
                d = 1 / c;
            rb.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], a, b), this.type = "DodecahedronGeometry", this.parameters = {
                radius: a,
                detail: b
            }
        }

        function wb(a, b, d, e, f, g) {
            na.call(this), this.type = "TubeGeometry", this.parameters = {
                path: a,
                segments: b,
                radius: d,
                radialSegments: e,
                closed: f,
                taper: g
            }, b = b || 64, d = d || 1, e = e || 8, f = f || !1, g = g || wb.NoTaper;
            var h, j, k, l, m, n, o, p, q, r, s = [],
                t = b + 1,
                u = new i;
            for (p = new wb.FrenetFrames(a, b, f), q = p.normals, r = p.binormals, this.tangents = p.tangents, this.normals = q, this.binormals = r, p = 0; p < t; p++)
                for (s[p] = [], k = p / (t - 1), o = a.getPointAt(k), h = q[p], j = r[p], m = d * g(k), k = 0; k < e; k++) l = k / e * 2 * Math.PI, n = -m * Math.cos(l), l = m * Math.sin(l), u.copy(o), u.x += n * h.x + l * j.x, u.y += n * h.y + l * j.y, u.z += n * h.z + l * j.z, s[p][k] = this.vertices.push(new i(u.x, u.y, u.z)) - 1;
            for (p = 0; p < b; p++)
                for (k = 0; k < e; k++) g = f ? (p + 1) % b : p + 1, t = (k + 1) % e, a = s[p][k], d = s[g][k], g = s[g][t], t = s[p][t], u = new c(p / b, k / e), q = new c((p + 1) / b, k / e), r = new c((p + 1) / b, (k + 1) / e), h = new c(p / b, (k + 1) / e), this.faces.push(new ha(a, d, t)), this.faceVertexUvs[0].push([u, q, h]), this.faces.push(new ha(d, g, t)), this.faceVertexUvs[0].push([q.clone(), r, h.clone()]);
            this.computeFaceNormals(), this.computeVertexNormals()
        }

        function xb(a, b, d, e, f, g) {
            function h(a, b, c, d, e) {
                var f = Math.sin(a);
                b = c / b * a, c = Math.cos(b), e.x = d * (2 + c) * .5 * Math.cos(a), e.y = d * (2 + c) * f * .5, e.z = d * Math.sin(b) * .5
            }
            pa.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                radius: a,
                tube: b,
                tubularSegments: d,
                radialSegments: e,
                p: f,
                q: g
            }, a = a || 100, b = b || 40, d = Math.floor(d) || 64, e = Math.floor(e) || 8, f = f || 2, g = g || 3;
            var j, k, l = (e + 1) * (d + 1),
                m = e * d * 6,
                m = new ja(new(65535 < m ? Uint32Array : Uint16Array)(m), 1),
                n = new ja(new Float32Array(3 * l), 3),
                o = new ja(new Float32Array(3 * l), 3),
                l = new ja(new Float32Array(2 * l), 2),
                p = 0,
                q = 0,
                r = new i,
                s = new i,
                t = new c,
                u = new i,
                v = new i,
                w = new i,
                x = new i,
                y = new i;
            for (j = 0; j <= d; ++j)
                for (k = j / d * f * Math.PI * 2, h(k, f, g, a, u), h(k + .01, f, g, a, v), x.subVectors(v, u), y.addVectors(v, u), w.crossVectors(x, y), y.crossVectors(w, x), w.normalize(), y.normalize(), k = 0; k <= e; ++k) {
                    var z = k / e * Math.PI * 2,
                        A = -b * Math.cos(z),
                        z = b * Math.sin(z);
                    r.x = u.x + (A * y.x + z * w.x), r.y = u.y + (A * y.y + z * w.y), r.z = u.z + (A * y.z + z * w.z), n.setXYZ(p, r.x, r.y, r.z), s.subVectors(r, u).normalize(), o.setXYZ(p, s.x, s.y, s.z), t.x = j / d, t.y = k / e, l.setXY(p, t.x, t.y), p++
                }
            for (k = 1; k <= d; k++)
                for (j = 1; j <= e; j++) a = (e + 1) * k + (j - 1), b = (e + 1) * k + j, f = (e + 1) * (k - 1) + j, m.setX(q, (e + 1) * (k - 1) + (j - 1)), q++, m.setX(q, a), q++, m.setX(q, f), q++, m.setX(q, a), q++, m.setX(q, b), q++, m.setX(q, f), q++;
            this.setIndex(m), this.addAttribute("position", n), this.addAttribute("normal", o), this.addAttribute("uv", l)
        }

        function yb(a, b, c, d, e, f, g) {
            na.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                radius: a,
                tube: b,
                tubularSegments: c,
                radialSegments: d,
                p: e,
                q: f
            }, void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new xb(a, b, c, d, e, f)), this.mergeVertices()
        }

        function zb(a, b, c, d, e) {
            pa.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                radius: a,
                tube: b,
                radialSegments: c,
                tubularSegments: d,
                arc: e
            }, a = a || 100, b = b || 40, c = Math.floor(c) || 8, d = Math.floor(d) || 6, e = e || 2 * Math.PI;
            var f, g, h = (c + 1) * (d + 1),
                j = c * d * 6,
                j = new(65535 < j ? Uint32Array : Uint16Array)(j),
                k = new Float32Array(3 * h),
                l = new Float32Array(3 * h),
                h = new Float32Array(2 * h),
                m = 0,
                n = 0,
                o = 0,
                p = new i,
                q = new i,
                r = new i;
            for (f = 0; f <= c; f++)
                for (g = 0; g <= d; g++) {
                    var s = g / d * e,
                        t = f / c * Math.PI * 2;
                    q.x = (a + b * Math.cos(t)) * Math.cos(s), q.y = (a + b * Math.cos(t)) * Math.sin(s), q.z = b * Math.sin(t), k[m] = q.x, k[m + 1] = q.y, k[m + 2] = q.z, p.x = a * Math.cos(s), p.y = a * Math.sin(s), r.subVectors(q, p).normalize(), l[m] = r.x, l[m + 1] = r.y, l[m + 2] = r.z, h[n] = g / d, h[n + 1] = f / c, m += 3, n += 2
                }
            for (f = 1; f <= c; f++)
                for (g = 1; g <= d; g++) a = (d + 1) * (f - 1) + g - 1, b = (d + 1) * (f - 1) + g, e = (d + 1) * f + g, j[o] = (d + 1) * f + g - 1, j[o + 1] = a, j[o + 2] = e, j[o + 3] = a, j[o + 4] = b, j[o + 5] = e, o += 6;
            this.setIndex(new ja(j, 1)), this.addAttribute("position", new ja(k, 3)), this.addAttribute("normal", new ja(l, 3)), this.addAttribute("uv", new ja(h, 2))
        }

        function Ab(a, b, c, d, e) {
            na.call(this), this.type = "TorusGeometry", this.parameters = {
                radius: a,
                tube: b,
                radialSegments: c,
                tubularSegments: d,
                arc: e
            }, this.fromBufferGeometry(new zb(a, b, c, d, e))
        }

        function Bb(a, b) {
            "undefined" != typeof a && (na.call(this), this.type = "ExtrudeGeometry", a = Array.isArray(a) ? a : [a], this.addShapeList(a, b), this.computeFaceNormals())
        }

        function Cb(a, b) {
            b = b || {};
            var c = b.font;
            return !1 === (c && c.isFont) ? (console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new na) : (c = c.generateShapes(a, b.size, b.curveSegments), b.amount = void 0 !== b.height ? b.height : 50, void 0 === b.bevelThickness && (b.bevelThickness = 10), void 0 === b.bevelSize && (b.bevelSize = 8), void 0 === b.bevelEnabled && (b.bevelEnabled = !1), Bb.call(this, c, b), void(this.type = "TextGeometry"))
        }

        function Db(a, b, c, d, e, f, g) {
            pa.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                radius: a,
                widthSegments: b,
                heightSegments: c,
                phiStart: d,
                phiLength: e,
                thetaStart: f,
                thetaLength: g
            }, a = a || 50, b = Math.max(3, Math.floor(b) || 8), c = Math.max(2, Math.floor(c) || 6), d = void 0 !== d ? d : 0, e = void 0 !== e ? e : 2 * Math.PI, f = void 0 !== f ? f : 0, g = void 0 !== g ? g : Math.PI;
            for (var h = f + g, j = (b + 1) * (c + 1), k = new ja(new Float32Array(3 * j), 3), l = new ja(new Float32Array(3 * j), 3), j = new ja(new Float32Array(2 * j), 2), m = 0, n = [], o = new i, p = 0; p <= c; p++) {
                for (var q = [], r = p / c, s = 0; s <= b; s++) {
                    var t = s / b,
                        u = -a * Math.cos(d + t * e) * Math.sin(f + r * g),
                        v = a * Math.cos(f + r * g),
                        w = a * Math.sin(d + t * e) * Math.sin(f + r * g);
                    o.set(u, v, w).normalize(), k.setXYZ(m, u, v, w), l.setXYZ(m, o.x, o.y, o.z), j.setXY(m, t, 1 - r), q.push(m), m++
                }
                n.push(q)
            }
            for (d = [], p = 0; p < c; p++)
                for (s = 0; s < b; s++) e = n[p][s + 1], g = n[p][s], m = n[p + 1][s], o = n[p + 1][s + 1], (0 !== p || 0 < f) && d.push(e, g, o), (p !== c - 1 || h < Math.PI) && d.push(g, m, o);
            this.setIndex(new(65535 < k.count ? la : ka)(d, 1)), this.addAttribute("position", k), this.addAttribute("normal", l), this.addAttribute("uv", j), this.boundingSphere = new Y(new i, a)
        }

        function Eb(a, b, c, d, e, f, g) {
            na.call(this), this.type = "SphereGeometry", this.parameters = {
                radius: a,
                widthSegments: b,
                heightSegments: c,
                phiStart: d,
                phiLength: e,
                thetaStart: f,
                thetaLength: g
            }, this.fromBufferGeometry(new Db(a, b, c, d, e, f, g))
        }

        function Fb(a, b, d, e, f, g) {
            pa.call(this), this.type = "RingBufferGeometry", this.parameters = {
                innerRadius: a,
                outerRadius: b,
                thetaSegments: d,
                phiSegments: e,
                thetaStart: f,
                thetaLength: g
            }, a = a || 20, b = b || 50, f = void 0 !== f ? f : 0, g = void 0 !== g ? g : 2 * Math.PI, d = void 0 !== d ? Math.max(3, d) : 8, e = void 0 !== e ? Math.max(1, e) : 1;
            var h, j, k = (d + 1) * (e + 1),
                l = d * e * 6,
                l = new ja(new(65535 < l ? Uint32Array : Uint16Array)(l), 1),
                m = new ja(new Float32Array(3 * k), 3),
                n = new ja(new Float32Array(3 * k), 3),
                k = new ja(new Float32Array(2 * k), 2),
                o = 0,
                p = 0,
                q = a,
                r = (b - a) / e,
                s = new i,
                t = new c;
            for (a = 0; a <= e; a++) {
                for (j = 0; j <= d; j++) h = f + j / d * g, s.x = q * Math.cos(h), s.y = q * Math.sin(h), m.setXYZ(o, s.x, s.y, s.z), n.setXYZ(o, 0, 0, 1), t.x = (s.x / b + 1) / 2, t.y = (s.y / b + 1) / 2, k.setXY(o, t.x, t.y), o++;
                q += r
            }
            for (a = 0; a < e; a++)
                for (b = a * (d + 1), j = 0; j < d; j++) f = h = j + b, g = h + d + 1, o = h + d + 2, h += 1, l.setX(p, f), p++, l.setX(p, g), p++, l.setX(p, o), p++, l.setX(p, f), p++, l.setX(p, o), p++, l.setX(p, h), p++;
            this.setIndex(l), this.addAttribute("position", m), this.addAttribute("normal", n), this.addAttribute("uv", k)
        }

        function Gb(a, b, c, d, e, f) {
            na.call(this), this.type = "RingGeometry", this.parameters = {
                innerRadius: a,
                outerRadius: b,
                thetaSegments: c,
                phiSegments: d,
                thetaStart: e,
                thetaLength: f
            }, this.fromBufferGeometry(new Fb(a, b, c, d, e, f))
        }

        function Hb(a, b, c, d) {
            na.call(this), this.type = "PlaneGeometry", this.parameters = {
                width: a,
                height: b,
                widthSegments: c,
                heightSegments: d
            }, this.fromBufferGeometry(new sa(a, b, c, d))
        }

        function Ib(b, d, e, f) {
            pa.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                points: b,
                segments: d,
                phiStart: e,
                phiLength: f
            }, d = Math.floor(d) || 12, e = e || 0, f = f || 2 * Math.PI, f = a.Math.clamp(f, 0, 2 * Math.PI);
            for (var g = (d + 1) * b.length, h = d * b.length * 6, j = new ja(new(65535 < h ? Uint32Array : Uint16Array)(h), 1), k = new ja(new Float32Array(3 * g), 3), l = new ja(new Float32Array(2 * g), 2), m = 0, n = 0, o = 1 / d, p = new i, q = new c, g = 0; g <= d; g++)
                for (var h = e + g * o * f, r = Math.sin(h), s = Math.cos(h), h = 0; h <= b.length - 1; h++) p.x = b[h].x * r, p.y = b[h].y, p.z = b[h].x * s, k.setXYZ(m, p.x, p.y, p.z), q.x = g / d, q.y = h / (b.length - 1), l.setXY(m, q.x, q.y), m++;
            for (g = 0; g < d; g++)
                for (h = 0; h < b.length - 1; h++) e = h + g * b.length, m = e + b.length, o = e + b.length + 1, p = e + 1, j.setX(n, e), n++, j.setX(n, m), n++, j.setX(n, p), n++, j.setX(n, m), n++, j.setX(n, o), n++, j.setX(n, p), n++;
            if (this.setIndex(j), this.addAttribute("position", k), this.addAttribute("uv", l), this.computeVertexNormals(), f === 2 * Math.PI)
                for (f = this.attributes.normal.array, j = new i, k = new i, l = new i, e = d * b.length * 3, h = g = 0; g < b.length; g++, h += 3) j.x = f[h + 0], j.y = f[h + 1], j.z = f[h + 2], k.x = f[e + h + 0], k.y = f[e + h + 1], k.z = f[e + h + 2], l.addVectors(j, k).normalize(), f[h + 0] = f[e + h + 0] = l.x, f[h + 1] = f[e + h + 1] = l.y, f[h + 2] = f[e + h + 2] = l.z
        }

        function Jb(a, b, c, d) {
            na.call(this), this.type = "LatheGeometry", this.parameters = {
                points: a,
                segments: b,
                phiStart: c,
                phiLength: d
            }, this.fromBufferGeometry(new Ib(a, b, c, d)), this.mergeVertices()
        }

        function Kb(a, b) {
            na.call(this), this.type = "ShapeGeometry", !1 === Array.isArray(a) && (a = [a]), this.addShapeList(a, b), this.computeFaceNormals()
        }

        function Lb(b, c) {
            function d(a, b) {
                return a - b
            }
            pa.call(this);
            var e, f = Math.cos(a.Math.DEG2RAD * (void 0 !== c ? c : 1)),
                g = [0, 0],
                h = {},
                i = ["a", "b", "c"];
            b && b.isBufferGeometry ? (e = new na, e.fromBufferGeometry(b)) : e = b.clone(), e.mergeVertices(), e.computeFaceNormals();
            var j = e.vertices;
            e = e.faces;
            for (var k = 0, l = e.length; k < l; k++)
                for (var m = e[k], n = 0; 3 > n; n++) {
                    g[0] = m[i[n]], g[1] = m[i[(n + 1) % 3]], g.sort(d);
                    var o = g.toString();
                    void 0 === h[o] ? h[o] = {
                        vert1: g[0],
                        vert2: g[1],
                        face1: k,
                        face2: void 0
                    } : h[o].face2 = k
                }
            g = [];
            for (o in h) i = h[o], (void 0 === i.face2 || e[i.face1].normal.dot(e[i.face2].normal) <= f) && (k = j[i.vert1], g.push(k.x), g.push(k.y), g.push(k.z), k = j[i.vert2], g.push(k.x), g.push(k.y), g.push(k.z));
            this.addAttribute("position", new ja(new Float32Array(g), 3))
        }

        function Mb(a, b, d, e, f, g, h, j) {
            function k(d) {
                var f, g, k, m = new c,
                    n = new i,
                    o = 0,
                    v = !0 === d ? a : b,
                    y = !0 === d ? 1 : -1;
                for (g = t, f = 1; f <= e; f++) q.setXYZ(t, 0, w * y, 0), r.setXYZ(t, 0, y, 0), m.x = .5, m.y = .5, s.setXY(t, m.x, m.y), t++;
                for (k = t, f = 0; f <= e; f++) {
                    var z = f / e * j + h,
                        A = Math.cos(z),
                        z = Math.sin(z);
                    n.x = v * z, n.y = w * y, n.z = v * A, q.setXYZ(t, n.x, n.y, n.z), r.setXYZ(t, 0, y, 0), m.x = .5 * A + .5, m.y = .5 * z * y + .5, s.setXY(t, m.x, m.y), t++
                }
                for (f = 0; f < e; f++) m = g + f, n = k + f, !0 === d ? (p.setX(u, n), u++, p.setX(u, n + 1)) : (p.setX(u, n + 1), u++, p.setX(u, n)), u++, p.setX(u, m), u++, o += 3;
                l.addGroup(x, o, !0 === d ? 1 : 2), x += o
            }
            pa.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                radiusTop: a,
                radiusBottom: b,
                height: d,
                radialSegments: e,
                heightSegments: f,
                openEnded: g,
                thetaStart: h,
                thetaLength: j
            };
            var l = this;
            a = void 0 !== a ? a : 20, b = void 0 !== b ? b : 20, d = void 0 !== d ? d : 100, e = Math.floor(e) || 8, f = Math.floor(f) || 1, g = void 0 !== g && g, h = void 0 !== h ? h : 0, j = void 0 !== j ? j : 2 * Math.PI;
            var m = 0;
            !1 === g && (0 < a && m++, 0 < b && m++);
            var n = function() {
                    var a = (e + 1) * (f + 1);
                    return !1 === g && (a += (e + 1) * m + e * m), a
                }(),
                o = function() {
                    var a = e * f * 6;
                    return !1 === g && (a += e * m * 3), a
                }(),
                p = new ja(new(65535 < o ? Uint32Array : Uint16Array)(o), 1),
                q = new ja(new Float32Array(3 * n), 3),
                r = new ja(new Float32Array(3 * n), 3),
                s = new ja(new Float32Array(2 * n), 2),
                t = 0,
                u = 0,
                v = [],
                w = d / 2,
                x = 0;
            ! function() {
                var c, g, k = new i,
                    m = new i,
                    n = 0,
                    o = (b - a) / d;
                for (g = 0; g <= f; g++) {
                    var y = [],
                        z = g / f,
                        A = z * (b - a) + a;
                    for (c = 0; c <= e; c++) {
                        var B = c / e,
                            C = B * j + h,
                            D = Math.sin(C),
                            C = Math.cos(C);
                        m.x = A * D, m.y = -z * d + w, m.z = A * C, q.setXYZ(t, m.x, m.y, m.z), k.set(D, o, C).normalize(), r.setXYZ(t, k.x, k.y, k.z), s.setXY(t, B, 1 - z), y.push(t), t++
                    }
                    v.push(y)
                }
                for (c = 0; c < e; c++)
                    for (g = 0; g < f; g++) k = v[g + 1][c], m = v[g + 1][c + 1], o = v[g][c + 1], p.setX(u, v[g][c]), u++, p.setX(u, k), u++, p.setX(u, o), u++, p.setX(u, k), u++, p.setX(u, m), u++, p.setX(u, o), u++, n += 6;
                l.addGroup(x, n, 0), x += n
            }(), !1 === g && (0 < a && k(!0), 0 < b && k(!1)), this.setIndex(p), this.addAttribute("position", q), this.addAttribute("normal", r), this.addAttribute("uv", s)
        }

        function Nb(a, b, c, d, e, f, g, h) {
            na.call(this), this.type = "CylinderGeometry", this.parameters = {
                radiusTop: a,
                radiusBottom: b,
                height: c,
                radialSegments: d,
                heightSegments: e,
                openEnded: f,
                thetaStart: g,
                thetaLength: h
            }, this.fromBufferGeometry(new Mb(a, b, c, d, e, f, g, h)), this.mergeVertices()
        }

        function Ob(a, b, c, d, e, f, g) {
            Nb.call(this, 0, a, b, c, d, e, f, g), this.type = "ConeGeometry", this.parameters = {
                radius: a,
                height: b,
                radialSegments: c,
                heightSegments: d,
                openEnded: e,
                thetaStart: f,
                thetaLength: g
            }
        }

        function Pb(a, b, c, d, e, f, g) {
            Mb.call(this, 0, a, b, c, d, e, f, g), this.type = "ConeBufferGeometry", this.parameters = {
                radius: a,
                height: b,
                radialSegments: c,
                heightSegments: d,
                thetaStart: f,
                thetaLength: g
            }
        }

        function Qb(a, b, c, d) {
            pa.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                radius: a,
                segments: b,
                thetaStart: c,
                thetaLength: d
            }, a = a || 50, b = void 0 !== b ? Math.max(3, b) : 8, c = void 0 !== c ? c : 0, d = void 0 !== d ? d : 2 * Math.PI;
            var e = b + 2,
                f = new Float32Array(3 * e),
                g = new Float32Array(3 * e),
                e = new Float32Array(2 * e);
            g[2] = 1, e[0] = .5, e[1] = .5;
            for (var h = 0, j = 3, k = 2; h <= b; h++, j += 3, k += 2) {
                var l = c + h / b * d;
                f[j] = a * Math.cos(l), f[j + 1] = a * Math.sin(l), g[j + 2] = 1, e[k] = (f[j] / a + 1) / 2, e[k + 1] = (f[j + 1] / a + 1) / 2
            }
            for (c = [], j = 1; j <= b; j++) c.push(j, j + 1, 0);
            this.setIndex(new ja(new Uint16Array(c), 1)), this.addAttribute("position", new ja(f, 3)), this.addAttribute("normal", new ja(g, 3)), this.addAttribute("uv", new ja(e, 2)), this.boundingSphere = new Y(new i, a)
        }

        function Rb(a, b, c, d) {
            na.call(this), this.type = "CircleGeometry", this.parameters = {
                radius: a,
                segments: b,
                thetaStart: c,
                thetaLength: d
            }, this.fromBufferGeometry(new Qb(a, b, c, d))
        }

        function Sb(a, b, c, d, e, f) {
            na.call(this), this.type = "BoxGeometry", this.parameters = {
                width: a,
                height: b,
                depth: c,
                widthSegments: d,
                heightSegments: e,
                depthSegments: f
            }, this.fromBufferGeometry(new ra(a, b, c, d, e, f)), this.mergeVertices()
        }

        function Tb() {
            V.call(this, {
                uniforms: a.UniformsUtils.merge([Td.lights, {
                    opacity: {
                        value: 1
                    }
                }]),
                vertexShader: Sd.shadow_vert,
                fragmentShader: Sd.shadow_frag
            }), this.transparent = this.lights = !0, Object.defineProperties(this, {
                opacity: {
                    enumerable: !0,
                    get: function() {
                        return this.uniforms.opacity.value
                    },
                    set: function(a) {
                        this.uniforms.opacity.value = a
                    }
                }
            })
        }

        function Ub(a) {
            V.call(this, a), this.type = "RawShaderMaterial"
        }

        function Vb(b) {
            this.uuid = a.Math.generateUUID(), this.type = "MultiMaterial", this.materials = b instanceof Array ? b : [], this.visible = !0
        }

        function Wb(a) {
            U.call(this), this.defines = {
                STANDARD: ""
            }, this.type = "MeshStandardMaterial", this.color = new Q(16777215), this.metalness = this.roughness = .5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Q(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new c(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a)
        }

        function Xb(a) {
            Wb.call(this), this.defines = {
                PHYSICAL: ""
            }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(a)
        }

        function Yb(a) {
            U.call(this), this.type = "MeshPhongMaterial", this.color = new Q(16777215), this.specular = new Q(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Q(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new c(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a)
        }

        function Zb(a) {
            U.call(this, a), this.type = "MeshNormalMaterial", this.wireframe = !1, this.wireframeLinewidth = 1, this.morphTargets = this.lights = this.fog = !1, this.setValues(a)
        }

        function $b(a) {
            U.call(this), this.type = "MeshLambertMaterial", this.color = new Q(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Q(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(a)
        }

        function _b(a) {
            U.call(this), this.type = "LineDashedMaterial", this.color = new Q(16777215), this.scale = this.linewidth = 1, this.dashSize = 3, this.gapSize = 1, this.lights = !1, this.setValues(a)
        }

        function ac(a, b, c) {
            var d = this,
                e = !1,
                f = 0,
                g = 0;
            this.onStart = void 0, this.onLoad = a, this.onProgress = b, this.onError = c, this.itemStart = function(a) {
                g++, !1 === e && void 0 !== d.onStart && d.onStart(a, f, g), e = !0
            }, this.itemEnd = function(a) {
                f++, void 0 !== d.onProgress && d.onProgress(a, f, g), f === g && (e = !1, void 0 !== d.onLoad) && d.onLoad()
            }, this.itemError = function(a) {
                void 0 !== d.onError && d.onError(a)
            }
        }

        function bc(b) {
            this.manager = void 0 !== b ? b : a.DefaultLoadingManager
        }

        function cc(b) {
            this.manager = void 0 !== b ? b : a.DefaultLoadingManager, this._parser = null
        }

        function dc(b) {
            this.manager = void 0 !== b ? b : a.DefaultLoadingManager, this._parser = null
        }

        function ec(b) {
            this.manager = void 0 !== b ? b : a.DefaultLoadingManager
        }

        function fc(b) {
            this.manager = void 0 !== b ? b : a.DefaultLoadingManager
        }

        function gc(b) {
            this.manager = void 0 !== b ? b : a.DefaultLoadingManager
        }

        function hc(a, b) {
            ea.call(this), this.type = "Light", this.color = new Q(a), this.intensity = void 0 !== b ? b : 1, this.receiveShadow = void 0
        }

        function ic(a, b, c) {
            hc.call(this, a, c), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(ea.DefaultUp), this.updateMatrix(), this.groundColor = new Q(b)
        }

        function jc(a) {
            this.camera = a, this.bias = 0, this.radius = 1, this.mapSize = new c(512, 512), this.map = null, this.matrix = new j
        }

        function kc() {
            jc.call(this, new ua(50, 1, .5, 500))
        }

        function lc(a, b, c, d, e, f) {
            hc.call(this, a, b), this.type = "SpotLight", this.position.copy(ea.DefaultUp), this.updateMatrix(), this.target = new ea, Object.defineProperty(this, "power", {
                get: function() {
                    return this.intensity * Math.PI
                },
                set: function(a) {
                    this.intensity = a / Math.PI
                }
            }), this.distance = void 0 !== c ? c : 0, this.angle = void 0 !== d ? d : Math.PI / 3, this.penumbra = void 0 !== e ? e : 0, this.decay = void 0 !== f ? f : 1, this.shadow = new kc
        }

        function mc(a, b, c, d) {
            hc.call(this, a, b), this.type = "PointLight", Object.defineProperty(this, "power", {
                get: function() {
                    return 4 * this.intensity * Math.PI
                },
                set: function(a) {
                    this.intensity = a / (4 * Math.PI)
                }
            }), this.distance = void 0 !== c ? c : 0, this.decay = void 0 !== d ? d : 1, this.shadow = new jc(new ua(90, 1, .5, 500))
        }

        function nc(a) {
            jc.call(this, new va(-5, 5, 5, -5, .5, 500))
        }

        function oc(a, b) {
            hc.call(this, a, b), this.type = "DirectionalLight", this.position.copy(ea.DefaultUp), this.updateMatrix(), this.target = new ea, this.shadow = new nc
        }

        function pc(a, b) {
            hc.call(this, a, b), this.type = "AmbientLight", this.castShadow = void 0
        }

        function qc(a, b, c, d) {
            this.parameterPositions = a, this._cachedIndex = 0, this.resultBuffer = void 0 !== d ? d : new b.constructor(c), this.sampleValues = b, this.valueSize = c
        }

        function rc(a, b, c, d) {
            qc.call(this, a, b, c, d), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
        }

        function sc(a, b, c, d) {
            qc.call(this, a, b, c, d)
        }

        function tc(a, b, c, d) {
            qc.call(this, a, b, c, d)
        }

        function uc(b, c, d, e) {
            if (void 0 === b) throw Error("track name is undefined");
            if (void 0 === c || 0 === c.length) throw Error("no keyframes in track named " + b);
            this.name = b, this.times = a.AnimationUtils.convertArray(c, this.TimeBufferType), this.values = a.AnimationUtils.convertArray(d, this.ValueBufferType), this.setInterpolation(e || this.DefaultInterpolation), this.validate(), this.optimize()
        }

        function vc(a, b, c, d) {
            uc.call(this, a, b, c, d)
        }

        function wc(a, b, c, d) {
            qc.call(this, a, b, c, d)
        }

        function xc(a, b, c, d) {
            uc.call(this, a, b, c, d)
        }

        function yc(a, b, c, d) {
            uc.call(this, a, b, c, d)
        }

        function zc(a, b, c, d) {
            uc.call(this, a, b, c, d)
        }

        function Ac(a, b, c) {
            uc.call(this, a, b, c)
        }

        function Bc(a, b, c, d) {
            uc.call(this, a, b, c, d)
        }

        function Cc(a, b, c, d) {
            uc.apply(this, arguments)
        }

        function Dc(b, c, d) {
            this.name = b, this.tracks = d, this.duration = void 0 !== c ? c : -1, this.uuid = a.Math.generateUUID(), 0 > this.duration && this.resetDuration(), this.optimize()
        }

        function Ec(b) {
            this.manager = void 0 !== b ? b : a.DefaultLoadingManager, this.textures = {}
        }

        function Fc(b) {
            this.manager = void 0 !== b ? b : a.DefaultLoadingManager
        }

        function Gc() {
            this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
        }

        function Hc(b) {
            "boolean" == typeof b && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), b = void 0), this.manager = void 0 !== b ? b : a.DefaultLoadingManager, this.withCredentials = !1
        }

        function Ic(b) {
            this.manager = void 0 !== b ? b : a.DefaultLoadingManager, this.texturePath = ""
        }

        function Jc() {}

        function Kc(a, b) {
            this.v1 = a, this.v2 = b
        }

        function Lc() {
            this.curves = [], this.autoClose = !1
        }

        function Mc(a, b, c, d, e, f, g, h) {
            this.aX = a, this.aY = b, this.xRadius = c, this.yRadius = d, this.aStartAngle = e, this.aEndAngle = f, this.aClockwise = g, this.aRotation = h || 0
        }

        function Nc(a) {
            this.points = void 0 === a ? [] : a
        }

        function Oc(a, b, c, d) {
            this.v0 = a, this.v1 = b, this.v2 = c, this.v3 = d
        }

        function Pc(a, b, c) {
            this.v0 = a, this.v1 = b, this.v2 = c
        }

        function Qc() {
            Rc.apply(this, arguments), this.holes = []
        }

        function Rc(a) {
            Lc.call(this), this.currentPoint = new c, a && this.fromPoints(a)
        }

        function Sc() {
            this.subPaths = [], this.currentPath = null
        }

        function Tc(a) {
            this.data = a
        }

        function Uc(b) {
            this.manager = void 0 !== b ? b : a.DefaultLoadingManager
        }

        function Vc() {
            return void 0 === be && (be = new(window.AudioContext || window.webkitAudioContext)), be
        }

        function Wc(b) {
            this.manager = void 0 !== b ? b : a.DefaultLoadingManager
        }

        function Xc() {
            this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new ua, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ua, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
        }

        function Yc(a, b, c) {
            ea.call(this), this.type = "CubeCamera";
            var d = new ua(90, 1, a, b);
            d.up.set(0, -1, 0), d.lookAt(new i(1, 0, 0)), this.add(d);
            var e = new ua(90, 1, a, b);
            e.up.set(0, -1, 0), e.lookAt(new i(-1, 0, 0)), this.add(e);
            var f = new ua(90, 1, a, b);
            f.up.set(0, 0, 1), f.lookAt(new i(0, 1, 0)), this.add(f);
            var h = new ua(90, 1, a, b);
            h.up.set(0, 0, -1), h.lookAt(new i(0, -1, 0)), this.add(h);
            var j = new ua(90, 1, a, b);
            j.up.set(0, -1, 0), j.lookAt(new i(0, 0, 1)), this.add(j);
            var k = new ua(90, 1, a, b);
            k.up.set(0, -1, 0), k.lookAt(new i(0, 0, -1)), this.add(k), this.renderTarget = new g(c, c, {
                format: 1022,
                magFilter: 1006,
                minFilter: 1006
            }), this.updateCubeMap = function(a, b) {
                null === this.parent && this.updateMatrixWorld();
                var c = this.renderTarget,
                    g = c.texture.generateMipmaps;
                c.texture.generateMipmaps = !1, c.activeCubeFace = 0, a.render(b, d, c), c.activeCubeFace = 1, a.render(b, e, c), c.activeCubeFace = 2, a.render(b, f, c), c.activeCubeFace = 3, a.render(b, h, c), c.activeCubeFace = 4, a.render(b, j, c), c.texture.generateMipmaps = g,
                    c.activeCubeFace = 5, a.render(b, k, c), a.setRenderTarget(null)
            }
        }

        function Zc() {
            ea.call(this), this.type = "AudioListener", this.context = Vc(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
        }

        function $c(a) {
            ea.call(this), this.type = "Audio", this.context = a.context, this.source = this.context.createBufferSource(), this.source.onended = this.onEnded.bind(this), this.gain = this.context.createGain(), this.gain.connect(a.getInput()), this.autoplay = !1, this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
        }

        function _c(a) {
            $c.call(this, a), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
        }

        function ad(a, b) {
            this.analyser = a.context.createAnalyser(), this.analyser.fftSize = void 0 !== b ? b : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), a.getOutput().connect(this.analyser)
        }

        function bd(a, b, c) {
            switch (this.binding = a, this.valueSize = c, a = Float64Array, b) {
                case "quaternion":
                    b = this._slerp;
                    break;
                case "string":
                case "bool":
                    a = Array, b = this._select;
                    break;
                default:
                    b = this._lerp
            }
            this.buffer = new a(4 * c), this._mixBufferRegion = b, this.referenceCount = this.useCount = this.cumulativeWeight = 0
        }

        function cd(a, b, c) {
            this.path = b, this.parsedPath = c || cd.parseTrackName(b), this.node = cd.findNode(a, this.parsedPath.nodeName) || a, this.rootNode = a
        }

        function dd(b) {
            this.uuid = a.Math.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
            var c = {};
            this._indicesByUUID = c;
            for (var d = 0, e = arguments.length; d !== e; ++d) c[arguments[d].uuid] = d;
            this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
            var f = this;
            this.stats = {
                objects: {
                    get total() {
                        return f._objects.length
                    },
                    get inUse() {
                        return this.total - f.nCachedObjects_
                    }
                },
                get bindingsPerObject() {
                    return f._bindings.length
                }
            }
        }

        function ed(a, b, c) {
            this._mixer = a, this._clip = b, this._localRoot = c || null, a = b.tracks, b = a.length, c = Array(b);
            for (var d = {
                    endingStart: 2400,
                    endingEnd: 2400
                }, e = 0; e !== b; ++e) {
                var f = a[e].createInterpolant(null);
                c[e] = f, f.settings = d
            }
            this._interpolantSettings = d, this._interpolants = c, this._propertyBindings = Array(b), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
        }

        function fd(a) {
            this._root = a, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1
        }

        function gd(a, b) {
            "string" == typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."), a = b), this.value = a, this.dynamic = !1
        }

        function hd() {
            pa.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
        }

        function id(b, c, d, e) {
            this.uuid = a.Math.generateUUID(), this.data = b, this.itemSize = c, this.offset = d, this.normalized = !0 === e
        }

        function jd(b, c) {
            this.uuid = a.Math.generateUUID(), this.array = b, this.stride = c, this.count = void 0 !== b ? b.length / c : 0, this.dynamic = !1, this.updateRange = {
                offset: 0,
                count: -1
            }, this.version = 0
        }

        function kd(a, b, c) {
            jd.call(this, a, b), this.meshPerAttribute = c || 1
        }

        function ld(a, b, c) {
            ja.call(this, a, b), this.meshPerAttribute = c || 1
        }

        function md(a, b, c, d) {
            this.ray = new ba(a, b), this.near = c || 0, this.far = d || 1 / 0, this.params = {
                Mesh: {},
                Line: {},
                LOD: {},
                Points: {
                    threshold: 1
                },
                Sprite: {}
            }, Object.defineProperties(this.params, {
                PointCloud: {
                    get: function() {
                        return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                    }
                }
            })
        }

        function nd(a, b) {
            return a.distance - b.distance
        }

        function od(a, b, c, d) {
            if (!1 !== a.visible && (a.raycast(b, c), !0 === d)) {
                a = a.children, d = 0;
                for (var e = a.length; d < e; d++) od(a[d], b, c, !0)
            }
        }

        function pd(a) {
            this.autoStart = void 0 === a || a, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
        }

        function qd(a, b, c) {
            return this.radius = void 0 !== a ? a : 1, this.phi = void 0 !== b ? b : 0, this.theta = void 0 !== c ? c : 0, this
        }

        function rd(a, b) {
            qa.call(this, a, b), this.animationsMap = {}, this.animationsList = [];
            var c = this.geometry.morphTargets.length;
            this.createAnimation("__default", 0, c - 1, c / 1), this.setAnimationWeight("__default", 1)
        }

        function sd(a) {
            ea.call(this), this.material = a, this.render = function(a) {}
        }

        function td(a, b, c, d) {
            this.object = a, this.size = void 0 !== b ? b : 1, a = void 0 !== c ? c : 16711680, d = void 0 !== d ? d : 1, b = 0, (c = this.object.geometry) && c.isGeometry ? b = 3 * c.faces.length : c && c.isBufferGeometry && (b = c.attributes.normal.count), c = new pa, b = new ma(6 * b, 3), c.addAttribute("position", b), hb.call(this, c, new fb({
                color: a,
                linewidth: d
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function ud(a) {
            ea.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, a = new pa;
            for (var b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], c = 0, d = 1; 32 > c; c++, d++) {
                var e = c / 32 * Math.PI * 2,
                    f = d / 32 * Math.PI * 2;
                b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f), 1)
            }
            a.addAttribute("position", new ma(b, 3)), b = new fb({
                fog: !1
            }), this.cone = new hb(a, b), this.add(this.cone), this.update()
        }

        function vd(a) {
            this.bones = this.getBoneList(a);
            for (var b = new na, c = 0; c < this.bones.length; c++) {
                var d = this.bones[c];
                d.parent && d.parent.isBone && (b.vertices.push(new i), b.vertices.push(new i), b.colors.push(new Q(0, 0, 1)), b.colors.push(new Q(0, 1, 0)))
            }
            b.dynamic = !0, c = new fb({
                vertexColors: 2,
                depthTest: !1,
                depthWrite: !1,
                transparent: !0
            }), hb.call(this, b, c), this.root = a, this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, this.update()
        }

        function wd(a, b) {
            this.light = a, this.light.updateMatrixWorld();
            var c = new Db(b, 4, 2),
                d = new ia({
                    wireframe: !0,
                    fog: !1
                });
            d.color.copy(this.light.color).multiplyScalar(this.light.intensity), qa.call(this, c, d), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1
        }

        function xd(a, b) {
            ea.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, this.colors = [new Q, new Q];
            var c = new Eb(b, 4, 2);
            c.rotateX(-Math.PI / 2);
            for (var d = 0; 8 > d; d++) c.faces[d].color = this.colors[4 > d ? 0 : 1];
            d = new ia({
                vertexColors: 1,
                wireframe: !0
            }), this.lightSphere = new qa(c, d), this.add(this.lightSphere), this.update()
        }

        function yd(a, b, c, d) {
            b = b || 1, c = new Q(void 0 !== c ? c : 4473924), d = new Q(void 0 !== d ? d : 8947848);
            for (var e = b / 2, f = 2 * a / b, g = [], h = [], i = 0, j = 0, k = -a; i <= b; i++, k += f) {
                g.push(-a, 0, k, a, 0, k), g.push(k, 0, -a, k, 0, a);
                var l = i === e ? c : d;
                l.toArray(h, j), j += 3, l.toArray(h, j), j += 3, l.toArray(h, j), j += 3, l.toArray(h, j), j += 3
            }
            a = new pa, a.addAttribute("position", new ma(g, 3)), a.addAttribute("color", new ma(h, 3)), g = new fb({
                vertexColors: 2
            }), hb.call(this, a, g)
        }

        function zd(a, b, c, d) {
            this.object = a, this.size = void 0 !== b ? b : 1, a = void 0 !== c ? c : 16776960, d = void 0 !== d ? d : 1, b = 0, (c = this.object.geometry) && c.isGeometry ? b = c.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."), c = new pa, b = new ma(6 * b, 3), c.addAttribute("position", b), hb.call(this, c, new fb({
                color: a,
                linewidth: d
            })), this.matrixAutoUpdate = !1, this.update()
        }

        function Ad(a, b) {
            ea.call(this), this.light = a, this.light.updateMatrixWorld(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, void 0 === b && (b = 1);
            var c = new pa;
            c.addAttribute("position", new ma([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3));
            var d = new fb({
                fog: !1
            });
            this.add(new gb(c, d)), c = new pa, c.addAttribute("position", new ma([0, 0, 0, 0, 0, 1], 3)), this.add(new gb(c, d)), this.update()
        }

        function Bd(a) {
            function b(a, b, d) {
                c(a, d), c(b, d)
            }

            function c(a, b) {
                d.vertices.push(new i), d.colors.push(new Q(b)), void 0 === f[a] && (f[a] = []), f[a].push(d.vertices.length - 1)
            }
            var d = new na,
                e = new fb({
                    color: 16777215,
                    vertexColors: 1
                }),
                f = {};
            b("n1", "n2", 16755200), b("n2", "n4", 16755200), b("n4", "n3", 16755200), b("n3", "n1", 16755200), b("f1", "f2", 16755200), b("f2", "f4", 16755200), b("f4", "f3", 16755200), b("f3", "f1", 16755200), b("n1", "f1", 16755200), b("n2", "f2", 16755200), b("n3", "f3", 16755200), b("n4", "f4", 16755200), b("p", "n1", 16711680), b("p", "n2", 16711680), b("p", "n3", 16711680), b("p", "n4", 16711680), b("u1", "u2", 43775), b("u2", "u3", 43775), b("u3", "u1", 43775), b("c", "t", 16777215), b("p", "c", 3355443), b("cn1", "cn2", 3355443), b("cn3", "cn4", 3355443), b("cf1", "cf2", 3355443), b("cf3", "cf4", 3355443), hb.call(this, d, e), this.camera = a, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = a.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = f, this.update()
        }

        function Cd(a, b) {
            var c = void 0 !== b ? b : 8947848;
            this.object = a, this.box = new X, qa.call(this, new Sb(1, 1, 1), new ia({
                color: c,
                wireframe: !0
            }))
        }

        function Dd(a, b) {
            void 0 === b && (b = 16776960);
            var c = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                d = new Float32Array(24),
                e = new pa;
            e.setIndex(new ja(c, 1)), e.addAttribute("position", new ja(d, 3)), hb.call(this, e, new fb({
                color: b
            })), void 0 !== a && this.update(a)
        }

        function Ed(a, b, c, d, e, f) {
            ea.call(this), void 0 === d && (d = 16776960), void 0 === c && (c = 1), void 0 === e && (e = .2 * c), void 0 === f && (f = .2 * e), this.position.copy(b), this.line = new gb(ce, new fb({
                color: d
            })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new qa(de, new ia({
                color: d
            })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(a), this.setLength(c, e, f)
        }

        function Fd(a) {
            a = a || 1;
            var b = new Float32Array([0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a]),
                c = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]);
            a = new pa, a.addAttribute("position", new ja(b, 3)), a.addAttribute("color", new ja(c, 3)), b = new fb({
                vertexColors: 2
            }), hb.call(this, a, b)
        }

        function Gd(b) {
            console.warn("THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3."), a.CatmullRomCurve3.call(this, b), this.type = "catmullrom", this.closed = !0
        }

        function Hd(a, b, c, d, e, f) {
            Mc.call(this, a, b, c, c, d, e, f)
        }
        void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Math.sign && (Math.sign = function(a) {
            return 0 > a ? -1 : 0 < a ? 1 : +a
        }), void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
            get: function() {
                return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1]
            }
        }), void 0 === Object.assign && function() {
            Object.assign = function(a) {
                if (void 0 === a || null === a) throw new TypeError("Cannot convert undefined or null to object");
                for (var b = Object(a), c = 1; c < arguments.length; c++) {
                    var d = arguments[c];
                    if (void 0 !== d && null !== d)
                        for (var e in d) Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e])
                }
                return b
            }
        }(), Object.assign(b.prototype, {
            addEventListener: function(a, b) {
                void 0 === this._listeners && (this._listeners = {});
                var c = this._listeners;
                void 0 === c[a] && (c[a] = []), -1 === c[a].indexOf(b) && c[a].push(b)
            },
            hasEventListener: function(a, b) {
                if (void 0 === this._listeners) return !1;
                var c = this._listeners;
                return void 0 !== c[a] && -1 !== c[a].indexOf(b)
            },
            removeEventListener: function(a, b) {
                if (void 0 !== this._listeners) {
                    var c = this._listeners[a];
                    if (void 0 !== c) {
                        var d = c.indexOf(b); - 1 !== d && c.splice(d, 1)
                    }
                }
            },
            dispatchEvent: function(a) {
                if (void 0 !== this._listeners) {
                    var b = this._listeners[a.type];
                    if (void 0 !== b) {
                        a.target = this;
                        var c, d = [],
                            e = b.length;
                        for (c = 0; c < e; c++) d[c] = b[c];
                        for (c = 0; c < e; c++) d[c].call(this, a)
                    }
                }
            }
        });
        var Id = {
                NoBlending: 0,
                NormalBlending: 1,
                AdditiveBlending: 2,
                SubtractiveBlending: 3,
                MultiplyBlending: 4,
                CustomBlending: 5
            },
            Jd = {
                UVMapping: 300,
                CubeReflectionMapping: 301,
                CubeRefractionMapping: 302,
                EquirectangularReflectionMapping: 303,
                EquirectangularRefractionMapping: 304,
                SphericalReflectionMapping: 305,
                CubeUVReflectionMapping: 306,
                CubeUVRefractionMapping: 307
            },
            Kd = {
                RepeatWrapping: 1e3,
                ClampToEdgeWrapping: 1001,
                MirroredRepeatWrapping: 1002
            },
            Ld = {
                NearestFilter: 1003,
                NearestMipMapNearestFilter: 1004,
                NearestMipMapLinearFilter: 1005,
                LinearFilter: 1006,
                LinearMipMapNearestFilter: 1007,
                LinearMipMapLinearFilter: 1008
            };
        a.Math = {
            DEG2RAD: Math.PI / 180,
            RAD2DEG: 180 / Math.PI,
            generateUUID: function() {
                var a, b = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                    c = Array(36),
                    d = 0;
                return function() {
                    for (var e = 0; 36 > e; e++) 8 === e || 13 === e || 18 === e || 23 === e ? c[e] = "-" : 14 === e ? c[e] = "4" : (2 >= d && (d = 33554432 + 16777216 * Math.random() | 0), a = 15 & d, d >>= 4, c[e] = b[19 === e ? 3 & a | 8 : a]);
                    return c.join("")
                }
            }(),
            clamp: function(a, b, c) {
                return Math.max(b, Math.min(c, a))
            },
            euclideanModulo: function(a, b) {
                return (a % b + b) % b
            },
            mapLinear: function(a, b, c, d, e) {
                return d + (a - b) * (e - d) / (c - b)
            },
            smoothstep: function(a, b, c) {
                return a <= b ? 0 : a >= c ? 1 : (a = (a - b) / (c - b), a * a * (3 - 2 * a))
            },
            smootherstep: function(a, b, c) {
                return a <= b ? 0 : a >= c ? 1 : (a = (a - b) / (c - b), a * a * a * (a * (6 * a - 15) + 10))
            },
            random16: function() {
                return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."), Math.random()
            },
            randInt: function(a, b) {
                return a + Math.floor(Math.random() * (b - a + 1))
            },
            randFloat: function(a, b) {
                return a + Math.random() * (b - a)
            },
            randFloatSpread: function(a) {
                return a * (.5 - Math.random())
            },
            degToRad: function(b) {
                return b * a.Math.DEG2RAD
            },
            radToDeg: function(b) {
                return b * a.Math.RAD2DEG
            },
            isPowerOfTwo: function(a) {
                return 0 === (a & a - 1) && 0 !== a
            },
            nearestPowerOfTwo: function(a) {
                return Math.pow(2, Math.round(Math.log(a) / Math.LN2))
            },
            nextPowerOfTwo: function(a) {
                return a--, a |= a >> 1, a |= a >> 2, a |= a >> 4, a |= a >> 8, a |= a >> 16, a++, a
            }
        }, c.prototype = {
            constructor: c,
            isVector2: !0,
            get width() {
                return this.x
            },
            set width(a) {
                this.x = a
            },
            get height() {
                return this.y
            },
            set height(a) {
                this.y = a
            },
            set: function(a, b) {
                return this.x = a, this.y = b, this
            },
            setScalar: function(a) {
                return this.y = this.x = a, this
            },
            setX: function(a) {
                return this.x = a, this
            },
            setY: function(a) {
                return this.y = a, this
            },
            setComponent: function(a, b) {
                switch (a) {
                    case 0:
                        this.x = b;
                        break;
                    case 1:
                        this.y = b;
                        break;
                    default:
                        throw Error("index is out of range: " + a)
                }
            },
            getComponent: function(a) {
                switch (a) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    default:
                        throw Error("index is out of range: " + a)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y)
            },
            copy: function(a) {
                return this.x = a.x, this.y = a.y, this
            },
            add: function(a, b) {
                return void 0 !== b ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this)
            },
            addScalar: function(a) {
                return this.x += a, this.y += a, this
            },
            addVectors: function(a, b) {
                return this.x = a.x + b.x, this.y = a.y + b.y, this
            },
            addScaledVector: function(a, b) {
                return this.x += a.x * b, this.y += a.y * b, this
            },
            sub: function(a, b) {
                return void 0 !== b ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this)
            },
            subScalar: function(a) {
                return this.x -= a, this.y -= a, this
            },
            subVectors: function(a, b) {
                return this.x = a.x - b.x, this.y = a.y - b.y, this
            },
            multiply: function(a) {
                return this.x *= a.x, this.y *= a.y, this
            },
            multiplyScalar: function(a) {
                return isFinite(a) ? (this.x *= a, this.y *= a) : this.y = this.x = 0, this
            },
            divide: function(a) {
                return this.x /= a.x, this.y /= a.y, this
            },
            divideScalar: function(a) {
                return this.multiplyScalar(1 / a)
            },
            min: function(a) {
                return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this
            },
            max: function(a) {
                return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this
            },
            clamp: function(a, b) {
                return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this
            },
            clampScalar: function() {
                var a, b;
                return function(d, e) {
                    return void 0 === a && (a = new c, b = new c), a.set(d, d), b.set(e, e), this.clamp(a, b)
                }
            }(),
            clampLength: function(a, b) {
                var c = this.length();
                return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c)
            },
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this
            },
            roundToZero: function() {
                return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this
            },
            dot: function(a) {
                return this.x * a.x + this.y * a.y
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            },
            lengthManhattan: function() {
                return Math.abs(this.x) + Math.abs(this.y)
            },
            normalize: function() {
                return this.divideScalar(this.length())
            },
            angle: function() {
                var a = Math.atan2(this.y, this.x);
                return 0 > a && (a += 2 * Math.PI), a
            },
            distanceTo: function(a) {
                return Math.sqrt(this.distanceToSquared(a))
            },
            distanceToSquared: function(a) {
                var b = this.x - a.x;
                return a = this.y - a.y, b * b + a * a
            },
            distanceToManhattan: function(a) {
                return Math.abs(this.x - a.x) + Math.abs(this.y - a.y)
            },
            setLength: function(a) {
                return this.multiplyScalar(a / this.length())
            },
            lerp: function(a, b) {
                return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this
            },
            lerpVectors: function(a, b, c) {
                return this.subVectors(b, a).multiplyScalar(c).add(a)
            },
            equals: function(a) {
                return a.x === this.x && a.y === this.y
            },
            fromArray: function(a, b) {
                return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this
            },
            toArray: function(a, b) {
                return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a
            },
            fromAttribute: function(a, b, c) {
                return void 0 === c && (c = 0), b = b * a.itemSize + c, this.x = a.array[b], this.y = a.array[b + 1], this
            },
            rotateAround: function(a, b) {
                var c = Math.cos(b),
                    d = Math.sin(b),
                    e = this.x - a.x,
                    f = this.y - a.y;
                return this.x = e * c - f * d + a.x, this.y = e * d + f * c + a.y, this
            }
        }, d.DEFAULT_IMAGE = void 0, d.DEFAULT_MAPPING = 300, d.prototype = {
            constructor: d,
            isTexture: !0,
            set needsUpdate(a) {
                !0 === a && this.version++
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(a) {
                return this.image = a.image, this.mipmaps = a.mipmaps.slice(0), this.mapping = a.mapping, this.wrapS = a.wrapS, this.wrapT = a.wrapT, this.magFilter = a.magFilter, this.minFilter = a.minFilter, this.anisotropy = a.anisotropy, this.format = a.format, this.type = a.type, this.offset.copy(a.offset), this.repeat.copy(a.repeat), this.generateMipmaps = a.generateMipmaps, this.premultiplyAlpha = a.premultiplyAlpha, this.flipY = a.flipY, this.unpackAlignment = a.unpackAlignment, this.encoding = a.encoding, this
            },
            toJSON: function(b) {
                if (void 0 !== b.textures[this.uuid]) return b.textures[this.uuid];
                var c = {
                    metadata: {
                        version: 4.4,
                        type: "Texture",
                        generator: "Texture.toJSON"
                    },
                    uuid: this.uuid,
                    name: this.name,
                    mapping: this.mapping,
                    repeat: [this.repeat.x, this.repeat.y],
                    offset: [this.offset.x, this.offset.y],
                    wrap: [this.wrapS, this.wrapT],
                    minFilter: this.minFilter,
                    magFilter: this.magFilter,
                    anisotropy: this.anisotropy,
                    flipY: this.flipY
                };
                if (void 0 !== this.image) {
                    var d = this.image;
                    if (void 0 === d.uuid && (d.uuid = a.Math.generateUUID()), void 0 === b.images[d.uuid]) {
                        var e, f = b.images,
                            g = d.uuid,
                            h = d.uuid;
                        void 0 !== d.toDataURL ? e = d : (e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), e.width = d.width, e.height = d.height, e.getContext("2d").drawImage(d, 0, 0, d.width, d.height)), e = 2048 < e.width || 2048 < e.height ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png"), f[g] = {
                            uuid: h,
                            url: e
                        }
                    }
                    c.image = d.uuid
                }
                return b.textures[this.uuid] = c
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            },
            transformUv: function(a) {
                if (300 === this.mapping) {
                    if (a.multiply(this.repeat), a.add(this.offset), 0 > a.x || 1 < a.x) switch (this.wrapS) {
                        case 1e3:
                            a.x -= Math.floor(a.x);
                            break;
                        case 1001:
                            a.x = 0 > a.x ? 0 : 1;
                            break;
                        case 1002:
                            a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x)
                    }
                    if (0 > a.y || 1 < a.y) switch (this.wrapT) {
                        case 1e3:
                            a.y -= Math.floor(a.y);
                            break;
                        case 1001:
                            a.y = 0 > a.y ? 0 : 1;
                            break;
                        case 1002:
                            a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y)
                    }
                    this.flipY && (a.y = 1 - a.y)
                }
            }
        }, Object.assign(d.prototype, b.prototype);
        var Md = 0;
        e.prototype = {
            constructor: e,
            isVector4: !0,
            set: function(a, b, c, d) {
                return this.x = a, this.y = b, this.z = c, this.w = d, this
            },
            setScalar: function(a) {
                return this.w = this.z = this.y = this.x = a, this
            },
            setX: function(a) {
                return this.x = a, this
            },
            setY: function(a) {
                return this.y = a, this
            },
            setZ: function(a) {
                return this.z = a, this
            },
            setW: function(a) {
                return this.w = a, this
            },
            setComponent: function(a, b) {
                switch (a) {
                    case 0:
                        this.x = b;
                        break;
                    case 1:
                        this.y = b;
                        break;
                    case 2:
                        this.z = b;
                        break;
                    case 3:
                        this.w = b;
                        break;
                    default:
                        throw Error("index is out of range: " + a)
                }
            },
            getComponent: function(a) {
                switch (a) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    case 3:
                        return this.w;
                    default:
                        throw Error("index is out of range: " + a)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y, this.z, this.w)
            },
            copy: function(a) {
                return this.x = a.x, this.y = a.y, this.z = a.z, this.w = void 0 !== a.w ? a.w : 1, this
            },
            add: function(a, b) {
                return void 0 !== b ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this.w += a.w, this)
            },
            addScalar: function(a) {
                return this.x += a, this.y += a, this.z += a, this.w += a, this
            },
            addVectors: function(a, b) {
                return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, this
            },
            addScaledVector: function(a, b) {
                return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this.w += a.w * b, this
            },
            sub: function(a, b) {
                return void 0 !== b ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this.w -= a.w, this)
            },
            subScalar: function(a) {
                return this.x -= a, this.y -= a, this.z -= a, this.w -= a, this
            },
            subVectors: function(a, b) {
                return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, this
            },
            multiplyScalar: function(a) {
                return isFinite(a) ? (this.x *= a, this.y *= a, this.z *= a, this.w *= a) : this.w = this.z = this.y = this.x = 0, this
            },
            applyMatrix4: function(a) {
                var b = this.x,
                    c = this.y,
                    d = this.z,
                    e = this.w;
                return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e, this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e, this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e, this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e, this
            },
            divideScalar: function(a) {
                return this.multiplyScalar(1 / a)
            },
            setAxisAngleFromQuaternion: function(a) {
                this.w = 2 * Math.acos(a.w);
                var b = Math.sqrt(1 - a.w * a.w);
                return 1e-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b), this
            },
            setAxisAngleFromRotationMatrix: function(a) {
                var b, c, d;
                a = a.elements;
                var e = a[0];
                d = a[4];
                var f = a[8],
                    g = a[1],
                    h = a[5],
                    i = a[9];
                c = a[2], b = a[6];
                var j = a[10];
                return .01 > Math.abs(d - g) && .01 > Math.abs(f - c) && .01 > Math.abs(i - b) ? .1 > Math.abs(d + g) && .1 > Math.abs(f + c) && .1 > Math.abs(i + b) && .1 > Math.abs(e + h + j - 3) ? (this.set(1, 0, 0, 0), this) : (a = Math.PI, e = (e + 1) / 2, h = (h + 1) / 2, j = (j + 1) / 2, d = (d + g) / 4, f = (f + c) / 4, i = (i + b) / 4, e > h && e > j ? .01 > e ? (b = 0, d = c = .707106781) : (b = Math.sqrt(e), c = d / b, d = f / b) : h > j ? .01 > h ? (b = .707106781, c = 0, d = .707106781) : (c = Math.sqrt(h), b = d / c, d = i / c) : .01 > j ? (c = b = .707106781, d = 0) : (d = Math.sqrt(j), b = f / d, c = i / d), this.set(b, c, d, a), this) : (a = Math.sqrt((b - i) * (b - i) + (f - c) * (f - c) + (g - d) * (g - d)), .001 > Math.abs(a) && (a = 1), this.x = (b - i) / a, this.y = (f - c) / a, this.z = (g - d) / a, this.w = Math.acos((e + h + j - 1) / 2), this)
            },
            min: function(a) {
                return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this.z = Math.min(this.z, a.z), this.w = Math.min(this.w, a.w), this
            },
            max: function(a) {
                return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this.z = Math.max(this.z, a.z), this.w = Math.max(this.w, a.w), this
            },
            clamp: function(a, b) {
                return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this.z = Math.max(a.z, Math.min(b.z, this.z)), this.w = Math.max(a.w, Math.min(b.w, this.w)), this
            },
            clampScalar: function() {
                var a, b;
                return function(c, d) {
                    return void 0 === a && (a = new e, b = new e), a.set(c, c, c, c), b.set(d, d, d, d), this.clamp(a, b)
                }
            }(),
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
            },
            roundToZero: function() {
                return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
            },
            dot: function(a) {
                return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            },
            lengthManhattan: function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
            },
            normalize: function() {
                return this.divideScalar(this.length())
            },
            setLength: function(a) {
                return this.multiplyScalar(a / this.length())
            },
            lerp: function(a, b) {
                return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, this.w += (a.w - this.w) * b, this
            },
            lerpVectors: function(a, b, c) {
                return this.subVectors(b, a).multiplyScalar(c).add(a)
            },
            equals: function(a) {
                return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
            },
            fromArray: function(a, b) {
                return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], this.w = a[b + 3], this
            },
            toArray: function(a, b) {
                return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z, a[b + 3] = this.w, a
            },
            fromAttribute: function(a, b, c) {
                return void 0 === c && (c = 0), b = b * a.itemSize + c, this.x = a.array[b], this.y = a.array[b + 1], this.z = a.array[b + 2], this.w = a.array[b + 3], this
            }
        }, Object.assign(f.prototype, b.prototype, {
            isWebGLRenderTarget: !0,
            setSize: function(a, b) {
                this.width === a && this.height === b || (this.width = a, this.height = b, this.dispose()), this.viewport.set(0, 0, a, b), this.scissor.set(0, 0, a, b)
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(a) {
                return this.width = a.width, this.height = a.height, this.viewport.copy(a.viewport), this.texture = a.texture.clone(), this.depthBuffer = a.depthBuffer, this.stencilBuffer = a.stencilBuffer, this.depthTexture = a.depthTexture, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), g.prototype = Object.create(f.prototype), g.prototype.constructor = g, g.prototype.isWebGLRenderTargetCube = !0, h.prototype = {
            constructor: h,
            get x() {
                return this._x
            },
            set x(a) {
                this._x = a, this.onChangeCallback()
            },
            get y() {
                return this._y
            },
            set y(a) {
                this._y = a, this.onChangeCallback()
            },
            get z() {
                return this._z
            },
            set z(a) {
                this._z = a, this.onChangeCallback()
            },
            get w() {
                return this._w
            },
            set w(a) {
                this._w = a, this.onChangeCallback()
            },
            set: function(a, b, c, d) {
                return this._x = a, this._y = b, this._z = c, this._w = d, this.onChangeCallback(), this
            },
            clone: function() {
                return new this.constructor(this._x, this._y, this._z, this._w)
            },
            copy: function(a) {
                return this._x = a.x, this._y = a.y, this._z = a.z, this._w = a.w, this.onChangeCallback(), this
            },
            setFromEuler: function(a, b) {
                if (!1 === (a && a.isEuler)) throw Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var c = Math.cos(a._x / 2),
                    d = Math.cos(a._y / 2),
                    e = Math.cos(a._z / 2),
                    f = Math.sin(a._x / 2),
                    g = Math.sin(a._y / 2),
                    h = Math.sin(a._z / 2),
                    i = a.order;
                return "XYZ" === i ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "YXZ" === i ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "ZXY" === i ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "ZYX" === i ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "YZX" === i ? (this._x = f * d * e + c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e - f * g * h) : "XZY" === i && (this._x = f * d * e - c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e + f * g * h), !1 !== b && this.onChangeCallback(), this
            },
            setFromAxisAngle: function(a, b) {
                var c = b / 2,
                    d = Math.sin(c);
                return this._x = a.x * d, this._y = a.y * d, this._z = a.z * d, this._w = Math.cos(c), this.onChangeCallback(), this
            },
            setFromRotationMatrix: function(a) {
                var b = a.elements,
                    c = b[0];
                a = b[4];
                var d = b[8],
                    e = b[1],
                    f = b[5],
                    g = b[9],
                    h = b[2],
                    i = b[6],
                    b = b[10],
                    j = c + f + b;
                return 0 < j ? (c = .5 / Math.sqrt(j + 1), this._w = .25 / c, this._x = (i - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (i - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y = .25 * c, this._z = (g + i) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + i) / c, this._z = .25 * c), this.onChangeCallback(), this
            },
            setFromUnitVectors: function() {
                var a, b;
                return function(c, d) {
                    return void 0 === a && (a = new i), b = c.dot(d) + 1, 1e-6 > b ? (b = 0, Math.abs(c.x) > Math.abs(c.z) ? a.set(-c.y, c.x, 0) : a.set(0, -c.z, c.y)) : a.crossVectors(c, d), this._x = a.x, this._y = a.y, this._z = a.z, this._w = b, this.normalize()
                }
            }(),
            inverse: function() {
                return this.conjugate().normalize()
            },
            conjugate: function() {
                return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
            },
            dot: function(a) {
                return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
            },
            lengthSq: function() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            },
            length: function() {
                return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
            },
            normalize: function() {
                var a = this.length();
                return 0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a), this.onChangeCallback(), this
            },
            multiply: function(a, b) {
                return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
            },
            premultiply: function(a) {
                return this.multiplyQuaternions(a, this)
            },
            multiplyQuaternions: function(a, b) {
                var c = a._x,
                    d = a._y,
                    e = a._z,
                    f = a._w,
                    g = b._x,
                    h = b._y,
                    i = b._z,
                    j = b._w;
                return this._x = c * j + f * g + d * i - e * h, this._y = d * j + f * h + e * g - c * i, this._z = e * j + f * i + c * h - d * g, this._w = f * j - c * g - d * h - e * i, this.onChangeCallback(), this
            },
            slerp: function(a, b) {
                if (0 === b) return this;
                if (1 === b) return this.copy(a);
                var c = this._x,
                    d = this._y,
                    e = this._z,
                    f = this._w,
                    g = f * a._w + c * a._x + d * a._y + e * a._z;
                if (0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a), 1 <= g) return this._w = f, this._x = c, this._y = d, this._z = e, this;
                var h = Math.sqrt(1 - g * g);
                if (.001 > Math.abs(h)) return this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this;
                var i = Math.atan2(h, g),
                    g = Math.sin((1 - b) * i) / h,
                    h = Math.sin(b * i) / h;
                return this._w = f * g + this._w * h, this._x = c * g + this._x * h, this._y = d * g + this._y * h, this._z = e * g + this._z * h, this.onChangeCallback(), this
            },
            equals: function(a) {
                return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
            },
            fromArray: function(a, b) {
                return void 0 === b && (b = 0), this._x = a[b], this._y = a[b + 1], this._z = a[b + 2], this._w = a[b + 3], this.onChangeCallback(), this
            },
            toArray: function(a, b) {
                return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, a[b + 2] = this._z, a[b + 3] = this._w, a
            },
            onChange: function(a) {
                return this.onChangeCallback = a, this
            },
            onChangeCallback: function() {}
        }, Object.assign(h, {
            slerp: function(a, b, c, d) {
                return c.copy(a).slerp(b, d)
            },
            slerpFlat: function(a, b, c, d, e, f, g) {
                var h = c[d + 0],
                    i = c[d + 1],
                    j = c[d + 2];
                c = c[d + 3], d = e[f + 0];
                var k = e[f + 1],
                    l = e[f + 2];
                if (e = e[f + 3], c !== e || h !== d || i !== k || j !== l) {
                    f = 1 - g;
                    var m = h * d + i * k + j * l + c * e,
                        n = 0 <= m ? 1 : -1,
                        o = 1 - m * m;
                    o > Number.EPSILON && (o = Math.sqrt(o), m = Math.atan2(o, m * n), f = Math.sin(f * m) / o, g = Math.sin(g * m) / o), n *= g, h = h * f + d * n, i = i * f + k * n, j = j * f + l * n, c = c * f + e * n, f === 1 - g && (g = 1 / Math.sqrt(h * h + i * i + j * j + c * c), h *= g, i *= g, j *= g, c *= g)
                }
                a[b] = h, a[b + 1] = i, a[b + 2] = j, a[b + 3] = c
            }
        }), i.prototype = {
            constructor: i,
            isVector3: !0,
            set: function(a, b, c) {
                return this.x = a, this.y = b, this.z = c, this
            },
            setScalar: function(a) {
                return this.z = this.y = this.x = a, this
            },
            setX: function(a) {
                return this.x = a, this
            },
            setY: function(a) {
                return this.y = a, this
            },
            setZ: function(a) {
                return this.z = a, this
            },
            setComponent: function(a, b) {
                switch (a) {
                    case 0:
                        this.x = b;
                        break;
                    case 1:
                        this.y = b;
                        break;
                    case 2:
                        this.z = b;
                        break;
                    default:
                        throw Error("index is out of range: " + a)
                }
            },
            getComponent: function(a) {
                switch (a) {
                    case 0:
                        return this.x;
                    case 1:
                        return this.y;
                    case 2:
                        return this.z;
                    default:
                        throw Error("index is out of range: " + a)
                }
            },
            clone: function() {
                return new this.constructor(this.x, this.y, this.z)
            },
            copy: function(a) {
                return this.x = a.x, this.y = a.y, this.z = a.z, this
            },
            add: function(a, b) {
                return void 0 !== b ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b)) : (this.x += a.x, this.y += a.y, this.z += a.z, this)
            },
            addScalar: function(a) {
                return this.x += a, this.y += a, this.z += a, this
            },
            addVectors: function(a, b) {
                return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this
            },
            addScaledVector: function(a, b) {
                return this.x += a.x * b, this.y += a.y * b, this.z += a.z * b, this
            },
            sub: function(a, b) {
                return void 0 !== b ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b)) : (this.x -= a.x, this.y -= a.y, this.z -= a.z, this)
            },
            subScalar: function(a) {
                return this.x -= a, this.y -= a, this.z -= a, this
            },
            subVectors: function(a, b) {
                return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this
            },
            multiply: function(a, b) {
                return void 0 !== b ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b)) : (this.x *= a.x, this.y *= a.y, this.z *= a.z, this)
            },
            multiplyScalar: function(a) {
                return isFinite(a) ? (this.x *= a, this.y *= a, this.z *= a) : this.z = this.y = this.x = 0, this
            },
            multiplyVectors: function(a, b) {
                return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this
            },
            applyEuler: function() {
                var a;
                return function(b) {
                    return !1 === (b && b.isEuler) && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), void 0 === a && (a = new h), this.applyQuaternion(a.setFromEuler(b))
                }
            }(),
            applyAxisAngle: function() {
                var a;
                return function(b, c) {
                    return void 0 === a && (a = new h), this.applyQuaternion(a.setFromAxisAngle(b, c))
                }
            }(),
            applyMatrix3: function(a) {
                var b = this.x,
                    c = this.y,
                    d = this.z;
                return a = a.elements, this.x = a[0] * b + a[3] * c + a[6] * d, this.y = a[1] * b + a[4] * c + a[7] * d, this.z = a[2] * b + a[5] * c + a[8] * d, this
            },
            applyMatrix4: function(a) {
                var b = this.x,
                    c = this.y,
                    d = this.z;
                return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d + a[12], this.y = a[1] * b + a[5] * c + a[9] * d + a[13], this.z = a[2] * b + a[6] * c + a[10] * d + a[14], this
            },
            applyProjection: function(a) {
                var b = this.x,
                    c = this.y,
                    d = this.z;
                a = a.elements;
                var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
                return this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e, this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e, this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e, this
            },
            applyQuaternion: function(a) {
                var b = this.x,
                    c = this.y,
                    d = this.z,
                    e = a.x,
                    f = a.y,
                    g = a.z;
                a = a.w;
                var h = a * b + f * d - g * c,
                    i = a * c + g * b - e * d,
                    j = a * d + e * c - f * b,
                    b = -e * b - f * c - g * d;
                return this.x = h * a + b * -e + i * -g - j * -f, this.y = i * a + b * -f + j * -e - h * -g, this.z = j * a + b * -g + h * -f - i * -e, this
            },
            project: function() {
                var a;
                return function(b) {
                    return void 0 === a && (a = new j), a.multiplyMatrices(b.projectionMatrix, a.getInverse(b.matrixWorld)), this.applyProjection(a)
                }
            }(),
            unproject: function() {
                var a;
                return function(b) {
                    return void 0 === a && (a = new j), a.multiplyMatrices(b.matrixWorld, a.getInverse(b.projectionMatrix)), this.applyProjection(a)
                }
            }(),
            transformDirection: function(a) {
                var b = this.x,
                    c = this.y,
                    d = this.z;
                return a = a.elements, this.x = a[0] * b + a[4] * c + a[8] * d, this.y = a[1] * b + a[5] * c + a[9] * d, this.z = a[2] * b + a[6] * c + a[10] * d, this.normalize()
            },
            divide: function(a) {
                return this.x /= a.x, this.y /= a.y, this.z /= a.z, this
            },
            divideScalar: function(a) {
                return this.multiplyScalar(1 / a)
            },
            min: function(a) {
                return this.x = Math.min(this.x, a.x), this.y = Math.min(this.y, a.y), this.z = Math.min(this.z, a.z), this
            },
            max: function(a) {
                return this.x = Math.max(this.x, a.x), this.y = Math.max(this.y, a.y), this.z = Math.max(this.z, a.z), this
            },
            clamp: function(a, b) {
                return this.x = Math.max(a.x, Math.min(b.x, this.x)), this.y = Math.max(a.y, Math.min(b.y, this.y)), this.z = Math.max(a.z, Math.min(b.z, this.z)), this
            },
            clampScalar: function() {
                var a, b;
                return function(c, d) {
                    return void 0 === a && (a = new i, b = new i), a.set(c, c, c), b.set(d, d, d), this.clamp(a, b)
                }
            }(),
            clampLength: function(a, b) {
                var c = this.length();
                return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c)
            },
            floor: function() {
                return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
            },
            ceil: function() {
                return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
            },
            round: function() {
                return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
            },
            roundToZero: function() {
                return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
            },
            negate: function() {
                return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
            },
            dot: function(a) {
                return this.x * a.x + this.y * a.y + this.z * a.z
            },
            lengthSq: function() {
                return this.x * this.x + this.y * this.y + this.z * this.z
            },
            length: function() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
            },
            lengthManhattan: function() {
                return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
            },
            normalize: function() {
                return this.divideScalar(this.length())
            },
            setLength: function(a) {
                return this.multiplyScalar(a / this.length())
            },
            lerp: function(a, b) {
                return this.x += (a.x - this.x) * b, this.y += (a.y - this.y) * b, this.z += (a.z - this.z) * b, this
            },
            lerpVectors: function(a, b, c) {
                return this.subVectors(b, a).multiplyScalar(c).add(a)
            },
            cross: function(a, b) {
                if (void 0 !== b) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b);
                var c = this.x,
                    d = this.y,
                    e = this.z;
                return this.x = d * a.z - e * a.y, this.y = e * a.x - c * a.z, this.z = c * a.y - d * a.x, this
            },
            crossVectors: function(a, b) {
                var c = a.x,
                    d = a.y,
                    e = a.z,
                    f = b.x,
                    g = b.y,
                    h = b.z;
                return this.x = d * h - e * g, this.y = e * f - c * h, this.z = c * g - d * f, this
            },
            projectOnVector: function(a) {
                var b = a.dot(this) / a.lengthSq();
                return this.copy(a).multiplyScalar(b)
            },
            projectOnPlane: function() {
                var a;
                return function(b) {
                    return void 0 === a && (a = new i), a.copy(this).projectOnVector(b), this.sub(a)
                }
            }(),
            reflect: function() {
                var a;
                return function(b) {
                    return void 0 === a && (a = new i), this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)))
                }
            }(),
            angleTo: function(b) {
                return b = this.dot(b) / Math.sqrt(this.lengthSq() * b.lengthSq()), Math.acos(a.Math.clamp(b, -1, 1))
            },
            distanceTo: function(a) {
                return Math.sqrt(this.distanceToSquared(a))
            },
            distanceToSquared: function(a) {
                var b = this.x - a.x,
                    c = this.y - a.y;
                return a = this.z - a.z, b * b + c * c + a * a
            },
            distanceToManhattan: function(a) {
                return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z)
            },
            setFromSpherical: function(a) {
                var b = Math.sin(a.phi) * a.radius;
                return this.x = b * Math.sin(a.theta), this.y = Math.cos(a.phi) * a.radius, this.z = b * Math.cos(a.theta), this
            },
            setFromMatrixPosition: function(a) {
                return this.setFromMatrixColumn(a, 3)
            },
            setFromMatrixScale: function(a) {
                var b = this.setFromMatrixColumn(a, 0).length(),
                    c = this.setFromMatrixColumn(a, 1).length();
                return a = this.setFromMatrixColumn(a, 2).length(), this.x = b, this.y = c, this.z = a, this
            },
            setFromMatrixColumn: function(a, b) {
                if ("number" == typeof a) {
                    console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).");
                    var c = a;
                    a = b, b = c
                }
                return this.fromArray(a.elements, 4 * b)
            },
            equals: function(a) {
                return a.x === this.x && a.y === this.y && a.z === this.z
            },
            fromArray: function(a, b) {
                return void 0 === b && (b = 0), this.x = a[b], this.y = a[b + 1], this.z = a[b + 2], this
            },
            toArray: function(a, b) {
                return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.x, a[b + 1] = this.y, a[b + 2] = this.z, a
            },
            fromAttribute: function(a, b, c) {
                return void 0 === c && (c = 0), b = b * a.itemSize + c, this.x = a.array[b], this.y = a.array[b + 1], this.z = a.array[b + 2], this
            }
        }, j.prototype = {
            constructor: j,
            isMatrix4: !0,
            set: function(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
                var q = this.elements;
                return q[0] = a, q[4] = b, q[8] = c, q[12] = d, q[1] = e, q[5] = f, q[9] = g, q[13] = h, q[2] = i, q[6] = j, q[10] = k, q[14] = l, q[3] = m, q[7] = n, q[11] = o, q[15] = p, this
            },
            identity: function() {
                return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            clone: function() {
                return (new j).fromArray(this.elements)
            },
            copy: function(a) {
                return this.elements.set(a.elements), this
            },
            copyPosition: function(a) {
                var b = this.elements;
                return a = a.elements, b[12] = a[12], b[13] = a[13], b[14] = a[14], this
            },
            extractBasis: function(a, b, c) {
                return a.setFromMatrixColumn(this, 0), b.setFromMatrixColumn(this, 1), c.setFromMatrixColumn(this, 2), this
            },
            makeBasis: function(a, b, c) {
                return this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1), this
            },
            extractRotation: function() {
                var a;
                return function(b) {
                    void 0 === a && (a = new i);
                    var c = this.elements,
                        d = b.elements,
                        e = 1 / a.setFromMatrixColumn(b, 0).length(),
                        f = 1 / a.setFromMatrixColumn(b, 1).length();
                    return b = 1 / a.setFromMatrixColumn(b, 2).length(), c[0] = d[0] * e, c[1] = d[1] * e, c[2] = d[2] * e, c[4] = d[4] * f, c[5] = d[5] * f, c[6] = d[6] * f, c[8] = d[8] * b, c[9] = d[9] * b, c[10] = d[10] * b, this
                }
            }(),
            makeRotationFromEuler: function(a) {
                !1 === (a && a.isEuler) && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                var b = this.elements,
                    c = a.x,
                    d = a.y,
                    e = a.z,
                    f = Math.cos(c),
                    c = Math.sin(c),
                    g = Math.cos(d),
                    d = Math.sin(d),
                    h = Math.cos(e),
                    e = Math.sin(e);
                if ("XYZ" === a.order) {
                    a = f * h;
                    var i = f * e,
                        j = c * h,
                        k = c * e;
                    b[0] = g * h, b[4] = -g * e, b[8] = d, b[1] = i + j * d, b[5] = a - k * d, b[9] = -c * g, b[2] = k - a * d, b[6] = j + i * d, b[10] = f * g
                } else "YXZ" === a.order ? (a = g * h, i = g * e, j = d * h, k = d * e, b[0] = a + k * c, b[4] = j * c - i, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = i * c - j, b[6] = k + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, i = g * e, j = d * h, k = d * e, b[0] = a - k * c, b[4] = -f * e, b[8] = j + i * c, b[1] = i + j * c, b[5] = f * h, b[9] = k - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, i = f * e, j = c * h, k = c * e, b[0] = g * h, b[4] = j * d - i, b[8] = a * d + k, b[1] = g * e, b[5] = k * d + a, b[9] = i * d - j, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, i = f * d, j = c * g, k = c * d, b[0] = g * h, b[4] = k - a * e, b[8] = j * e + i, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = i * e + j, b[10] = a - k * e) : "XZY" === a.order && (a = f * g, i = f * d, j = c * g, k = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + k, b[5] = f * h, b[9] = i * e - j, b[2] = j * e - i, b[6] = c * h, b[10] = k * e + a);
                return b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this
            },
            makeRotationFromQuaternion: function(a) {
                var b = this.elements,
                    c = a.x,
                    d = a.y,
                    e = a.z,
                    f = a.w,
                    g = c + c,
                    h = d + d,
                    i = e + e;
                a = c * g;
                var j = c * h,
                    c = c * i,
                    k = d * h,
                    d = d * i,
                    e = e * i,
                    g = f * g,
                    h = f * h,
                    f = f * i;
                return b[0] = 1 - (k + e), b[4] = j - f, b[8] = c + h, b[1] = j + f, b[5] = 1 - (a + e), b[9] = d - g, b[2] = c - h, b[6] = d + g, b[10] = 1 - (a + k), b[3] = 0, b[7] = 0, b[11] = 0, b[12] = 0, b[13] = 0, b[14] = 0, b[15] = 1, this
            },
            lookAt: function() {
                var a, b, c;
                return function(d, e, f) {
                    void 0 === a && (a = new i, b = new i, c = new i);
                    var g = this.elements;
                    return c.subVectors(d, e).normalize(), 0 === c.lengthSq() && (c.z = 1), a.crossVectors(f, c).normalize(), 0 === a.lengthSq() && (c.z += 1e-4, a.crossVectors(f, c).normalize()), b.crossVectors(c, a), g[0] = a.x, g[4] = b.x, g[8] = c.x, g[1] = a.y, g[5] = b.y, g[9] = c.y, g[2] = a.z, g[6] = b.z, g[10] = c.z, this
                }
            }(),
            multiply: function(a, b) {
                return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
            },
            premultiply: function(a) {
                return this.multiplyMatrices(a, this)
            },
            multiplyMatrices: function(a, b) {
                var c = a.elements,
                    d = b.elements,
                    e = this.elements,
                    f = c[0],
                    g = c[4],
                    h = c[8],
                    i = c[12],
                    j = c[1],
                    k = c[5],
                    l = c[9],
                    m = c[13],
                    n = c[2],
                    o = c[6],
                    p = c[10],
                    q = c[14],
                    r = c[3],
                    s = c[7],
                    t = c[11],
                    c = c[15],
                    u = d[0],
                    v = d[4],
                    w = d[8],
                    x = d[12],
                    y = d[1],
                    z = d[5],
                    A = d[9],
                    B = d[13],
                    C = d[2],
                    D = d[6],
                    E = d[10],
                    F = d[14],
                    G = d[3],
                    H = d[7],
                    I = d[11],
                    d = d[15];
                return e[0] = f * u + g * y + h * C + i * G, e[4] = f * v + g * z + h * D + i * H, e[8] = f * w + g * A + h * E + i * I, e[12] = f * x + g * B + h * F + i * d, e[1] = j * u + k * y + l * C + m * G, e[5] = j * v + k * z + l * D + m * H, e[9] = j * w + k * A + l * E + m * I, e[13] = j * x + k * B + l * F + m * d, e[2] = n * u + o * y + p * C + q * G, e[6] = n * v + o * z + p * D + q * H, e[10] = n * w + o * A + p * E + q * I, e[14] = n * x + o * B + p * F + q * d, e[3] = r * u + s * y + t * C + c * G, e[7] = r * v + s * z + t * D + c * H, e[11] = r * w + s * A + t * E + c * I, e[15] = r * x + s * B + t * F + c * d, this
            },
            multiplyToArray: function(a, b, c) {
                var d = this.elements;
                return this.multiplyMatrices(a, b), c[0] = d[0], c[1] = d[1], c[2] = d[2], c[3] = d[3], c[4] = d[4], c[5] = d[5], c[6] = d[6], c[7] = d[7], c[8] = d[8], c[9] = d[9], c[10] = d[10], c[11] = d[11], c[12] = d[12], c[13] = d[13], c[14] = d[14], c[15] = d[15], this
            },
            multiplyScalar: function(a) {
                var b = this.elements;
                return b[0] *= a, b[4] *= a, b[8] *= a, b[12] *= a, b[1] *= a, b[5] *= a, b[9] *= a, b[13] *= a, b[2] *= a, b[6] *= a, b[10] *= a, b[14] *= a, b[3] *= a, b[7] *= a, b[11] *= a, b[15] *= a, this
            },
            applyToVector3Array: function() {
                var a;
                return function(b, c, d) {
                    void 0 === a && (a = new i), void 0 === c && (c = 0), void 0 === d && (d = b.length);
                    for (var e = 0; e < d; e += 3, c += 3) a.fromArray(b, c), a.applyMatrix4(this), a.toArray(b, c);
                    return b
                }
            }(),
            applyToBuffer: function() {
                var a;
                return function(b, c, d) {
                    void 0 === a && (a = new i), void 0 === c && (c = 0), void 0 === d && (d = b.length / b.itemSize);
                    for (var e = 0; e < d; e++, c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix4(this), b.setXYZ(a.x, a.y, a.z);
                    return b
                }
            }(),
            determinant: function() {
                var a = this.elements,
                    b = a[0],
                    c = a[4],
                    d = a[8],
                    e = a[12],
                    f = a[1],
                    g = a[5],
                    h = a[9],
                    i = a[13],
                    j = a[2],
                    k = a[6],
                    l = a[10],
                    m = a[14];
                return a[3] * (+e * h * k - d * i * k - e * g * l + c * i * l + d * g * m - c * h * m) + a[7] * (+b * h * m - b * i * l + e * f * l - d * f * m + d * i * j - e * h * j) + a[11] * (+b * i * k - b * g * m - e * f * k + c * f * m + e * g * j - c * i * j) + a[15] * (-d * g * j - b * h * k + b * g * l + d * f * k - c * f * l + c * h * j)
            },
            transpose: function() {
                var a, b = this.elements;
                return a = b[1], b[1] = b[4], b[4] = a, a = b[2], b[2] = b[8], b[8] = a, a = b[6], b[6] = b[9], b[9] = a, a = b[3], b[3] = b[12], b[12] = a, a = b[7], b[7] = b[13], b[13] = a, a = b[11], b[11] = b[14], b[14] = a, this
            },
            flattenToArrayOffset: function(a, b) {
                return console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead."), this.toArray(a, b)
            },
            getPosition: function() {
                var a;
                return function() {
                    return void 0 === a && (a = new i), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), a.setFromMatrixColumn(this, 3)
                }
            }(),
            setPosition: function(a) {
                var b = this.elements;
                return b[12] = a.x, b[13] = a.y, b[14] = a.z, this
            },
            getInverse: function(a, b) {
                var c = this.elements,
                    d = a.elements,
                    e = d[0],
                    f = d[1],
                    g = d[2],
                    h = d[3],
                    i = d[4],
                    j = d[5],
                    k = d[6],
                    l = d[7],
                    m = d[8],
                    n = d[9],
                    o = d[10],
                    p = d[11],
                    q = d[12],
                    r = d[13],
                    s = d[14],
                    d = d[15],
                    t = n * s * l - r * o * l + r * k * p - j * s * p - n * k * d + j * o * d,
                    u = q * o * l - m * s * l - q * k * p + i * s * p + m * k * d - i * o * d,
                    v = m * r * l - q * n * l + q * j * p - i * r * p - m * j * d + i * n * d,
                    w = q * n * k - m * r * k - q * j * o + i * r * o + m * j * s - i * n * s,
                    x = e * t + f * u + g * v + h * w;
                if (0 === x) {
                    if (!0 === b) throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
                    return console.warn("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0"), this.identity()
                }
                return x = 1 / x, c[0] = t * x, c[1] = (r * o * h - n * s * h - r * g * p + f * s * p + n * g * d - f * o * d) * x, c[2] = (j * s * h - r * k * h + r * g * l - f * s * l - j * g * d + f * k * d) * x, c[3] = (n * k * h - j * o * h - n * g * l + f * o * l + j * g * p - f * k * p) * x, c[4] = u * x, c[5] = (m * s * h - q * o * h + q * g * p - e * s * p - m * g * d + e * o * d) * x, c[6] = (q * k * h - i * s * h - q * g * l + e * s * l + i * g * d - e * k * d) * x, c[7] = (i * o * h - m * k * h + m * g * l - e * o * l - i * g * p + e * k * p) * x, c[8] = v * x, c[9] = (q * n * h - m * r * h - q * f * p + e * r * p + m * f * d - e * n * d) * x, c[10] = (i * r * h - q * j * h + q * f * l - e * r * l - i * f * d + e * j * d) * x, c[11] = (m * j * h - i * n * h - m * f * l + e * n * l + i * f * p - e * j * p) * x, c[12] = w * x, c[13] = (m * r * g - q * n * g + q * f * o - e * r * o - m * f * s + e * n * s) * x, c[14] = (q * j * g - i * r * g - q * f * k + e * r * k + i * f * s - e * j * s) * x, c[15] = (i * n * g - m * j * g + m * f * k - e * n * k - i * f * o + e * j * o) * x, this
            },
            scale: function(a) {
                var b = this.elements,
                    c = a.x,
                    d = a.y;
                return a = a.z, b[0] *= c, b[4] *= d, b[8] *= a, b[1] *= c, b[5] *= d, b[9] *= a, b[2] *= c, b[6] *= d, b[10] *= a, b[3] *= c, b[7] *= d, b[11] *= a, this
            },
            getMaxScaleOnAxis: function() {
                var a = this.elements;
                return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10]))
            },
            makeTranslation: function(a, b, c) {
                return this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1), this
            },
            makeRotationX: function(a) {
                var b = Math.cos(a);
                return a = Math.sin(a), this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1), this
            },
            makeRotationY: function(a) {
                var b = Math.cos(a);
                return a = Math.sin(a), this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1), this
            },
            makeRotationZ: function(a) {
                var b = Math.cos(a);
                return a = Math.sin(a), this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
            },
            makeRotationAxis: function(a, b) {
                var c = Math.cos(b),
                    d = Math.sin(b),
                    e = 1 - c,
                    f = a.x,
                    g = a.y,
                    h = a.z,
                    i = e * f,
                    j = e * g;
                return this.set(i * f + c, i * g - d * h, i * h + d * g, 0, i * g + d * h, j * g + c, j * h - d * f, 0, i * h - d * g, j * h + d * f, e * h * h + c, 0, 0, 0, 0, 1), this
            },
            makeScale: function(a, b, c) {
                return this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1), this
            },
            compose: function(a, b, c) {
                return this.makeRotationFromQuaternion(b), this.scale(c), this.setPosition(a), this
            },
            decompose: function() {
                var a, b;
                return function(c, d, e) {
                    void 0 === a && (a = new i, b = new j);
                    var f = this.elements,
                        g = a.set(f[0], f[1], f[2]).length(),
                        h = a.set(f[4], f[5], f[6]).length(),
                        k = a.set(f[8], f[9], f[10]).length();
                    0 > this.determinant() && (g = -g), c.x = f[12], c.y = f[13], c.z = f[14], b.elements.set(this.elements), c = 1 / g;
                    var f = 1 / h,
                        l = 1 / k;
                    return b.elements[0] *= c, b.elements[1] *= c, b.elements[2] *= c, b.elements[4] *= f, b.elements[5] *= f, b.elements[6] *= f, b.elements[8] *= l, b.elements[9] *= l, b.elements[10] *= l, d.setFromRotationMatrix(b), e.x = g, e.y = h, e.z = k, this
                }
            }(),
            makeFrustum: function(a, b, c, d, e, f) {
                var g = this.elements;
                return g[0] = 2 * e / (b - a), g[4] = 0, g[8] = (b + a) / (b - a), g[12] = 0, g[1] = 0, g[5] = 2 * e / (d - c), g[9] = (d + c) / (d - c), g[13] = 0, g[2] = 0, g[6] = 0, g[10] = -(f + e) / (f - e), g[14] = -2 * f * e / (f - e), g[3] = 0, g[7] = 0, g[11] = -1, g[15] = 0, this
            },
            makePerspective: function(b, c, d, e) {
                b = d * Math.tan(a.Math.DEG2RAD * b * .5);
                var f = -b;
                return this.makeFrustum(f * c, b * c, f, b, d, e)
            },
            makeOrthographic: function(a, b, c, d, e, f) {
                var g = this.elements,
                    h = 1 / (b - a),
                    i = 1 / (c - d),
                    j = 1 / (f - e);
                return g[0] = 2 * h, g[4] = 0, g[8] = 0, g[12] = -((b + a) * h), g[1] = 0, g[5] = 2 * i, g[9] = 0, g[13] = -((c + d) * i), g[2] = 0, g[6] = 0, g[10] = -2 * j, g[14] = -((f + e) * j), g[3] = 0, g[7] = 0, g[11] = 0, g[15] = 1, this
            },
            equals: function(a) {
                var b = this.elements;
                a = a.elements;
                for (var c = 0; 16 > c; c++)
                    if (b[c] !== a[c]) return !1;
                return !0
            },
            fromArray: function(a, b) {
                void 0 === b && (b = 0);
                for (var c = 0; 16 > c; c++) this.elements[c] = a[c + b];
                return this
            },
            toArray: function(a, b) {
                void 0 === a && (a = []), void 0 === b && (b = 0);
                var c = this.elements;
                return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a[b + 9] = c[9], a[b + 10] = c[10], a[b + 11] = c[11], a[b + 12] = c[12], a[b + 13] = c[13], a[b + 14] = c[14], a[b + 15] = c[15], a
            }
        }, k.prototype = Object.create(d.prototype), k.prototype.constructor = k, k.prototype.isCubeTexture = !0, Object.defineProperty(k.prototype, "images", {
            get: function() {
                return this.image
            },
            set: function(a) {
                this.image = a
            }
        });
        var Nd = new d,
            Od = new k,
            Pd = [],
            Qd = [];
        O.prototype.setValue = function(a, b) {
            for (var c = this.seq, d = 0, e = c.length; d !== e; ++d) {
                var f = c[d];
                f.setValue(a, b[f.id])
            }
        };
        var Rd = /([\w\d_]+)(\])?(\[|\.)?/g;
        P.prototype.setValue = function(a, b, c) {
            b = this.map[b], void 0 !== b && b.setValue(a, c, this.renderer)
        }, P.prototype.set = function(a, b, c) {
            var d = this.map[c];
            void 0 !== d && d.setValue(a, b[c], this.renderer)
        }, P.prototype.setOptional = function(a, b, c) {
            b = b[c], void 0 !== b && this.setValue(a, c, b)
        }, P.upload = function(a, b, c, d) {
            for (var e = 0, f = b.length; e !== f; ++e) {
                var g = b[e],
                    h = c[g.id];
                !1 !== h.needsUpdate && g.setValue(a, h.value, d)
            }
        }, P.seqWithValue = function(a, b) {
            for (var c = [], d = 0, e = a.length; d !== e; ++d) {
                var f = a[d];
                f.id in b && c.push(f)
            }
            return c
        }, P.splitDynamic = function(a, b) {
            for (var c = null, d = a.length, e = 0, f = 0; f !== d; ++f) {
                var g = a[f],
                    h = b[g.id];
                h && !0 === h.dynamic ? (null === c && (c = []), c.push(g)) : (e < f && (a[e] = g), ++e)
            }
            return e < d && (a.length = e), c
        }, P.evalDynamic = function(a, b, c, d, e) {
            for (var f = 0, g = a.length; f !== g; ++f) {
                var h = b[a[f].id],
                    i = h.onUpdateCallback;
                void 0 !== i && i.call(h, c, d, e)
            }
        }, a.UniformsUtils = {
            merge: function(a) {
                for (var b = {}, c = 0; c < a.length; c++) {
                    var d, e = this.clone(a[c]);
                    for (d in e) b[d] = e[d]
                }
                return b
            },
            clone: function(a) {
                var b, c = {};
                for (b in a) {
                    c[b] = {};
                    for (var d in a[b]) {
                        var e = a[b][d];
                        e && e.isColor || e && e.isVector2 || e && e.isVector3 || e && e.isVector4 || e && e.isMatrix3 || e && e.isMatrix4 || e && e.isTexture ? c[b][d] = e.clone() : Array.isArray(e) ? c[b][d] = e.slice() : c[b][d] = e
                    }
                }
                return c
            }
        };
        var Sd = {
            alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
            alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
            alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
            aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
            aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
            begin_vertex: "\nvec3 transformed = vec3( position );\n",
            beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
            bsdfs: "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
            bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
            clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n#endif\n",
            clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
            clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n",
            clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
            color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
            color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
            color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
            color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
            common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n",
            cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
            defaultnormal_vertex: "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n",
            displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
            displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
            emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
            emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
            encodings_fragment: "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
            encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n",
            envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
            envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
            envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
            envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
            fog_fragment: "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
            fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
            lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
            lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
            lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
            lights_pars: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#include <normal_flip>\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#include <normal_flip>\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
            lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
            lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
            lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
            lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
            lights_template: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
            logdepthbuf_fragment: "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
            logdepthbuf_pars_fragment: "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n",
            logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif",
            logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n",
            map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
            map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
            map_particle_fragment: "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
            map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n",
            metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n",
            metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
            morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
            morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
            morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
            normal_flip: "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n",
            normal_fragment: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
            normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n",
            packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
            premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
            project_vertex: "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n",
            roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n",
            roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
            shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
            shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
            shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
            shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
            skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
            skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
            skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n",
            skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
            specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
            specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
            tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
            tonemapping_pars_fragment: "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
            uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
            uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n",
            uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
            uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
            uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
            uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
            worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n",
            cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n",
            cube_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
            depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
            depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
            distanceRGBA_frag: "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n",
            distanceRGBA_vert: "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n",
            equirect_frag: "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
            equirect_vert: "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
            linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
            meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n",
            meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n",
            meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n",
            meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n",
            normal_frag: "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n",
            normal_vert: "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
            points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
            points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n",
            shadow_frag: "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n",
            shadow_vert: "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n"
        };
        Q.prototype = {
            constructor: Q,
            isColor: !0,
            r: 1,
            g: 1,
            b: 1,
            set: function(a) {
                return a && a.isColor ? this.copy(a) : "number" == typeof a ? this.setHex(a) : "string" == typeof a && this.setStyle(a), this
            },
            setScalar: function(a) {
                this.b = this.g = this.r = a
            },
            setHex: function(a) {
                return a = Math.floor(a), this.r = (a >> 16 & 255) / 255, this.g = (a >> 8 & 255) / 255, this.b = (255 & a) / 255, this
            },
            setRGB: function(a, b, c) {
                return this.r = a, this.g = b, this.b = c, this
            },
            setHSL: function() {
                function b(a, b, c) {
                    return 0 > c && (c += 1), 1 < c && --c, c < 1 / 6 ? a + 6 * (b - a) * c : .5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a
                }
                return function(c, d, e) {
                    return c = a.Math.euclideanModulo(c, 1), d = a.Math.clamp(d, 0, 1), e = a.Math.clamp(e, 0, 1), 0 === d ? this.r = this.g = this.b = e : (d = .5 >= e ? e * (1 + d) : e + d - e * d, e = 2 * e - d, this.r = b(e, d, c + 1 / 3), this.g = b(e, d, c), this.b = b(e, d, c - 1 / 3)), this
                }
            }(),
            setStyle: function(b) {
                function c(a) {
                    void 0 !== a && 1 > parseFloat(a) && console.warn("THREE.Color: Alpha component of " + b + " will be ignored.")
                }
                var d;
                if (d = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(b)) {
                    var e = d[2];
                    switch (d[1]) {
                        case "rgb":
                        case "rgba":
                            if (d = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(e)) return this.r = Math.min(255, parseInt(d[1], 10)) / 255, this.g = Math.min(255, parseInt(d[2], 10)) / 255, this.b = Math.min(255, parseInt(d[3], 10)) / 255, c(d[5]), this;
                            if (d = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(e)) return this.r = Math.min(100, parseInt(d[1], 10)) / 100, this.g = Math.min(100, parseInt(d[2], 10)) / 100, this.b = Math.min(100, parseInt(d[3], 10)) / 100, c(d[5]), this;
                            break;
                        case "hsl":
                        case "hsla":
                            if (d = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(e)) {
                                var e = parseFloat(d[1]) / 360,
                                    f = parseInt(d[2], 10) / 100,
                                    g = parseInt(d[3], 10) / 100;
                                return c(d[5]), this.setHSL(e, f, g)
                            }
                    }
                } else if (d = /^\#([A-Fa-f0-9]+)$/.exec(b)) {
                    if (d = d[1], e = d.length, 3 === e) return this.r = parseInt(d.charAt(0) + d.charAt(0), 16) / 255, this.g = parseInt(d.charAt(1) + d.charAt(1), 16) / 255, this.b = parseInt(d.charAt(2) + d.charAt(2), 16) / 255, this;
                    if (6 === e) return this.r = parseInt(d.charAt(0) + d.charAt(1), 16) / 255, this.g = parseInt(d.charAt(2) + d.charAt(3), 16) / 255, this.b = parseInt(d.charAt(4) + d.charAt(5), 16) / 255, this
                }
                return b && 0 < b.length && (d = a.ColorKeywords[b], void 0 !== d ? this.setHex(d) : console.warn("THREE.Color: Unknown color " + b)), this
            },
            clone: function() {
                return new this.constructor(this.r, this.g, this.b)
            },
            copy: function(a) {
                return this.r = a.r, this.g = a.g, this.b = a.b, this
            },
            copyGammaToLinear: function(a, b) {
                return void 0 === b && (b = 2), this.r = Math.pow(a.r, b), this.g = Math.pow(a.g, b), this.b = Math.pow(a.b, b), this
            },
            copyLinearToGamma: function(a, b) {
                void 0 === b && (b = 2);
                var c = 0 < b ? 1 / b : 1;
                return this.r = Math.pow(a.r, c), this.g = Math.pow(a.g, c), this.b = Math.pow(a.b, c), this
            },
            convertGammaToLinear: function() {
                var a = this.r,
                    b = this.g,
                    c = this.b;
                return this.r = a * a, this.g = b * b, this.b = c * c, this
            },
            convertLinearToGamma: function() {
                return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
            },
            getHex: function() {
                return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
            },
            getHexString: function() {
                return ("000000" + this.getHex().toString(16)).slice(-6)
            },
            getHSL: function(a) {
                a = a || {
                    h: 0,
                    s: 0,
                    l: 0
                };
                var b, c = this.r,
                    d = this.g,
                    e = this.b,
                    f = Math.max(c, d, e),
                    g = Math.min(c, d, e),
                    h = (g + f) / 2;
                if (g === f) g = b = 0;
                else {
                    var i = f - g,
                        g = .5 >= h ? i / (f + g) : i / (2 - f - g);
                    switch (f) {
                        case c:
                            b = (d - e) / i + (d < e ? 6 : 0);
                            break;
                        case d:
                            b = (e - c) / i + 2;
                            break;
                        case e:
                            b = (c - d) / i + 4
                    }
                    b /= 6
                }
                return a.h = b, a.s = g, a.l = h, a
            },
            getStyle: function() {
                return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
            },
            offsetHSL: function(a, b, c) {
                var d = this.getHSL();
                return d.h += a, d.s += b, d.l += c, this.setHSL(d.h, d.s, d.l), this
            },
            add: function(a) {
                return this.r += a.r, this.g += a.g, this.b += a.b, this
            },
            addColors: function(a, b) {
                return this.r = a.r + b.r, this.g = a.g + b.g, this.b = a.b + b.b, this
            },
            addScalar: function(a) {
                return this.r += a, this.g += a, this.b += a, this
            },
            sub: function(a) {
                return this.r = Math.max(0, this.r - a.r), this.g = Math.max(0, this.g - a.g), this.b = Math.max(0, this.b - a.b), this
            },
            multiply: function(a) {
                return this.r *= a.r, this.g *= a.g, this.b *= a.b, this
            },
            multiplyScalar: function(a) {
                return this.r *= a, this.g *= a, this.b *= a, this
            },
            lerp: function(a, b) {
                return this.r += (a.r - this.r) * b, this.g += (a.g - this.g) * b, this.b += (a.b - this.b) * b, this
            },
            equals: function(a) {
                return a.r === this.r && a.g === this.g && a.b === this.b
            },
            fromArray: function(a, b) {
                return void 0 === b && (b = 0), this.r = a[b], this.g = a[b + 1], this.b = a[b + 2], this
            },
            toArray: function(a, b) {
                return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this.r, a[b + 1] = this.g, a[b + 2] = this.b, a
            },
            toJSON: function() {
                return this.getHex()
            }
        }, a.ColorKeywords = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        };
        var Td = {
                common: {
                    diffuse: {
                        value: new Q(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    offsetRepeat: {
                        value: new e(0, 0, 1, 1)
                    },
                    specularMap: {
                        value: null
                    },
                    alphaMap: {
                        value: null
                    },
                    envMap: {
                        value: null
                    },
                    flipEnvMap: {
                        value: -1
                    },
                    reflectivity: {
                        value: 1
                    },
                    refractionRatio: {
                        value: .98
                    }
                },
                aomap: {
                    aoMap: {
                        value: null
                    },
                    aoMapIntensity: {
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        value: null
                    },
                    lightMapIntensity: {
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        value: null
                    },
                    bumpScale: {
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        value: null
                    },
                    normalScale: {
                        value: new c(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        value: null
                    },
                    displacementScale: {
                        value: 1
                    },
                    displacementBias: {
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        value: 25e-5
                    },
                    fogNear: {
                        value: 1
                    },
                    fogFar: {
                        value: 2e3
                    },
                    fogColor: {
                        value: new Q(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        value: []
                    },
                    directionalLights: {
                        value: [],
                        properties: {
                            direction: {},
                            color: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    directionalShadowMap: {
                        value: []
                    },
                    directionalShadowMatrix: {
                        value: []
                    },
                    spotLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            direction: {},
                            distance: {},
                            coneCos: {},
                            penumbraCos: {},
                            decay: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    spotShadowMap: {
                        value: []
                    },
                    spotShadowMatrix: {
                        value: []
                    },
                    pointLights: {
                        value: [],
                        properties: {
                            color: {},
                            position: {},
                            decay: {},
                            distance: {},
                            shadow: {},
                            shadowBias: {},
                            shadowRadius: {},
                            shadowMapSize: {}
                        }
                    },
                    pointShadowMap: {
                        value: []
                    },
                    pointShadowMatrix: {
                        value: []
                    },
                    hemisphereLights: {
                        value: [],
                        properties: {
                            direction: {},
                            skyColor: {},
                            groundColor: {}
                        }
                    }
                },
                points: {
                    diffuse: {
                        value: new Q(15658734)
                    },
                    opacity: {
                        value: 1
                    },
                    size: {
                        value: 1
                    },
                    scale: {
                        value: 1
                    },
                    map: {
                        value: null
                    },
                    offsetRepeat: {
                        value: new e(0, 0, 1, 1)
                    }
                }
            },
            Ud = {
                basic: {
                    uniforms: a.UniformsUtils.merge([Td.common, Td.aomap, Td.fog]),
                    vertexShader: Sd.meshbasic_vert,
                    fragmentShader: Sd.meshbasic_frag
                },
                lambert: {
                    uniforms: a.UniformsUtils.merge([Td.common, Td.aomap, Td.lightmap, Td.emissivemap, Td.fog, Td.lights, {
                        emissive: {
                            value: new Q(0)
                        }
                    }]),
                    vertexShader: Sd.meshlambert_vert,
                    fragmentShader: Sd.meshlambert_frag
                },
                phong: {
                    uniforms: a.UniformsUtils.merge([Td.common, Td.aomap, Td.lightmap, Td.emissivemap, Td.bumpmap, Td.normalmap, Td.displacementmap, Td.fog, Td.lights, {
                        emissive: {
                            value: new Q(0)
                        },
                        specular: {
                            value: new Q(1118481)
                        },
                        shininess: {
                            value: 30
                        }
                    }]),
                    vertexShader: Sd.meshphong_vert,
                    fragmentShader: Sd.meshphong_frag
                },
                standard: {
                    uniforms: a.UniformsUtils.merge([Td.common, Td.aomap, Td.lightmap, Td.emissivemap, Td.bumpmap, Td.normalmap, Td.displacementmap, Td.roughnessmap, Td.metalnessmap, Td.fog, Td.lights, {
                        emissive: {
                            value: new Q(0)
                        },
                        roughness: {
                            value: .5
                        },
                        metalness: {
                            value: 0
                        },
                        envMapIntensity: {
                            value: 1
                        }
                    }]),
                    vertexShader: Sd.meshphysical_vert,
                    fragmentShader: Sd.meshphysical_frag
                },
                points: {
                    uniforms: a.UniformsUtils.merge([Td.points, Td.fog]),
                    vertexShader: Sd.points_vert,
                    fragmentShader: Sd.points_frag
                },
                dashed: {
                    uniforms: a.UniformsUtils.merge([Td.common, Td.fog, {
                        scale: {
                            value: 1
                        },
                        dashSize: {
                            value: 1
                        },
                        totalSize: {
                            value: 2
                        }
                    }]),
                    vertexShader: Sd.linedashed_vert,
                    fragmentShader: Sd.linedashed_frag
                },
                depth: {
                    uniforms: a.UniformsUtils.merge([Td.common, Td.displacementmap]),
                    vertexShader: Sd.depth_vert,
                    fragmentShader: Sd.depth_frag
                },
                normal: {
                    uniforms: {
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: Sd.normal_vert,
                    fragmentShader: Sd.normal_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        },
                        opacity: {
                            value: 1
                        }
                    },
                    vertexShader: Sd.cube_vert,
                    fragmentShader: Sd.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            value: null
                        },
                        tFlip: {
                            value: -1
                        }
                    },
                    vertexShader: Sd.equirect_vert,
                    fragmentShader: Sd.equirect_frag
                },
                distanceRGBA: {
                    uniforms: {
                        lightPos: {
                            value: new i
                        }
                    },
                    vertexShader: Sd.distanceRGBA_vert,
                    fragmentShader: Sd.distanceRGBA_frag
                }
            };
        Ud.physical = {
            uniforms: a.UniformsUtils.merge([Ud.standard.uniforms, {
                clearCoat: {
                    value: 0
                },
                clearCoatRoughness: {
                    value: 0
                }
            }]),
            vertexShader: Sd.meshphysical_vert,
            fragmentShader: Sd.meshphysical_frag
        }, R.prototype = {
            constructor: R,
            set: function(a, b) {
                return this.min.copy(a), this.max.copy(b), this
            },
            setFromPoints: function(a) {
                this.makeEmpty();
                for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
                return this
            },
            setFromCenterAndSize: function() {
                var a = new c;
                return function(b, c) {
                    var d = a.copy(c).multiplyScalar(.5);
                    return this.min.copy(b).sub(d), this.max.copy(b).add(d), this
                }
            }(),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(a) {
                return this.min.copy(a.min), this.max.copy(a.max), this
            },
            makeEmpty: function() {
                return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -(1 / 0), this
            },
            isEmpty: function() {
                return this.max.x < this.min.x || this.max.y < this.min.y
            },
            getCenter: function(a) {
                return a = a || new c, this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function(a) {
                return a = a || new c, this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min)
            },
            expandByPoint: function(a) {
                return this.min.min(a), this.max.max(a), this
            },
            expandByVector: function(a) {
                return this.min.sub(a), this.max.add(a), this
            },
            expandByScalar: function(a) {
                return this.min.addScalar(-a), this.max.addScalar(a), this
            },
            containsPoint: function(a) {
                return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y)
            },
            containsBox: function(a) {
                return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y
            },
            getParameter: function(a, b) {
                return (b || new c).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
            },
            intersectsBox: function(a) {
                return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y)
            },
            clampPoint: function(a, b) {
                return (b || new c).copy(a).clamp(this.min, this.max)
            },
            distanceToPoint: function() {
                var a = new c;
                return function(b) {
                    return a.copy(b).clamp(this.min, this.max).sub(b).length()
                }
            }(),
            intersect: function(a) {
                return this.min.max(a.min), this.max.min(a.max), this
            },
            union: function(a) {
                return this.min.min(a.min), this.max.max(a.max), this
            },
            translate: function(a) {
                return this.min.add(a), this.max.add(a), this
            },
            equals: function(a) {
                return a.min.equals(this.min) && a.max.equals(this.max)
            }
        }, U.prototype = {
            constructor: U,
            isMaterial: !0,
            get needsUpdate() {
                return this._needsUpdate
            },
            set needsUpdate(a) {
                !0 === a && this.update(), this._needsUpdate = a
            },
            setValues: function(a) {
                if (void 0 !== a)
                    for (var b in a) {
                        var c = a[b];
                        if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined.");
                        else {
                            var d = this[b];
                            void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : d && d.isColor ? d.set(c) : d && d.isVector3 && c && c.isVector3 ? d.copy(c) : this[b] = "overdraw" === b ? Number(c) : c
                        }
                    }
            },
            toJSON: function(a) {
                function b(a) {
                    var b, c = [];
                    for (b in a) {
                        var d = a[b];
                        delete d.metadata, c.push(d)
                    }
                    return c
                }
                var c = void 0 === a;
                c && (a = {
                    textures: {},
                    images: {}
                });
                var d = {
                    metadata: {
                        version: 4.4,
                        type: "Material",
                        generator: "Material.toJSON"
                    }
                };
                return d.uuid = this.uuid, d.type = this.type, "" !== this.name && (d.name = this.name), this.color && this.color.isColor && (d.color = this.color.getHex()), void 0 !== this.roughness && (d.roughness = this.roughness), void 0 !== this.metalness && (d.metalness = this.metalness), this.emissive && this.emissive.isColor && (d.emissive = this.emissive.getHex()), this.specular && this.specular.isColor && (d.specular = this.specular.getHex()), void 0 !== this.shininess && (d.shininess = this.shininess), this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid), this.alphaMap && this.alphaMap.isTexture && (d.alphaMap = this.alphaMap.toJSON(a).uuid), this.lightMap && this.lightMap.isTexture && (d.lightMap = this.lightMap.toJSON(a).uuid), this.bumpMap && this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (d.normalMap = this.normalMap.toJSON(a).uuid, d.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (d.displacementMap = this.displacementMap.toJSON(a).uuid, d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid), this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid), this.emissiveMap && this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid), this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid), this.envMap && this.envMap.isTexture && (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity), void 0 !== this.size && (d.size = this.size), void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (d.blending = this.blending), 2 !== this.shading && (d.shading = this.shading), 0 !== this.side && (d.side = this.side), 0 !== this.vertexColors && (d.vertexColors = this.vertexColors), 1 > this.opacity && (d.opacity = this.opacity), !0 === this.transparent && (d.transparent = this.transparent), d.depthFunc = this.depthFunc, d.depthTest = this.depthTest, d.depthWrite = this.depthWrite, 0 < this.alphaTest && (d.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (d.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (d.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (d.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin), d.skinning = this.skinning, d.morphTargets = this.morphTargets, c && (c = b(a.textures), a = b(a.images), 0 < c.length && (d.textures = c), 0 < a.length && (d.images = a)), d
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(a) {
                this.name = a.name, this.fog = a.fog, this.lights = a.lights, this.blending = a.blending, this.side = a.side, this.shading = a.shading, this.vertexColors = a.vertexColors, this.opacity = a.opacity, this.transparent = a.transparent, this.blendSrc = a.blendSrc, this.blendDst = a.blendDst, this.blendEquation = a.blendEquation, this.blendSrcAlpha = a.blendSrcAlpha, this.blendDstAlpha = a.blendDstAlpha, this.blendEquationAlpha = a.blendEquationAlpha, this.depthFunc = a.depthFunc, this.depthTest = a.depthTest, this.depthWrite = a.depthWrite, this.colorWrite = a.colorWrite, this.precision = a.precision, this.polygonOffset = a.polygonOffset, this.polygonOffsetFactor = a.polygonOffsetFactor, this.polygonOffsetUnits = a.polygonOffsetUnits, this.alphaTest = a.alphaTest, this.premultipliedAlpha = a.premultipliedAlpha, this.overdraw = a.overdraw, this.visible = a.visible, this.clipShadows = a.clipShadows, a = a.clippingPlanes;
                var b = null;
                if (null !== a)
                    for (var c = a.length, b = Array(c), d = 0; d !== c; ++d) b[d] = a[d].clone();
                return this.clippingPlanes = b, this
            },
            update: function() {
                this.dispatchEvent({
                    type: "update"
                })
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }, Object.assign(U.prototype, b.prototype);
        var Vd = 0;
        V.prototype = Object.create(U.prototype), V.prototype.constructor = V, V.prototype.isShaderMaterial = !0, V.prototype.copy = function(b) {
            return U.prototype.copy.call(this, b), this.fragmentShader = b.fragmentShader, this.vertexShader = b.vertexShader, this.uniforms = a.UniformsUtils.clone(b.uniforms), this.defines = b.defines, this.wireframe = b.wireframe, this.wireframeLinewidth = b.wireframeLinewidth, this.lights = b.lights, this.clipping = b.clipping, this.skinning = b.skinning, this.morphTargets = b.morphTargets, this.morphNormals = b.morphNormals, this.extensions = b.extensions, this
        }, V.prototype.toJSON = function(a) {
            return a = U.prototype.toJSON.call(this, a), a.uniforms = this.uniforms, a.vertexShader = this.vertexShader, a.fragmentShader = this.fragmentShader, a
        }, W.prototype = Object.create(U.prototype), W.prototype.constructor = W, W.prototype.isMeshDepthMaterial = !0, W.prototype.copy = function(a) {
            return U.prototype.copy.call(this, a), this.depthPacking = a.depthPacking, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.map = a.map, this.alphaMap = a.alphaMap, this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this
        }, X.prototype = {
            constructor: X,
            isBox3: !0,
            set: function(a, b) {
                return this.min.copy(a), this.max.copy(b), this
            },
            setFromArray: function(a) {
                for (var b = 1 / 0, c = 1 / 0, d = 1 / 0, e = -(1 / 0), f = -(1 / 0), g = -(1 / 0), h = 0, i = a.length; h < i; h += 3) {
                    var j = a[h],
                        k = a[h + 1],
                        l = a[h + 2];
                    j < b && (b = j), k < c && (c = k), l < d && (d = l), j > e && (e = j), k > f && (f = k), l > g && (g = l)
                }
                this.min.set(b, c, d), this.max.set(e, f, g)
            },
            setFromPoints: function(a) {
                this.makeEmpty();
                for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
                return this
            },
            setFromCenterAndSize: function() {
                var a = new i;
                return function(b, c) {
                    var d = a.copy(c).multiplyScalar(.5);
                    return this.min.copy(b).sub(d), this.max.copy(b).add(d), this
                }
            }(),
            setFromObject: function() {
                var a = new i;
                return function(b) {
                    var c = this;
                    return b.updateMatrixWorld(!0), this.makeEmpty(), b.traverse(function(b) {
                        var d = b.geometry;
                        if (void 0 !== d)
                            if (d && d.isGeometry)
                                for (var d = d.vertices, e = 0, f = d.length; e < f; e++) a.copy(d[e]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a);
                            else if (d && d.isBufferGeometry && (f = d.attributes.position, void 0 !== f)) {
                            var g;
                            for (f && f.isInterleavedBufferAttribute ? (d = f.data.array, e = f.offset, g = f.data.stride) : (d = f.array, e = 0, g = 3), f = d.length; e < f; e += g) a.fromArray(d, e), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a)
                        }
                    }), this
                }
            }(),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(a) {
                return this.min.copy(a.min), this.max.copy(a.max), this
            },
            makeEmpty: function() {
                return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -(1 / 0), this
            },
            isEmpty: function() {
                return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
            },
            getCenter: function(a) {
                return a = a || new i, this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
            },
            getSize: function(a) {
                return a = a || new i, this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min)
            },
            expandByPoint: function(a) {
                return this.min.min(a), this.max.max(a), this
            },
            expandByVector: function(a) {
                return this.min.sub(a), this.max.add(a), this
            },
            expandByScalar: function(a) {
                return this.min.addScalar(-a), this.max.addScalar(a), this
            },
            containsPoint: function(a) {
                return !(a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z)
            },
            containsBox: function(a) {
                return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z
            },
            getParameter: function(a, b) {
                return (b || new i).set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
            },
            intersectsBox: function(a) {
                return !(a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z)
            },
            intersectsSphere: function() {
                var a;
                return function(b) {
                    return void 0 === a && (a = new i), this.clampPoint(b.center, a), a.distanceToSquared(b.center) <= b.radius * b.radius
                }
            }(),
            intersectsPlane: function(a) {
                var b, c;
                return 0 < a.normal.x ? (b = a.normal.x * this.min.x, c = a.normal.x * this.max.x) : (b = a.normal.x * this.max.x, c = a.normal.x * this.min.x), 0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c += a.normal.y * this.min.y), 0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, c += a.normal.z * this.min.z), b <= a.constant && c >= a.constant
            },
            clampPoint: function(a, b) {
                return (b || new i).copy(a).clamp(this.min, this.max)
            },
            distanceToPoint: function() {
                var a = new i;
                return function(b) {
                    return a.copy(b).clamp(this.min, this.max).sub(b).length()
                }
            }(),
            getBoundingSphere: function() {
                var a = new i;
                return function(b) {
                    return b = b || new Y, this.getCenter(b.center), b.radius = .5 * this.size(a).length(), b
                }
            }(),
            intersect: function(a) {
                return this.min.max(a.min), this.max.min(a.max), this.isEmpty() && this.makeEmpty(), this
            },
            union: function(a) {
                return this.min.min(a.min), this.max.max(a.max), this
            },
            applyMatrix4: function() {
                var a = [new i, new i, new i, new i, new i, new i, new i, new i];
                return function(b) {
                    return this.isEmpty() ? this : (a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b), a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b), a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b), a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b), a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b), a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b), a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b), a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b), this.setFromPoints(a), this)
                }
            }(),
            translate: function(a) {
                return this.min.add(a), this.max.add(a), this
            },
            equals: function(a) {
                return a.min.equals(this.min) && a.max.equals(this.max)
            }
        }, Y.prototype = {
            constructor: Y,
            set: function(a, b) {
                return this.center.copy(a), this.radius = b, this
            },
            setFromPoints: function() {
                var a = new X;
                return function(b, c) {
                    var d = this.center;
                    void 0 !== c ? d.copy(c) : a.setFromPoints(b).getCenter(d);
                    for (var e = 0, f = 0, g = b.length; f < g; f++) e = Math.max(e, d.distanceToSquared(b[f]));
                    return this.radius = Math.sqrt(e), this
                }
            }(),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(a) {
                return this.center.copy(a.center), this.radius = a.radius, this
            },
            empty: function() {
                return 0 >= this.radius
            },
            containsPoint: function(a) {
                return a.distanceToSquared(this.center) <= this.radius * this.radius
            },
            distanceToPoint: function(a) {
                return a.distanceTo(this.center) - this.radius
            },
            intersectsSphere: function(a) {
                var b = this.radius + a.radius;
                return a.center.distanceToSquared(this.center) <= b * b
            },
            intersectsBox: function(a) {
                return a.intersectsSphere(this)
            },
            intersectsPlane: function(a) {
                return Math.abs(this.center.dot(a.normal) - a.constant) <= this.radius
            },
            clampPoint: function(a, b) {
                var c = this.center.distanceToSquared(a),
                    d = b || new i;
                return d.copy(a), c > this.radius * this.radius && (d.sub(this.center).normalize(), d.multiplyScalar(this.radius).add(this.center)), d
            },
            getBoundingBox: function(a) {
                return a = a || new X, a.set(this.center, this.center), a.expandByScalar(this.radius), a
            },
            applyMatrix4: function(a) {
                return this.center.applyMatrix4(a), this.radius *= a.getMaxScaleOnAxis(), this
            },
            translate: function(a) {
                return this.center.add(a), this
            },
            equals: function(a) {
                return a.center.equals(this.center) && a.radius === this.radius
            }
        }, Z.prototype = {
            constructor: Z,
            isMatrix3: !0,
            set: function(a, b, c, d, e, f, g, h, i) {
                var j = this.elements;
                return j[0] = a, j[1] = d, j[2] = g, j[3] = b, j[4] = e, j[5] = h, j[6] = c, j[7] = f, j[8] = i, this
            },
            identity: function() {
                return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
            },
            clone: function() {
                return (new this.constructor).fromArray(this.elements)
            },
            copy: function(a) {
                return a = a.elements, this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]), this
            },
            setFromMatrix4: function(a) {
                return a = a.elements, this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]), this
            },
            applyToVector3Array: function() {
                var a;
                return function(b, c, d) {
                    void 0 === a && (a = new i), void 0 === c && (c = 0), void 0 === d && (d = b.length);
                    for (var e = 0; e < d; e += 3, c += 3) a.fromArray(b, c), a.applyMatrix3(this), a.toArray(b, c);
                    return b
                }
            }(),
            applyToBuffer: function() {
                var a;
                return function(b, c, d) {
                    void 0 === a && (a = new i), void 0 === c && (c = 0), void 0 === d && (d = b.length / b.itemSize);
                    for (var e = 0; e < d; e++, c++) a.x = b.getX(c), a.y = b.getY(c), a.z = b.getZ(c), a.applyMatrix3(this), b.setXYZ(a.x, a.y, a.z);
                    return b
                }
            }(),
            multiplyScalar: function(a) {
                var b = this.elements;
                return b[0] *= a, b[3] *= a, b[6] *= a, b[1] *= a, b[4] *= a, b[7] *= a, b[2] *= a, b[5] *= a, b[8] *= a, this
            },
            determinant: function() {
                var a = this.elements,
                    b = a[0],
                    c = a[1],
                    d = a[2],
                    e = a[3],
                    f = a[4],
                    g = a[5],
                    h = a[6],
                    i = a[7],
                    a = a[8];
                return b * f * a - b * g * i - c * e * a + c * g * h + d * e * i - d * f * h
            },
            getInverse: function(a, b) {
                a && a.isMatrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
                var c = a.elements,
                    d = this.elements,
                    e = c[0],
                    f = c[1],
                    g = c[2],
                    h = c[3],
                    i = c[4],
                    j = c[5],
                    k = c[6],
                    l = c[7],
                    c = c[8],
                    m = c * i - j * l,
                    n = j * k - c * h,
                    o = l * h - i * k,
                    p = e * m + f * n + g * o;
                if (0 === p) {
                    if (!0 === b) throw Error("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");
                    return console.warn("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0"), this.identity()
                }
                return p = 1 / p, d[0] = m * p, d[1] = (g * l - c * f) * p, d[2] = (j * f - g * i) * p, d[3] = n * p, d[4] = (c * e - g * k) * p, d[5] = (g * h - j * e) * p, d[6] = o * p, d[7] = (f * k - l * e) * p, d[8] = (i * e - f * h) * p, this
            },
            transpose: function() {
                var a, b = this.elements;
                return a = b[1], b[1] = b[3], b[3] = a, a = b[2], b[2] = b[6], b[6] = a, a = b[5], b[5] = b[7], b[7] = a, this
            },
            flattenToArrayOffset: function(a, b) {
                return console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead."), this.toArray(a, b)
            },
            getNormalMatrix: function(a) {
                return this.setFromMatrix4(a).getInverse(this).transpose()
            },
            transposeIntoArray: function(a) {
                var b = this.elements;
                return a[0] = b[0], a[1] = b[3], a[2] = b[6], a[3] = b[1], a[4] = b[4], a[5] = b[7], a[6] = b[2], a[7] = b[5], a[8] = b[8], this
            },
            fromArray: function(a, b) {
                void 0 === b && (b = 0);
                for (var c = 0; 9 > c; c++) this.elements[c] = a[c + b];
                return this
            },
            toArray: function(a, b) {
                void 0 === a && (a = []), void 0 === b && (b = 0);
                var c = this.elements;
                return a[b] = c[0], a[b + 1] = c[1], a[b + 2] = c[2], a[b + 3] = c[3], a[b + 4] = c[4], a[b + 5] = c[5], a[b + 6] = c[6], a[b + 7] = c[7], a[b + 8] = c[8], a
            }
        }, $.prototype = {
            constructor: $,
            set: function(a, b) {
                return this.normal.copy(a), this.constant = b, this
            },
            setComponents: function(a, b, c, d) {
                return this.normal.set(a, b, c), this.constant = d, this
            },
            setFromNormalAndCoplanarPoint: function(a, b) {
                return this.normal.copy(a), this.constant = -b.dot(this.normal), this
            },
            setFromCoplanarPoints: function() {
                var a = new i,
                    b = new i;
                return function(c, d, e) {
                    return d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize(), this.setFromNormalAndCoplanarPoint(d, c), this
                }
            }(),
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(a) {
                return this.normal.copy(a.normal), this.constant = a.constant, this
            },
            normalize: function() {
                var a = 1 / this.normal.length();
                return this.normal.multiplyScalar(a), this.constant *= a, this
            },
            negate: function() {
                return this.constant *= -1, this.normal.negate(), this
            },
            distanceToPoint: function(a) {
                return this.normal.dot(a) + this.constant
            },
            distanceToSphere: function(a) {
                return this.distanceToPoint(a.center) - a.radius
            },
            projectPoint: function(a, b) {
                return this.orthoPoint(a, b).sub(a).negate()
            },
            orthoPoint: function(a, b) {
                var c = this.distanceToPoint(a);
                return (b || new i).copy(this.normal).multiplyScalar(c)
            },
            intersectLine: function() {
                var a = new i;
                return function(b, c) {
                    var d = c || new i,
                        e = b.delta(a),
                        f = this.normal.dot(e);
                    return 0 !== f ? (f = -(b.start.dot(this.normal) + this.constant) / f, 0 > f || 1 < f ? void 0 : d.copy(e).multiplyScalar(f).add(b.start)) : 0 === this.distanceToPoint(b.start) ? d.copy(b.start) : void 0
                }
            }(),
            intersectsLine: function(a) {
                var b = this.distanceToPoint(a.start);
                return a = this.distanceToPoint(a.end), 0 > b && 0 < a || 0 > a && 0 < b
            },
            intersectsBox: function(a) {
                return a.intersectsPlane(this)
            },
            intersectsSphere: function(a) {
                return a.intersectsPlane(this)
            },
            coplanarPoint: function(a) {
                return (a || new i).copy(this.normal).multiplyScalar(-this.constant)
            },
            applyMatrix4: function() {
                var a = new i,
                    b = new Z;
                return function(c, d) {
                    var e = this.coplanarPoint(a).applyMatrix4(c),
                        f = d || b.getNormalMatrix(c),
                        f = this.normal.applyMatrix3(f).normalize();
                    return this.constant = -e.dot(f), this
                }
            }(),
            translate: function(a) {
                return this.constant -= a.dot(this.normal), this
            },
            equals: function(a) {
                return a.normal.equals(this.normal) && a.constant === this.constant
            }
        }, _.prototype = {
            constructor: _,
            set: function(a, b, c, d, e, f) {
                var g = this.planes;
                return g[0].copy(a), g[1].copy(b), g[2].copy(c), g[3].copy(d), g[4].copy(e), g[5].copy(f), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(a) {
                for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
                return this
            },
            setFromMatrix: function(a) {
                var b = this.planes,
                    c = a.elements;
                a = c[0];
                var d = c[1],
                    e = c[2],
                    f = c[3],
                    g = c[4],
                    h = c[5],
                    i = c[6],
                    j = c[7],
                    k = c[8],
                    l = c[9],
                    m = c[10],
                    n = c[11],
                    o = c[12],
                    p = c[13],
                    q = c[14],
                    c = c[15];
                return b[0].setComponents(f - a, j - g, n - k, c - o).normalize(), b[1].setComponents(f + a, j + g, n + k, c + o).normalize(), b[2].setComponents(f + d, j + h, n + l, c + p).normalize(), b[3].setComponents(f - d, j - h, n - l, c - p).normalize(), b[4].setComponents(f - e, j - i, n - m, c - q).normalize(), b[5].setComponents(f + e, j + i, n + m, c + q).normalize(), this
            },
            intersectsObject: function() {
                var a = new Y;
                return function(b) {
                    var c = b.geometry;
                    return null === c.boundingSphere && c.computeBoundingSphere(), a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld), this.intersectsSphere(a)
                }
            }(),
            intersectsSprite: function() {
                var a = new Y;
                return function(b) {
                    return a.center.set(0, 0, 0), a.radius = .7071067811865476, a.applyMatrix4(b.matrixWorld), this.intersectsSphere(a)
                }
            }(),
            intersectsSphere: function(a) {
                var b = this.planes,
                    c = a.center;
                a = -a.radius;
                for (var d = 0; 6 > d; d++)
                    if (b[d].distanceToPoint(c) < a) return !1;
                return !0
            },
            intersectsBox: function() {
                var a = new i,
                    b = new i;
                return function(c) {
                    for (var d = this.planes, e = 0; 6 > e; e++) {
                        var f = d[e];
                        a.x = 0 < f.normal.x ? c.min.x : c.max.x, b.x = 0 < f.normal.x ? c.max.x : c.min.x, a.y = 0 < f.normal.y ? c.min.y : c.max.y, b.y = 0 < f.normal.y ? c.max.y : c.min.y, a.z = 0 < f.normal.z ? c.min.z : c.max.z, b.z = 0 < f.normal.z ? c.max.z : c.min.z;
                        var g = f.distanceToPoint(a),
                            f = f.distanceToPoint(b);
                        if (0 > g && 0 > f) return !1
                    }
                    return !0
                }
            }(),
            containsPoint: function(a) {
                for (var b = this.planes, c = 0; 6 > c; c++)
                    if (0 > b[c].distanceToPoint(a)) return !1;
                return !0
            }
        }, ba.prototype = {
            constructor: ba,
            set: function(a, b) {
                return this.origin.copy(a), this.direction.copy(b), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(a) {
                return this.origin.copy(a.origin), this.direction.copy(a.direction), this
            },
            at: function(a, b) {
                return (b || new i).copy(this.direction).multiplyScalar(a).add(this.origin)
            },
            lookAt: function(a) {
                return this.direction.copy(a).sub(this.origin).normalize(), this
            },
            recast: function() {
                var a = new i;
                return function(b) {
                    return this.origin.copy(this.at(b, a)), this
                }
            }(),
            closestPointToPoint: function(a, b) {
                var c = b || new i;
                c.subVectors(a, this.origin);
                var d = c.dot(this.direction);
                return 0 > d ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(d).add(this.origin)
            },
            distanceToPoint: function(a) {
                return Math.sqrt(this.distanceSqToPoint(a))
            },
            distanceSqToPoint: function() {
                var a = new i;
                return function(b) {
                    var c = a.subVectors(b, this.origin).dot(this.direction);
                    return 0 > c ? this.origin.distanceToSquared(b) : (a.copy(this.direction).multiplyScalar(c).add(this.origin), a.distanceToSquared(b))
                }
            }(),
            distanceSqToSegment: function() {
                var a = new i,
                    b = new i,
                    c = new i;
                return function(d, e, f, g) {
                    a.copy(d).add(e).multiplyScalar(.5), b.copy(e).sub(d).normalize(), c.copy(this.origin).sub(a);
                    var h, i = .5 * d.distanceTo(e),
                        j = -this.direction.dot(b),
                        k = c.dot(this.direction),
                        l = -c.dot(b),
                        m = c.lengthSq(),
                        n = Math.abs(1 - j * j);
                    return 0 < n ? (d = j * l - k, e = j * k - l, h = i * n, 0 <= d ? e >= -h ? e <= h ? (i = 1 / n, d *= i, e *= i, j = d * (d + j * e + 2 * k) + e * (j * d + e + 2 * l) + m) : (e = i, d = Math.max(0, -(j * e + k)), j = -d * d + e * (e + 2 * l) + m) : (e = -i, d = Math.max(0, -(j * e + k)), j = -d * d + e * (e + 2 * l) + m) : e <= -h ? (d = Math.max(0, -(-j * i + k)), e = 0 < d ? -i : Math.min(Math.max(-i, -l), i), j = -d * d + e * (e + 2 * l) + m) : e <= h ? (d = 0, e = Math.min(Math.max(-i, -l), i), j = e * (e + 2 * l) + m) : (d = Math.max(0, -(j * i + k)), e = 0 < d ? i : Math.min(Math.max(-i, -l), i), j = -d * d + e * (e + 2 * l) + m)) : (e = 0 < j ? -i : i, d = Math.max(0, -(j * e + k)), j = -d * d + e * (e + 2 * l) + m), f && f.copy(this.direction).multiplyScalar(d).add(this.origin), g && g.copy(b).multiplyScalar(e).add(a), j
                }
            }(),
            intersectSphere: function() {
                var a = new i;
                return function(b, c) {
                    a.subVectors(b.center, this.origin);
                    var d = a.dot(this.direction),
                        e = a.dot(a) - d * d,
                        f = b.radius * b.radius;
                    return e > f ? null : (f = Math.sqrt(f - e), e = d - f, d += f, 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c))
                }
            }(),
            intersectsSphere: function(a) {
                return this.distanceToPoint(a.center) <= a.radius
            },
            distanceToPlane: function(a) {
                var b = a.normal.dot(this.direction);
                return 0 === b ? 0 === a.distanceToPoint(this.origin) ? 0 : null : (a = -(this.origin.dot(a.normal) + a.constant) / b, 0 <= a ? a : null)
            },
            intersectPlane: function(a, b) {
                var c = this.distanceToPlane(a);
                return null === c ? null : this.at(c, b)
            },
            intersectsPlane: function(a) {
                var b = a.distanceToPoint(this.origin);
                return 0 === b || 0 > a.normal.dot(this.direction) * b
            },
            intersectBox: function(a, b) {
                var c, d, e, f, g;
                d = 1 / this.direction.x, f = 1 / this.direction.y, g = 1 / this.direction.z;
                var h = this.origin;
                return 0 <= d ? (c = (a.min.x - h.x) * d, d *= a.max.x - h.x) : (c = (a.max.x - h.x) * d, d *= a.min.x - h.x), 0 <= f ? (e = (a.min.y - h.y) * f, f *= a.max.y - h.y) : (e = (a.max.y - h.y) * f, f *= a.min.y - h.y), c > f || e > d ? null : ((e > c || c !== c) && (c = e), (f < d || d !== d) && (d = f), 0 <= g ? (e = (a.min.z - h.z) * g, g *= a.max.z - h.z) : (e = (a.max.z - h.z) * g, g *= a.min.z - h.z), c > g || e > d ? null : ((e > c || c !== c) && (c = e), (g < d || d !== d) && (d = g), 0 > d ? null : this.at(0 <= c ? c : d, b)))
            },
            intersectsBox: function() {
                var a = new i;
                return function(b) {
                    return null !== this.intersectBox(b, a)
                }
            }(),
            intersectTriangle: function() {
                var a = new i,
                    b = new i,
                    c = new i,
                    d = new i;
                return function(e, f, g, h, i) {
                    if (b.subVectors(f, e), c.subVectors(g, e), d.crossVectors(b, c), f = this.direction.dot(d), 0 < f) {
                        if (h) return null;
                        h = 1
                    } else {
                        if (!(0 > f)) return null;
                        h = -1, f = -f
                    }
                    return a.subVectors(this.origin, e), e = h * this.direction.dot(c.crossVectors(a, c)), 0 > e ? null : (g = h * this.direction.dot(b.cross(a)), 0 > g || e + g > f ? null : (e = -h * a.dot(d), 0 > e ? null : this.at(e / f, i)))
                }
            }(),
            applyMatrix4: function(a) {
                return this.direction.add(this.origin).applyMatrix4(a), this.origin.applyMatrix4(a), this.direction.sub(this.origin), this.direction.normalize(), this
            },
            equals: function(a) {
                return a.origin.equals(this.origin) && a.direction.equals(this.direction)
            }
        }, ca.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), ca.DefaultOrder = "XYZ", ca.prototype = {
            constructor: ca,
            isEuler: !0,
            get x() {
                return this._x
            },
            set x(a) {
                this._x = a, this.onChangeCallback()
            },
            get y() {
                return this._y
            },
            set y(a) {
                this._y = a, this.onChangeCallback()
            },
            get z() {
                return this._z
            },
            set z(a) {
                this._z = a, this.onChangeCallback()
            },
            get order() {
                return this._order
            },
            set order(a) {
                this._order = a, this.onChangeCallback()
            },
            set: function(a, b, c, d) {
                return this._x = a, this._y = b, this._z = c, this._order = d || this._order, this.onChangeCallback(), this
            },
            clone: function() {
                return new this.constructor(this._x, this._y, this._z, this._order)
            },
            copy: function(a) {
                return this._x = a._x, this._y = a._y, this._z = a._z, this._order = a._order, this.onChangeCallback(), this
            },
            setFromRotationMatrix: function(b, c, d) {
                var e = a.Math.clamp,
                    f = b.elements;
                b = f[0];
                var g = f[4],
                    h = f[8],
                    i = f[1],
                    j = f[5],
                    k = f[9],
                    l = f[2],
                    m = f[6],
                    f = f[10];
                return c = c || this._order, "XYZ" === c ? (this._y = Math.asin(e(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(-k, f), this._z = Math.atan2(-g, b)) : (this._x = Math.atan2(m, j), this._z = 0)) : "YXZ" === c ? (this._x = Math.asin(-e(k, -1, 1)), .99999 > Math.abs(k) ? (this._y = Math.atan2(h, f), this._z = Math.atan2(i, j)) : (this._y = Math.atan2(-l, b), this._z = 0)) : "ZXY" === c ? (this._x = Math.asin(e(m, -1, 1)), .99999 > Math.abs(m) ? (this._y = Math.atan2(-l, f), this._z = Math.atan2(-g, j)) : (this._y = 0, this._z = Math.atan2(i, b))) : "ZYX" === c ? (this._y = Math.asin(-e(l, -1, 1)), .99999 > Math.abs(l) ? (this._x = Math.atan2(m, f), this._z = Math.atan2(i, b)) : (this._x = 0, this._z = Math.atan2(-g, j))) : "YZX" === c ? (this._z = Math.asin(e(i, -1, 1)), .99999 > Math.abs(i) ? (this._x = Math.atan2(-k, j), this._y = Math.atan2(-l, b)) : (this._x = 0, this._y = Math.atan2(h, f))) : "XZY" === c ? (this._z = Math.asin(-e(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(m, j), this._y = Math.atan2(h, b)) : (this._x = Math.atan2(-k, f), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + c), this._order = c, !1 !== d && this.onChangeCallback(), this
            },
            setFromQuaternion: function() {
                var a;
                return function(b, c, d) {
                    return void 0 === a && (a = new j), a.makeRotationFromQuaternion(b), this.setFromRotationMatrix(a, c, d)
                }
            }(),
            setFromVector3: function(a, b) {
                return this.set(a.x, a.y, a.z, b || this._order)
            },
            reorder: function() {
                var a = new h;
                return function(b) {
                    return a.setFromEuler(this), this.setFromQuaternion(a, b)
                }
            }(),
            equals: function(a) {
                return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
            },
            fromArray: function(a) {
                return this._x = a[0], this._y = a[1], this._z = a[2], void 0 !== a[3] && (this._order = a[3]), this.onChangeCallback(), this
            },
            toArray: function(a, b) {
                return void 0 === a && (a = []), void 0 === b && (b = 0), a[b] = this._x, a[b + 1] = this._y, a[b + 2] = this._z, a[b + 3] = this._order, a
            },
            toVector3: function(a) {
                return a ? a.set(this._x, this._y, this._z) : new i(this._x, this._y, this._z)
            },
            onChange: function(a) {
                return this.onChangeCallback = a, this
            },
            onChangeCallback: function() {}
        }, da.prototype = {
            constructor: da,
            set: function(a) {
                this.mask = 1 << a
            },
            enable: function(a) {
                this.mask |= 1 << a
            },
            toggle: function(a) {
                this.mask ^= 1 << a
            },
            disable: function(a) {
                this.mask &= ~(1 << a)
            },
            test: function(a) {
                return 0 !== (this.mask & a.mask);
            }
        }, ea.DefaultUp = new i(0, 1, 0), ea.DefaultMatrixAutoUpdate = !0, Object.assign(ea.prototype, b.prototype, {
            isObject3D: !0,
            applyMatrix: function(a) {
                this.matrix.multiplyMatrices(a, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
            },
            setRotationFromAxisAngle: function(a, b) {
                this.quaternion.setFromAxisAngle(a, b)
            },
            setRotationFromEuler: function(a) {
                this.quaternion.setFromEuler(a, !0)
            },
            setRotationFromMatrix: function(a) {
                this.quaternion.setFromRotationMatrix(a)
            },
            setRotationFromQuaternion: function(a) {
                this.quaternion.copy(a)
            },
            rotateOnAxis: function() {
                var a = new h;
                return function(b, c) {
                    return a.setFromAxisAngle(b, c), this.quaternion.multiply(a), this
                }
            }(),
            rotateX: function() {
                var a = new i(1, 0, 0);
                return function(b) {
                    return this.rotateOnAxis(a, b)
                }
            }(),
            rotateY: function() {
                var a = new i(0, 1, 0);
                return function(b) {
                    return this.rotateOnAxis(a, b)
                }
            }(),
            rotateZ: function() {
                var a = new i(0, 0, 1);
                return function(b) {
                    return this.rotateOnAxis(a, b)
                }
            }(),
            translateOnAxis: function() {
                var a = new i;
                return function(b, c) {
                    return a.copy(b).applyQuaternion(this.quaternion), this.position.add(a.multiplyScalar(c)), this
                }
            }(),
            translateX: function() {
                var a = new i(1, 0, 0);
                return function(b) {
                    return this.translateOnAxis(a, b)
                }
            }(),
            translateY: function() {
                var a = new i(0, 1, 0);
                return function(b) {
                    return this.translateOnAxis(a, b)
                }
            }(),
            translateZ: function() {
                var a = new i(0, 0, 1);
                return function(b) {
                    return this.translateOnAxis(a, b)
                }
            }(),
            localToWorld: function(a) {
                return a.applyMatrix4(this.matrixWorld)
            },
            worldToLocal: function() {
                var a = new j;
                return function(b) {
                    return b.applyMatrix4(a.getInverse(this.matrixWorld))
                }
            }(),
            lookAt: function() {
                var a = new j;
                return function(b) {
                    a.lookAt(b, this.position, this.up), this.quaternion.setFromRotationMatrix(a)
                }
            }(),
            add: function(a) {
                if (1 < arguments.length) {
                    for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
                    return this
                }
                return a === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this) : (a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({
                    type: "added"
                }), this.children.push(a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a), this)
            },
            remove: function(a) {
                if (1 < arguments.length)
                    for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
                b = this.children.indexOf(a), -1 !== b && (a.parent = null, a.dispatchEvent({
                    type: "removed"
                }), this.children.splice(b, 1))
            },
            getObjectById: function(a) {
                return this.getObjectByProperty("id", a)
            },
            getObjectByName: function(a) {
                return this.getObjectByProperty("name", a)
            },
            getObjectByProperty: function(a, b) {
                if (this[a] === b) return this;
                for (var c = 0, d = this.children.length; c < d; c++) {
                    var e = this.children[c].getObjectByProperty(a, b);
                    if (void 0 !== e) return e
                }
            },
            getWorldPosition: function(a) {
                return a = a || new i, this.updateMatrixWorld(!0), a.setFromMatrixPosition(this.matrixWorld)
            },
            getWorldQuaternion: function() {
                var a = new i,
                    b = new i;
                return function(c) {
                    return c = c || new h, this.updateMatrixWorld(!0), this.matrixWorld.decompose(a, c, b), c
                }
            }(),
            getWorldRotation: function() {
                var a = new h;
                return function(b) {
                    return b = b || new ca, this.getWorldQuaternion(a), b.setFromQuaternion(a, this.rotation.order, !1)
                }
            }(),
            getWorldScale: function() {
                var a = new i,
                    b = new h;
                return function(c) {
                    return c = c || new i, this.updateMatrixWorld(!0), this.matrixWorld.decompose(a, b, c), c
                }
            }(),
            getWorldDirection: function() {
                var a = new h;
                return function(b) {
                    return b = b || new i, this.getWorldQuaternion(a), b.set(0, 0, 1).applyQuaternion(a)
                }
            }(),
            raycast: function() {},
            traverse: function(a) {
                a(this);
                for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverse(a)
            },
            traverseVisible: function(a) {
                if (!1 !== this.visible) {
                    a(this);
                    for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverseVisible(a)
                }
            },
            traverseAncestors: function(a) {
                var b = this.parent;
                null !== b && (a(b), b.traverseAncestors(a))
            },
            updateMatrix: function() {
                this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
            },
            updateMatrixWorld: function(a) {
                !0 === this.matrixAutoUpdate && this.updateMatrix(), !0 !== this.matrixWorldNeedsUpdate && !0 !== a || (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0);
                for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].updateMatrixWorld(a)
            },
            toJSON: function(a) {
                function b(a) {
                    var b, c = [];
                    for (b in a) {
                        var d = a[b];
                        delete d.metadata, c.push(d)
                    }
                    return c
                }
                var c = void 0 === a || "" === a,
                    d = {};
                c && (a = {
                    geometries: {},
                    materials: {},
                    textures: {},
                    images: {}
                }, d.metadata = {
                    version: 4.4,
                    type: "Object",
                    generator: "Object3D.toJSON"
                });
                var e = {};
                if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), "{}" !== JSON.stringify(this.userData) && (e.userData = this.userData), !0 === this.castShadow && (e.castShadow = !0), !0 === this.receiveShadow && (e.receiveShadow = !0), !1 === this.visible && (e.visible = !1), e.matrix = this.matrix.toArray(), void 0 !== this.geometry && (void 0 === a.geometries[this.geometry.uuid] && (a.geometries[this.geometry.uuid] = this.geometry.toJSON(a)), e.geometry = this.geometry.uuid), void 0 !== this.material && (void 0 === a.materials[this.material.uuid] && (a.materials[this.material.uuid] = this.material.toJSON(a)), e.material = this.material.uuid), 0 < this.children.length) {
                    e.children = [];
                    for (var f = 0; f < this.children.length; f++) e.children.push(this.children[f].toJSON(a).object)
                }
                if (c) {
                    var c = b(a.geometries),
                        f = b(a.materials),
                        g = b(a.textures);
                    a = b(a.images), 0 < c.length && (d.geometries = c), 0 < f.length && (d.materials = f), 0 < g.length && (d.textures = g), 0 < a.length && (d.images = a)
                }
                return d.object = e, d
            },
            clone: function(a) {
                return (new this.constructor).copy(this, a)
            },
            copy: function(a, b) {
                if (void 0 === b && (b = !0), this.name = a.name, this.up.copy(a.up), this.position.copy(a.position), this.quaternion.copy(a.quaternion), this.scale.copy(a.scale), this.matrix.copy(a.matrix), this.matrixWorld.copy(a.matrixWorld), this.matrixAutoUpdate = a.matrixAutoUpdate, this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate, this.visible = a.visible, this.castShadow = a.castShadow, this.receiveShadow = a.receiveShadow, this.frustumCulled = a.frustumCulled, this.renderOrder = a.renderOrder, this.userData = JSON.parse(JSON.stringify(a.userData)), !0 === b)
                    for (var c = 0; c < a.children.length; c++) this.add(a.children[c].clone());
                return this
            }
        });
        var Wd = 0;
        fa.prototype = {
            constructor: fa,
            set: function(a, b) {
                return this.start.copy(a), this.end.copy(b), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(a) {
                return this.start.copy(a.start), this.end.copy(a.end), this
            },
            getCenter: function(a) {
                return (a || new i).addVectors(this.start, this.end).multiplyScalar(.5)
            },
            delta: function(a) {
                return (a || new i).subVectors(this.end, this.start)
            },
            distanceSq: function() {
                return this.start.distanceToSquared(this.end)
            },
            distance: function() {
                return this.start.distanceTo(this.end)
            },
            at: function(a, b) {
                var c = b || new i;
                return this.delta(c).multiplyScalar(a).add(this.start)
            },
            closestPointToPointParameter: function() {
                var b = new i,
                    c = new i;
                return function(d, e) {
                    b.subVectors(d, this.start), c.subVectors(this.end, this.start);
                    var f = c.dot(c),
                        f = c.dot(b) / f;
                    return e && (f = a.Math.clamp(f, 0, 1)), f
                }
            }(),
            closestPointToPoint: function(a, b, c) {
                return a = this.closestPointToPointParameter(a, b), c = c || new i, this.delta(c).multiplyScalar(a).add(this.start)
            },
            applyMatrix4: function(a) {
                return this.start.applyMatrix4(a), this.end.applyMatrix4(a), this
            },
            equals: function(a) {
                return a.start.equals(this.start) && a.end.equals(this.end)
            }
        }, ga.normal = function() {
            var a = new i;
            return function(b, c, d, e) {
                return e = e || new i, e.subVectors(d, c), a.subVectors(b, c), e.cross(a), b = e.lengthSq(), 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0)
            }
        }(), ga.barycoordFromPoint = function() {
            var a = new i,
                b = new i,
                c = new i;
            return function(d, e, f, g, h) {
                a.subVectors(g, e), b.subVectors(f, e), c.subVectors(d, e), d = a.dot(a), e = a.dot(b), f = a.dot(c);
                var j = b.dot(b);
                g = b.dot(c);
                var k = d * j - e * e;
                return h = h || new i, 0 === k ? h.set(-2, -1, -1) : (k = 1 / k, j = (j * f - e * g) * k, d = (d * g - e * f) * k, h.set(1 - j - d, d, j))
            }
        }(), ga.containsPoint = function() {
            var a = new i;
            return function(b, c, d, e) {
                return b = ga.barycoordFromPoint(b, c, d, e, a), 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y
            }
        }(), ga.prototype = {
            constructor: ga,
            set: function(a, b, c) {
                return this.a.copy(a), this.b.copy(b), this.c.copy(c), this
            },
            setFromPointsAndIndices: function(a, b, c, d) {
                return this.a.copy(a[b]), this.b.copy(a[c]), this.c.copy(a[d]), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(a) {
                return this.a.copy(a.a), this.b.copy(a.b), this.c.copy(a.c), this
            },
            area: function() {
                var a = new i,
                    b = new i;
                return function() {
                    return a.subVectors(this.c, this.b), b.subVectors(this.a, this.b), .5 * a.cross(b).length()
                }
            }(),
            midpoint: function(a) {
                return (a || new i).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
            },
            normal: function(a) {
                return ga.normal(this.a, this.b, this.c, a)
            },
            plane: function(a) {
                return (a || new $).setFromCoplanarPoints(this.a, this.b, this.c)
            },
            barycoordFromPoint: function(a, b) {
                return ga.barycoordFromPoint(a, this.a, this.b, this.c, b)
            },
            containsPoint: function(a) {
                return ga.containsPoint(a, this.a, this.b, this.c)
            },
            closestPointToPoint: function() {
                var a, b, c, d;
                return function(e, f) {
                    void 0 === a && (a = new $, b = [new fa, new fa, new fa], c = new i, d = new i);
                    var g = f || new i,
                        h = 1 / 0;
                    if (a.setFromCoplanarPoints(this.a, this.b, this.c), a.projectPoint(e, c), !0 === this.containsPoint(c)) g.copy(c);
                    else {
                        b[0].set(this.a, this.b), b[1].set(this.b, this.c), b[2].set(this.c, this.a);
                        for (var j = 0; j < b.length; j++) {
                            b[j].closestPointToPoint(c, !0, d);
                            var k = c.distanceToSquared(d);
                            k < h && (h = k, g.copy(d))
                        }
                    }
                    return g
                }
            }(),
            equals: function(a) {
                return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
            }
        }, ha.prototype = {
            constructor: ha,
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(a) {
                this.a = a.a, this.b = a.b, this.c = a.c, this.normal.copy(a.normal), this.color.copy(a.color), this.materialIndex = a.materialIndex;
                for (var b = 0, c = a.vertexNormals.length; b < c; b++) this.vertexNormals[b] = a.vertexNormals[b].clone();
                for (b = 0, c = a.vertexColors.length; b < c; b++) this.vertexColors[b] = a.vertexColors[b].clone();
                return this
            }
        }, ia.prototype = Object.create(U.prototype), ia.prototype.constructor = ia, ia.prototype.isMeshBasicMaterial = !0, ia.prototype.copy = function(a) {
            return U.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this
        }, ja.prototype = {
            constructor: ja,
            isBufferAttribute: !0,
            set needsUpdate(a) {
                !0 === a && this.version++
            },
            setDynamic: function(a) {
                return this.dynamic = a, this
            },
            copy: function(a) {
                return this.array = new a.array.constructor(a.array), this.itemSize = a.itemSize, this.count = a.count, this.normalized = a.normalized, this.dynamic = a.dynamic, this
            },
            copyAt: function(a, b, c) {
                a *= this.itemSize, c *= b.itemSize;
                for (var d = 0, e = this.itemSize; d < e; d++) this.array[a + d] = b.array[c + d];
                return this
            },
            copyArray: function(a) {
                return this.array.set(a), this
            },
            copyColorsArray: function(a) {
                for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                    var f = a[d];
                    void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d), f = new Q), b[c++] = f.r, b[c++] = f.g, b[c++] = f.b
                }
                return this
            },
            copyIndicesArray: function(a) {
                for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                    var f = a[d];
                    b[c++] = f.a, b[c++] = f.b, b[c++] = f.c
                }
                return this
            },
            copyVector2sArray: function(a) {
                for (var b = this.array, d = 0, e = 0, f = a.length; e < f; e++) {
                    var g = a[e];
                    void 0 === g && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", e), g = new c), b[d++] = g.x, b[d++] = g.y
                }
                return this
            },
            copyVector3sArray: function(a) {
                for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
                    var f = a[d];
                    void 0 === f && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), f = new i), b[c++] = f.x, b[c++] = f.y, b[c++] = f.z
                }
                return this
            },
            copyVector4sArray: function(a) {
                for (var b = this.array, c = 0, d = 0, f = a.length; d < f; d++) {
                    var g = a[d];
                    void 0 === g && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), g = new e), b[c++] = g.x, b[c++] = g.y, b[c++] = g.z, b[c++] = g.w
                }
                return this
            },
            set: function(a, b) {
                return void 0 === b && (b = 0), this.array.set(a, b), this
            },
            getX: function(a) {
                return this.array[a * this.itemSize]
            },
            setX: function(a, b) {
                return this.array[a * this.itemSize] = b, this
            },
            getY: function(a) {
                return this.array[a * this.itemSize + 1]
            },
            setY: function(a, b) {
                return this.array[a * this.itemSize + 1] = b, this
            },
            getZ: function(a) {
                return this.array[a * this.itemSize + 2]
            },
            setZ: function(a, b) {
                return this.array[a * this.itemSize + 2] = b, this
            },
            getW: function(a) {
                return this.array[a * this.itemSize + 3]
            },
            setW: function(a, b) {
                return this.array[a * this.itemSize + 3] = b, this
            },
            setXY: function(a, b, c) {
                return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this
            },
            setXYZ: function(a, b, c, d) {
                return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this.array[a + 2] = d, this
            },
            setXYZW: function(a, b, c, d, e) {
                return a *= this.itemSize, this.array[a + 0] = b, this.array[a + 1] = c, this.array[a + 2] = d, this.array[a + 3] = e, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        }, Object.assign(na.prototype, b.prototype, {
            isGeometry: !0,
            applyMatrix: function(a) {
                for (var b = (new Z).getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++) this.vertices[c].applyMatrix4(a);
                for (c = 0, d = this.faces.length; c < d; c++) {
                    a = this.faces[c], a.normal.applyMatrix3(b).normalize();
                    for (var e = 0, f = a.vertexNormals.length; e < f; e++) a.vertexNormals[e].applyMatrix3(b).normalize()
                }
                return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this
            },
            rotateX: function() {
                var a;
                return function(b) {
                    return void 0 === a && (a = new j), a.makeRotationX(b), this.applyMatrix(a), this
                }
            }(),
            rotateY: function() {
                var a;
                return function(b) {
                    return void 0 === a && (a = new j), a.makeRotationY(b), this.applyMatrix(a), this
                }
            }(),
            rotateZ: function() {
                var a;
                return function(b) {
                    return void 0 === a && (a = new j), a.makeRotationZ(b), this.applyMatrix(a), this
                }
            }(),
            translate: function() {
                var a;
                return function(b, c, d) {
                    return void 0 === a && (a = new j), a.makeTranslation(b, c, d), this.applyMatrix(a), this
                }
            }(),
            scale: function() {
                var a;
                return function(b, c, d) {
                    return void 0 === a && (a = new j), a.makeScale(b, c, d), this.applyMatrix(a), this
                }
            }(),
            lookAt: function() {
                var a;
                return function(b) {
                    void 0 === a && (a = new ea), a.lookAt(b), a.updateMatrix(), this.applyMatrix(a.matrix)
                }
            }(),
            fromBufferGeometry: function(a) {
                function b(a, b, c, e) {
                    var f = void 0 !== h ? [m[a].clone(), m[b].clone(), m[c].clone()] : [],
                        g = void 0 !== j ? [d.colors[a].clone(), d.colors[b].clone(), d.colors[c].clone()] : [];
                    e = new ha(a, b, c, f, g, e), d.faces.push(e), void 0 !== k && d.faceVertexUvs[0].push([n[a].clone(), n[b].clone(), n[c].clone()]), void 0 !== l && d.faceVertexUvs[1].push([o[a].clone(), o[b].clone(), o[c].clone()])
                }
                var d = this,
                    e = null !== a.index ? a.index.array : void 0,
                    f = a.attributes,
                    g = f.position.array,
                    h = void 0 !== f.normal ? f.normal.array : void 0,
                    j = void 0 !== f.color ? f.color.array : void 0,
                    k = void 0 !== f.uv ? f.uv.array : void 0,
                    l = void 0 !== f.uv2 ? f.uv2.array : void 0;
                void 0 !== l && (this.faceVertexUvs[1] = []);
                for (var m = [], n = [], o = [], p = f = 0; f < g.length; f += 3, p += 2) d.vertices.push(new i(g[f], g[f + 1], g[f + 2])), void 0 !== h && m.push(new i(h[f], h[f + 1], h[f + 2])), void 0 !== j && d.colors.push(new Q(j[f], j[f + 1], j[f + 2])), void 0 !== k && n.push(new c(k[p], k[p + 1])), void 0 !== l && o.push(new c(l[p], l[p + 1]));
                if (void 0 !== e)
                    if (g = a.groups, 0 < g.length)
                        for (f = 0; f < g.length; f++)
                            for (var q = g[f], r = q.start, s = q.count, p = r, r = r + s; p < r; p += 3) b(e[p], e[p + 1], e[p + 2], q.materialIndex);
                    else
                        for (f = 0; f < e.length; f += 3) b(e[f], e[f + 1], e[f + 2]);
                else
                    for (f = 0; f < g.length / 3; f += 3) b(f, f + 1, f + 2);
                return this.computeFaceNormals(), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), this
            },
            center: function() {
                this.computeBoundingBox();
                var a = this.boundingBox.getCenter().negate();
                return this.translate(a.x, a.y, a.z), a
            },
            normalize: function() {
                this.computeBoundingSphere();
                var a = this.boundingSphere.center,
                    b = this.boundingSphere.radius,
                    b = 0 === b ? 1 : 1 / b,
                    c = new j;
                return c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1), this.applyMatrix(c), this
            },
            computeFaceNormals: function() {
                for (var a = new i, b = new i, c = 0, d = this.faces.length; c < d; c++) {
                    var e = this.faces[c],
                        f = this.vertices[e.a],
                        g = this.vertices[e.b];
                    a.subVectors(this.vertices[e.c], g), b.subVectors(f, g), a.cross(b), a.normalize(), e.normal.copy(a)
                }
            },
            computeVertexNormals: function(a) {
                void 0 === a && (a = !0);
                var b, c, d;
                for (d = Array(this.vertices.length), b = 0, c = this.vertices.length; b < c; b++) d[b] = new i;
                if (a) {
                    var e, f, g, h = new i,
                        j = new i;
                    for (a = 0, b = this.faces.length; a < b; a++) c = this.faces[a], e = this.vertices[c.a], f = this.vertices[c.b], g = this.vertices[c.c], h.subVectors(g, f), j.subVectors(e, f), h.cross(j), d[c.a].add(h), d[c.b].add(h), d[c.c].add(h)
                } else
                    for (a = 0, b = this.faces.length; a < b; a++) c = this.faces[a], d[c.a].add(c.normal), d[c.b].add(c.normal), d[c.c].add(c.normal);
                for (b = 0, c = this.vertices.length; b < c; b++) d[b].normalize();
                for (a = 0, b = this.faces.length; a < b; a++) c = this.faces[a], e = c.vertexNormals, 3 === e.length ? (e[0].copy(d[c.a]), e[1].copy(d[c.b]), e[2].copy(d[c.c])) : (e[0] = d[c.a].clone(), e[1] = d[c.b].clone(), e[2] = d[c.c].clone());
                0 < this.faces.length && (this.normalsNeedUpdate = !0)
            },
            computeMorphNormals: function() {
                var a, b, c, d, e;
                for (c = 0, d = this.faces.length; c < d; c++)
                    for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; a < b; a++) e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
                var f = new na;
                for (f.faces = this.faces, a = 0, b = this.morphTargets.length; a < b; a++) {
                    if (!this.morphNormals[a]) {
                        this.morphNormals[a] = {}, this.morphNormals[a].faceNormals = [], this.morphNormals[a].vertexNormals = [], e = this.morphNormals[a].faceNormals;
                        var g, h, j = this.morphNormals[a].vertexNormals;
                        for (c = 0, d = this.faces.length; c < d; c++) g = new i, h = {
                            a: new i,
                            b: new i,
                            c: new i
                        }, e.push(g), j.push(h)
                    }
                    for (j = this.morphNormals[a], f.vertices = this.morphTargets[a].vertices, f.computeFaceNormals(), f.computeVertexNormals(), c = 0, d = this.faces.length; c < d; c++) e = this.faces[c], g = j.faceNormals[c], h = j.vertexNormals[c], g.copy(e.normal), h.a.copy(e.vertexNormals[0]), h.b.copy(e.vertexNormals[1]), h.c.copy(e.vertexNormals[2])
                }
                for (c = 0, d = this.faces.length; c < d; c++) e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals
            },
            computeTangents: function() {
                console.warn("THREE.Geometry: .computeTangents() has been removed.")
            },
            computeLineDistances: function() {
                for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++) 0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new X), this.boundingBox.setFromPoints(this.vertices)
            },
            computeBoundingSphere: function() {
                null === this.boundingSphere && (this.boundingSphere = new Y), this.boundingSphere.setFromPoints(this.vertices)
            },
            merge: function(a, b, c) {
                if (!1 === (a && a.isGeometry)) console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a);
                else {
                    var d, e = this.vertices.length,
                        f = this.vertices,
                        g = a.vertices,
                        h = this.faces,
                        i = a.faces,
                        j = this.faceVertexUvs[0],
                        k = a.faceVertexUvs[0],
                        l = this.colors,
                        m = a.colors;
                    void 0 === c && (c = 0), void 0 !== b && (d = (new Z).getNormalMatrix(b)), a = 0;
                    for (var n = g.length; a < n; a++) {
                        var o = g[a].clone();
                        void 0 !== b && o.applyMatrix4(b), f.push(o)
                    }
                    for (a = 0, n = m.length; a < n; a++) l.push(m[a].clone());
                    for (a = 0, n = i.length; a < n; a++) {
                        var g = i[a],
                            p = g.vertexNormals,
                            m = g.vertexColors,
                            l = new ha(g.a + e, g.b + e, g.c + e);
                        for (l.normal.copy(g.normal), void 0 !== d && l.normal.applyMatrix3(d).normalize(), b = 0, f = p.length; b < f; b++) o = p[b].clone(), void 0 !== d && o.applyMatrix3(d).normalize(), l.vertexNormals.push(o);
                        for (l.color.copy(g.color), b = 0, f = m.length; b < f; b++) o = m[b], l.vertexColors.push(o.clone());
                        l.materialIndex = g.materialIndex + c, h.push(l)
                    }
                    for (a = 0, n = k.length; a < n; a++)
                        if (c = k[a], d = [], void 0 !== c) {
                            for (b = 0, f = c.length; b < f; b++) d.push(c[b].clone());
                            j.push(d)
                        }
                }
            },
            mergeMesh: function(a) {
                !1 === (a && a.isMesh) ? console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a) : (a.matrixAutoUpdate && a.updateMatrix(), this.merge(a.geometry, a.matrix))
            },
            mergeVertices: function() {
                var a, b, c, d = {},
                    e = [],
                    f = [],
                    g = Math.pow(10, 4);
                for (b = 0, c = this.vertices.length; b < c; b++) a = this.vertices[b], a = Math.round(a.x * g) + "_" + Math.round(a.y * g) + "_" + Math.round(a.z * g), void 0 === d[a] ? (d[a] = b, e.push(this.vertices[b]), f[b] = e.length - 1) : f[b] = f[d[a]];
                for (d = [], b = 0, c = this.faces.length; b < c; b++)
                    for (g = this.faces[b], g.a = f[g.a], g.b = f[g.b], g.c = f[g.c], g = [g.a, g.b, g.c], a = 0; 3 > a; a++)
                        if (g[a] === g[(a + 1) % 3]) {
                            d.push(b);
                            break
                        }
                for (b = d.length - 1; 0 <= b; b--)
                    for (g = d[b], this.faces.splice(g, 1), f = 0, c = this.faceVertexUvs.length; f < c; f++) this.faceVertexUvs[f].splice(g, 1);
                return b = this.vertices.length - e.length, this.vertices = e, b
            },
            sortFacesByMaterialIndex: function() {
                for (var a = this.faces, b = a.length, c = 0; c < b; c++) a[c]._id = c;
                a.sort(function(a, b) {
                    return a.materialIndex - b.materialIndex
                });
                var d, e, f = this.faceVertexUvs[0],
                    g = this.faceVertexUvs[1];
                for (f && f.length === b && (d = []), g && g.length === b && (e = []), c = 0; c < b; c++) {
                    var h = a[c]._id;
                    d && d.push(f[h]), e && e.push(g[h])
                }
                d && (this.faceVertexUvs[0] = d), e && (this.faceVertexUvs[1] = e)
            },
            toJSON: function() {
                function a(a, b, c) {
                    return c ? a | 1 << b : a & ~(1 << b)
                }

                function b(a) {
                    var b = a.x.toString() + a.y.toString() + a.z.toString();
                    return void 0 !== j[b] ? j[b] : (j[b] = i.length / 3, i.push(a.x, a.y, a.z), j[b])
                }

                function c(a) {
                    var b = a.r.toString() + a.g.toString() + a.b.toString();
                    return void 0 !== l[b] ? l[b] : (l[b] = k.length, k.push(a.getHex()), l[b])
                }

                function d(a) {
                    var b = a.x.toString() + a.y.toString();
                    return void 0 !== n[b] ? n[b] : (n[b] = m.length / 2, m.push(a.x, a.y), n[b])
                }
                var e = {
                    metadata: {
                        version: 4.4,
                        type: "Geometry",
                        generator: "Geometry.toJSON"
                    }
                };
                if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
                    var f, g = this.parameters;
                    for (f in g) void 0 !== g[f] && (e[f] = g[f]);
                    return e
                }
                for (g = [], f = 0; f < this.vertices.length; f++) {
                    var h = this.vertices[f];
                    g.push(h.x, h.y, h.z)
                }
                var h = [],
                    i = [],
                    j = {},
                    k = [],
                    l = {},
                    m = [],
                    n = {};
                for (f = 0; f < this.faces.length; f++) {
                    var o = this.faces[f],
                        p = void 0 !== this.faceVertexUvs[0][f],
                        q = 0 < o.normal.length(),
                        r = 0 < o.vertexNormals.length,
                        s = 1 !== o.color.r || 1 !== o.color.g || 1 !== o.color.b,
                        t = 0 < o.vertexColors.length,
                        u = 0,
                        u = a(u, 0, 0),
                        u = a(u, 1, !0),
                        u = a(u, 2, !1),
                        u = a(u, 3, p),
                        u = a(u, 4, q),
                        u = a(u, 5, r),
                        u = a(u, 6, s),
                        u = a(u, 7, t);
                    h.push(u), h.push(o.a, o.b, o.c), h.push(o.materialIndex), p && (p = this.faceVertexUvs[0][f], h.push(d(p[0]), d(p[1]), d(p[2]))), q && h.push(b(o.normal)), r && (q = o.vertexNormals, h.push(b(q[0]), b(q[1]), b(q[2]))), s && h.push(c(o.color)), t && (o = o.vertexColors, h.push(c(o[0]), c(o[1]), c(o[2])))
                }
                return e.data = {}, e.data.vertices = g, e.data.normals = i, 0 < k.length && (e.data.colors = k), 0 < m.length && (e.data.uvs = [m]), e.data.faces = h, e
            },
            clone: function() {
                return (new na).copy(this)
            },
            copy: function(a) {
                this.vertices = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.colors = [];
                for (var b = a.vertices, c = 0, d = b.length; c < d; c++) this.vertices.push(b[c].clone());
                for (b = a.colors, c = 0, d = b.length; c < d; c++) this.colors.push(b[c].clone());
                for (b = a.faces, c = 0, d = b.length; c < d; c++) this.faces.push(b[c].clone());
                for (c = 0, d = a.faceVertexUvs.length; c < d; c++) {
                    b = a.faceVertexUvs[c], void 0 === this.faceVertexUvs[c] && (this.faceVertexUvs[c] = []);
                    for (var e = 0, f = b.length; e < f; e++) {
                        for (var g = b[e], h = [], i = 0, j = g.length; i < j; i++) h.push(g[i].clone());
                        this.faceVertexUvs[c].push(h)
                    }
                }
                return this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        });
        var Xd = 0;
        Object.assign(oa.prototype, b.prototype, {
            computeBoundingBox: na.prototype.computeBoundingBox,
            computeBoundingSphere: na.prototype.computeBoundingSphere,
            computeFaceNormals: function() {
                console.warn("THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.")
            },
            computeVertexNormals: function() {
                console.warn("THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.")
            },
            computeGroups: function(a) {
                var b, c, d = [];
                a = a.faces;
                for (var e = 0; e < a.length; e++) {
                    var f = a[e];
                    f.materialIndex !== c && (c = f.materialIndex, void 0 !== b && (b.count = 3 * e - b.start, d.push(b)), b = {
                        start: 3 * e,
                        materialIndex: c
                    })
                }
                void 0 !== b && (b.count = 3 * e - b.start, d.push(b)), this.groups = d
            },
            fromGeometry: function(a) {
                var b, d = a.faces,
                    e = a.vertices,
                    f = a.faceVertexUvs,
                    g = f[0] && 0 < f[0].length,
                    h = f[1] && 0 < f[1].length,
                    i = a.morphTargets,
                    j = i.length;
                if (0 < j) {
                    b = [];
                    for (var k = 0; k < j; k++) b[k] = [];
                    this.morphTargets.position = b
                }
                var l, m = a.morphNormals,
                    n = m.length;
                if (0 < n) {
                    for (l = [], k = 0; k < n; k++) l[k] = [];
                    this.morphTargets.normal = l
                }
                for (var o = a.skinIndices, p = a.skinWeights, q = o.length === e.length, r = p.length === e.length, k = 0; k < d.length; k++) {
                    var s = d[k];
                    this.vertices.push(e[s.a], e[s.b], e[s.c]);
                    var t = s.vertexNormals;
                    for (3 === t.length ? this.normals.push(t[0], t[1], t[2]) : (t = s.normal, this.normals.push(t, t, t)), t = s.vertexColors, 3 === t.length ? this.colors.push(t[0], t[1], t[2]) : (t = s.color, this.colors.push(t, t, t)), !0 === g && (t = f[0][k], void 0 !== t ? this.uvs.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", k), this.uvs.push(new c, new c, new c))), !0 === h && (t = f[1][k], void 0 !== t ? this.uvs2.push(t[0], t[1], t[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", k), this.uvs2.push(new c, new c, new c))), t = 0; t < j; t++) {
                        var u = i[t].vertices;
                        b[t].push(u[s.a], u[s.b], u[s.c])
                    }
                    for (t = 0; t < n; t++) u = m[t].vertexNormals[k], l[t].push(u.a, u.b, u.c);
                    q && this.skinIndices.push(o[s.a], o[s.b], o[s.c]), r && this.skinWeights.push(p[s.a], p[s.b], p[s.c])
                }
                return this.computeGroups(a), this.verticesNeedUpdate = a.verticesNeedUpdate, this.normalsNeedUpdate = a.normalsNeedUpdate, this.colorsNeedUpdate = a.colorsNeedUpdate, this.uvsNeedUpdate = a.uvsNeedUpdate, this.groupsNeedUpdate = a.groupsNeedUpdate, this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), Object.assign(pa.prototype, b.prototype, {
            isBufferGeometry: !0,
            getIndex: function() {
                return this.index
            },
            setIndex: function(a) {
                this.index = a
            },
            addAttribute: function(a, b, c) {
                if (!1 === (b && b.isBufferAttribute) && !1 === (b && b.isInterleavedBufferAttribute)) console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(a, new ja(b, c));
                else {
                    if ("index" !== a) return this.attributes[a] = b, this;
                    console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(b)
                }
            },
            getAttribute: function(a) {
                return this.attributes[a]
            },
            removeAttribute: function(a) {
                return delete this.attributes[a], this
            },
            addGroup: function(a, b, c) {
                this.groups.push({
                    start: a,
                    count: b,
                    materialIndex: void 0 !== c ? c : 0
                })
            },
            clearGroups: function() {
                this.groups = []
            },
            setDrawRange: function(a, b) {
                this.drawRange.start = a, this.drawRange.count = b
            },
            applyMatrix: function(a) {
                var b = this.attributes.position;
                return void 0 !== b && (a.applyToVector3Array(b.array), b.needsUpdate = !0), b = this.attributes.normal, void 0 !== b && ((new Z).getNormalMatrix(a).applyToVector3Array(b.array), b.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
            },
            rotateX: function() {
                var a;
                return function(b) {
                    return void 0 === a && (a = new j), a.makeRotationX(b), this.applyMatrix(a), this
                }
            }(),
            rotateY: function() {
                var a;
                return function(b) {
                    return void 0 === a && (a = new j), a.makeRotationY(b), this.applyMatrix(a), this
                }
            }(),
            rotateZ: function() {
                var a;
                return function(b) {
                    return void 0 === a && (a = new j), a.makeRotationZ(b), this.applyMatrix(a), this
                }
            }(),
            translate: function() {
                var a;
                return function(b, c, d) {
                    return void 0 === a && (a = new j), a.makeTranslation(b, c, d), this.applyMatrix(a), this
                }
            }(),
            scale: function() {
                var a;
                return function(b, c, d) {
                    return void 0 === a && (a = new j), a.makeScale(b, c, d), this.applyMatrix(a), this
                }
            }(),
            lookAt: function() {
                var a;
                return function(b) {
                    void 0 === a && (a = new ea), a.lookAt(b), a.updateMatrix(), this.applyMatrix(a.matrix)
                }
            }(),
            center: function() {
                this.computeBoundingBox();
                var a = this.boundingBox.getCenter().negate();
                return this.translate(a.x, a.y, a.z), a
            },
            setFromObject: function(a) {
                var b = a.geometry;
                if (a && a.isPoints || a && a.isLine) {
                    a = new ma(3 * b.vertices.length, 3);
                    var c = new ma(3 * b.colors.length, 3);
                    this.addAttribute("position", a.copyVector3sArray(b.vertices)), this.addAttribute("color", c.copyColorsArray(b.colors)), b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new ma(b.lineDistances.length, 1), this.addAttribute("lineDistance", a.copyArray(b.lineDistances))), null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone()), null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone())
                } else a && a.isMesh && b && b.isGeometry && this.fromGeometry(b);
                return this
            },
            updateFromObject: function(a) {
                var b = a.geometry;
                if (a && a.isMesh) {
                    var c = b.__directGeometry;
                    if (!0 === b.elementsNeedUpdate && (c = void 0, b.elementsNeedUpdate = !1), void 0 === c) return this.fromGeometry(b);
                    c.verticesNeedUpdate = b.verticesNeedUpdate, c.normalsNeedUpdate = b.normalsNeedUpdate, c.colorsNeedUpdate = b.colorsNeedUpdate, c.uvsNeedUpdate = b.uvsNeedUpdate, c.groupsNeedUpdate = b.groupsNeedUpdate, b.verticesNeedUpdate = !1, b.normalsNeedUpdate = !1, b.colorsNeedUpdate = !1, b.uvsNeedUpdate = !1, b.groupsNeedUpdate = !1, b = c
                }
                return !0 === b.verticesNeedUpdate && (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices), c.needsUpdate = !0), b.verticesNeedUpdate = !1), !0 === b.normalsNeedUpdate && (c = this.attributes.normal, void 0 !== c && (c.copyVector3sArray(b.normals), c.needsUpdate = !0), b.normalsNeedUpdate = !1), !0 === b.colorsNeedUpdate && (c = this.attributes.color, void 0 !== c && (c.copyColorsArray(b.colors), c.needsUpdate = !0), b.colorsNeedUpdate = !1), b.uvsNeedUpdate && (c = this.attributes.uv, void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = !0), b.uvsNeedUpdate = !1), b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances), c.needsUpdate = !0), b.lineDistancesNeedUpdate = !1), b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = !1), this
            },
            fromGeometry: function(a) {
                return a.__directGeometry = (new oa).fromGeometry(a), this.fromDirectGeometry(a.__directGeometry)
            },
            fromDirectGeometry: function(a) {
                var b = new Float32Array(3 * a.vertices.length);
                this.addAttribute("position", new ja(b, 3).copyVector3sArray(a.vertices)), 0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.addAttribute("normal", new ja(b, 3).copyVector3sArray(a.normals))), 0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.addAttribute("color", new ja(b, 3).copyColorsArray(a.colors))), 0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), this.addAttribute("uv", new ja(b, 2).copyVector2sArray(a.uvs))), 0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), this.addAttribute("uv2", new ja(b, 2).copyVector2sArray(a.uvs2))), 0 < a.indices.length && (b = new(65535 < a.vertices.length ? Uint32Array : Uint16Array)(3 * a.indices.length), this.setIndex(new ja(b, 1).copyIndicesArray(a.indices))), this.groups = a.groups;
                for (var c in a.morphTargets) {
                    for (var b = [], d = a.morphTargets[c], e = 0, f = d.length; e < f; e++) {
                        var g = d[e],
                            h = new ma(3 * g.length, 3);
                        b.push(h.copyVector3sArray(g))
                    }
                    this.morphAttributes[c] = b
                }
                return 0 < a.skinIndices.length && (c = new ma(4 * a.skinIndices.length, 4), this.addAttribute("skinIndex", c.copyVector4sArray(a.skinIndices))), 0 < a.skinWeights.length && (c = new ma(4 * a.skinWeights.length, 4), this.addAttribute("skinWeight", c.copyVector4sArray(a.skinWeights))), null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone()), null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone()), this
            },
            computeBoundingBox: function() {
                null === this.boundingBox && (this.boundingBox = new X);
                var a = this.attributes.position.array;
                void 0 !== a ? this.boundingBox.setFromArray(a) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
            },
            computeBoundingSphere: function() {
                var a = new X,
                    b = new i;
                return function() {
                    null === this.boundingSphere && (this.boundingSphere = new Y);
                    var c = this.attributes.position;
                    if (c) {
                        var c = c.array,
                            d = this.boundingSphere.center;
                        a.setFromArray(c), a.getCenter(d);
                        for (var e = 0, f = 0, g = c.length; f < g; f += 3) b.fromArray(c, f), e = Math.max(e, d.distanceToSquared(b));
                        this.boundingSphere.radius = Math.sqrt(e), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                    }
                }
            }(),
            computeFaceNormals: function() {},
            computeVertexNormals: function() {
                var a = this.index,
                    b = this.attributes,
                    c = this.groups;
                if (b.position) {
                    var d = b.position.array;
                    if (void 0 === b.normal) this.addAttribute("normal", new ja(new Float32Array(d.length), 3));
                    else
                        for (var e = b.normal.array, f = 0, g = e.length; f < g; f++) e[f] = 0;
                    var h, j, k, e = b.normal.array,
                        l = new i,
                        m = new i,
                        n = new i,
                        o = new i,
                        p = new i;
                    if (a) {
                        a = a.array, 0 === c.length && this.addGroup(0, a.length);
                        for (var q = 0, r = c.length; q < r; ++q)
                            for (f = c[q], g = f.start, h = f.count, f = g, g += h; f < g; f += 3) h = 3 * a[f + 0], j = 3 * a[f + 1], k = 3 * a[f + 2], l.fromArray(d, h), m.fromArray(d, j), n.fromArray(d, k), o.subVectors(n, m), p.subVectors(l, m), o.cross(p), e[h] += o.x, e[h + 1] += o.y, e[h + 2] += o.z, e[j] += o.x, e[j + 1] += o.y, e[j + 2] += o.z, e[k] += o.x, e[k + 1] += o.y, e[k + 2] += o.z
                    } else
                        for (f = 0, g = d.length; f < g; f += 9) l.fromArray(d, f), m.fromArray(d, f + 3), n.fromArray(d, f + 6), o.subVectors(n, m), p.subVectors(l, m), o.cross(p), e[f] = o.x, e[f + 1] = o.y, e[f + 2] = o.z, e[f + 3] = o.x, e[f + 4] = o.y, e[f + 5] = o.z, e[f + 6] = o.x, e[f + 7] = o.y, e[f + 8] = o.z;
                    this.normalizeNormals(), b.normal.needsUpdate = !0
                }
            },
            merge: function(a, b) {
                if (!1 !== (a && a.isBufferGeometry)) {
                    void 0 === b && (b = 0);
                    var c, d = this.attributes;
                    for (c in d)
                        if (void 0 !== a.attributes[c])
                            for (var e = d[c].array, f = a.attributes[c], g = f.array, h = 0, f = f.itemSize * b; h < g.length; h++, f++) e[f] = g[h];
                    return this
                }
                console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a)
            },
            normalizeNormals: function() {
                for (var a, b, c, d = this.attributes.normal.array, e = 0, f = d.length; e < f; e += 3) a = d[e], b = d[e + 1], c = d[e + 2], a = 1 / Math.sqrt(a * a + b * b + c * c), d[e] *= a, d[e + 1] *= a, d[e + 2] *= a
            },
            toNonIndexed: function() {
                if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                var a, b = new pa,
                    c = this.index.array,
                    d = this.attributes;
                for (a in d) {
                    for (var e, f = d[a], g = f.array, f = f.itemSize, h = new g.constructor(c.length * f), i = 0, j = 0, k = c.length; j < k; j++) {
                        e = c[j] * f;
                        for (var l = 0; l < f; l++) h[i++] = g[e++]
                    }
                    b.addAttribute(a, new ja(h, f))
                }
                return b
            },
            toJSON: function() {
                var a = {
                    metadata: {
                        version: 4.4,
                        type: "BufferGeometry",
                        generator: "BufferGeometry.toJSON"
                    }
                };
                if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), void 0 !== this.parameters) {
                    var b, c = this.parameters;
                    for (b in c) void 0 !== c[b] && (a[b] = c[b]);
                    return a
                }
                a.data = {
                    attributes: {}
                };
                var d = this.index;
                null !== d && (c = Array.prototype.slice.call(d.array), a.data.index = {
                    type: d.array.constructor.name,
                    array: c
                }), d = this.attributes;
                for (b in d) {
                    var e = d[b],
                        c = Array.prototype.slice.call(e.array);
                    a.data.attributes[b] = {
                        itemSize: e.itemSize,
                        type: e.array.constructor.name,
                        array: c,
                        normalized: e.normalized
                    }
                }
                return b = this.groups, 0 < b.length && (a.data.groups = JSON.parse(JSON.stringify(b))), b = this.boundingSphere, null !== b && (a.data.boundingSphere = {
                    center: b.center.toArray(),
                    radius: b.radius
                }), a
            },
            clone: function() {
                return (new pa).copy(this)
            },
            copy: function(a) {
                var b = a.index;
                null !== b && this.setIndex(b.clone());
                var c, b = a.attributes;
                for (c in b) this.addAttribute(c, b[c].clone());
                for (a = a.groups, c = 0, b = a.length; c < b; c++) {
                    var d = a[c];
                    this.addGroup(d.start, d.count, d.materialIndex)
                }
                return this
            },
            dispose: function() {
                this.dispatchEvent({
                    type: "dispose"
                })
            }
        }), pa.MaxIndex = 65535, qa.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: qa,
            isMesh: !0,
            setDrawMode: function(a) {
                this.drawMode = a
            },
            copy: function(a) {
                return ea.prototype.copy.call(this, a), this.drawMode = a.drawMode, this
            },
            updateMorphTargets: function() {
                var a = this.geometry.morphTargets;
                if (void 0 !== a && 0 < a.length) {
                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (var b = 0, c = a.length; b < c; b++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[a[b].name] = b
                }
            },
            raycast: function() {
                function a(a, b, c, d, e, f, g) {
                    return ga.barycoordFromPoint(a, b, c, d, s), e.multiplyScalar(s.x), f.multiplyScalar(s.y), g.multiplyScalar(s.z), e.add(f).add(g), e.clone()
                }

                function b(a, b, c, d, e, f, g) {
                    var h = a.material;
                    return null === (1 === h.side ? c.intersectTriangle(f, e, d, !0, g) : c.intersectTriangle(d, e, f, 2 !== h.side, g)) ? null : (u.copy(g), u.applyMatrix4(a.matrixWorld), c = b.ray.origin.distanceTo(u), c < b.near || c > b.far ? null : {
                        distance: c,
                        point: u.clone(),
                        object: a
                    })
                }

                function d(c, d, e, f, g, i, j, m) {
                    return h.fromArray(f, 3 * i), k.fromArray(f, 3 * j), l.fromArray(f, 3 * m), (c = b(c, d, e, h, k, l, t)) && (g && (p.fromArray(g, 2 * i), q.fromArray(g, 2 * j), r.fromArray(g, 2 * m), c.uv = a(t, h, k, l, p, q, r)), c.face = new ha(i, j, m, ga.normal(h, k, l)), c.faceIndex = i), c
                }
                var e = new j,
                    f = new ba,
                    g = new Y,
                    h = new i,
                    k = new i,
                    l = new i,
                    m = new i,
                    n = new i,
                    o = new i,
                    p = new c,
                    q = new c,
                    r = new c,
                    s = new i,
                    t = new i,
                    u = new i;
                return function(c, i) {
                    var j = this.geometry,
                        s = this.material,
                        u = this.matrixWorld;
                    if (void 0 !== s && (null === j.boundingSphere && j.computeBoundingSphere(), g.copy(j.boundingSphere), g.applyMatrix4(u), !1 !== c.ray.intersectsSphere(g) && (e.getInverse(u), f.copy(c.ray).applyMatrix4(e), null === j.boundingBox || !1 !== f.intersectsBox(j.boundingBox)))) {
                        var v, w;
                        if (j && j.isBufferGeometry) {
                            var x, y, s = j.index,
                                u = j.attributes,
                                j = u.position.array;
                            if (void 0 !== u.uv && (v = u.uv.array), null !== s)
                                for (var u = s.array, z = 0, A = u.length; z < A; z += 3) s = u[z], x = u[z + 1], y = u[z + 2], (w = d(this, c, f, j, v, s, x, y)) && (w.faceIndex = Math.floor(z / 3), i.push(w));
                            else
                                for (z = 0, A = j.length; z < A; z += 9) s = z / 3, x = s + 1, y = s + 2, (w = d(this, c, f, j, v, s, x, y)) && (w.index = s, i.push(w))
                        } else if (j && j.isGeometry) {
                            var B, C, u = s && s.isMultiMaterial,
                                z = !0 === u ? s.materials : null,
                                A = j.vertices;
                            x = j.faces, y = j.faceVertexUvs[0], 0 < y.length && (v = y);
                            for (var D = 0, E = x.length; D < E; D++) {
                                var F = x[D];
                                if (w = !0 === u ? z[F.materialIndex] : s, void 0 !== w) {
                                    if (y = A[F.a], B = A[F.b], C = A[F.c], !0 === w.morphTargets) {
                                        w = j.morphTargets;
                                        var G = this.morphTargetInfluences;
                                        h.set(0, 0, 0), k.set(0, 0, 0), l.set(0, 0, 0);
                                        for (var H = 0, I = w.length; H < I; H++) {
                                            var J = G[H];
                                            if (0 !== J) {
                                                var K = w[H].vertices;
                                                h.addScaledVector(m.subVectors(K[F.a], y), J), k.addScaledVector(n.subVectors(K[F.b], B), J), l.addScaledVector(o.subVectors(K[F.c], C), J)
                                            }
                                        }
                                        h.add(y), k.add(B), l.add(C), y = h, B = k, C = l
                                    }(w = b(this, c, f, y, B, C, t)) && (v && (G = v[D], p.copy(G[0]), q.copy(G[1]), r.copy(G[2]), w.uv = a(t, y, B, C, p, q, r)), w.face = F, w.faceIndex = D, i.push(w))
                                }
                            }
                        }
                    }
                }
            }(),
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), ra.prototype = Object.create(pa.prototype), ra.prototype.constructor = ra, sa.prototype = Object.create(pa.prototype), sa.prototype.constructor = sa, ta.prototype = Object.create(ea.prototype), ta.prototype.constructor = ta, ta.prototype.isCamera = !0, ta.prototype.getWorldDirection = function() {
            var a = new h;
            return function(b) {
                return b = b || new i, this.getWorldQuaternion(a), b.set(0, 0, -1).applyQuaternion(a)
            }
        }(), ta.prototype.lookAt = function() {
            var a = new j;
            return function(b) {
                a.lookAt(this.position, b, this.up), this.quaternion.setFromRotationMatrix(a)
            }
        }(), ta.prototype.clone = function() {
            return (new this.constructor).copy(this)
        }, ta.prototype.copy = function(a) {
            return ea.prototype.copy.call(this, a), this.matrixWorldInverse.copy(a.matrixWorldInverse), this.projectionMatrix.copy(a.projectionMatrix), this
        }, ua.prototype = Object.assign(Object.create(ta.prototype), {
            constructor: ua,
            isPerspectiveCamera: !0,
            copy: function(a) {
                return ta.prototype.copy.call(this, a), this.fov = a.fov, this.zoom = a.zoom, this.near = a.near, this.far = a.far, this.focus = a.focus, this.aspect = a.aspect, this.view = null === a.view ? null : Object.assign({}, a.view), this.filmGauge = a.filmGauge, this.filmOffset = a.filmOffset, this
            },
            setFocalLength: function(b) {
                b = .5 * this.getFilmHeight() / b, this.fov = 2 * a.Math.RAD2DEG * Math.atan(b), this.updateProjectionMatrix()
            },
            getFocalLength: function() {
                var b = Math.tan(.5 * a.Math.DEG2RAD * this.fov);
                return .5 * this.getFilmHeight() / b
            },
            getEffectiveFOV: function() {
                return 2 * a.Math.RAD2DEG * Math.atan(Math.tan(.5 * a.Math.DEG2RAD * this.fov) / this.zoom)
            },
            getFilmWidth: function() {
                return this.filmGauge * Math.min(this.aspect, 1)
            },
            getFilmHeight: function() {
                return this.filmGauge / Math.max(this.aspect, 1)
            },
            setViewOffset: function(a, b, c, d, e, f) {
                this.aspect = a / b, this.view = {
                    fullWidth: a,
                    fullHeight: b,
                    offsetX: c,
                    offsetY: d,
                    width: e,
                    height: f
                }, this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                this.view = null, this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var b = this.near,
                    c = b * Math.tan(.5 * a.Math.DEG2RAD * this.fov) / this.zoom,
                    d = 2 * c,
                    e = this.aspect * d,
                    f = -.5 * e,
                    g = this.view;
                if (null !== g) var h = g.fullWidth,
                    i = g.fullHeight,
                    f = f + g.offsetX * e / h,
                    c = c - g.offsetY * d / i,
                    e = g.width / h * e,
                    d = g.height / i * d;
                g = this.filmOffset, 0 !== g && (f += b * g / this.getFilmWidth()), this.projectionMatrix.makeFrustum(f, f + e, c - d, c, b, this.far)
            },
            toJSON: function(a) {
                return a = ea.prototype.toJSON.call(this, a), a.object.fov = this.fov, a.object.zoom = this.zoom, a.object.near = this.near, a.object.far = this.far, a.object.focus = this.focus, a.object.aspect = this.aspect, null !== this.view && (a.object.view = Object.assign({}, this.view)), a.object.filmGauge = this.filmGauge, a.object.filmOffset = this.filmOffset, a
            }
        }), va.prototype = Object.assign(Object.create(ta.prototype), {
            constructor: va,
            isOrthographicCamera: !0,
            copy: function(a) {
                return ta.prototype.copy.call(this, a), this.left = a.left, this.right = a.right, this.top = a.top, this.bottom = a.bottom, this.near = a.near, this.far = a.far, this.zoom = a.zoom, this.view = null === a.view ? null : Object.assign({}, a.view), this
            },
            setViewOffset: function(a, b, c, d, e, f) {
                this.view = {
                    fullWidth: a,
                    fullHeight: b,
                    offsetX: c,
                    offsetY: d,
                    width: e,
                    height: f
                }, this.updateProjectionMatrix()
            },
            clearViewOffset: function() {
                this.view = null, this.updateProjectionMatrix()
            },
            updateProjectionMatrix: function() {
                var a = (this.right - this.left) / (2 * this.zoom),
                    b = (this.top - this.bottom) / (2 * this.zoom),
                    c = (this.right + this.left) / 2,
                    d = (this.top + this.bottom) / 2,
                    e = c - a,
                    c = c + a,
                    a = d + b,
                    b = d - b;
                if (null !== this.view) var c = this.zoom / (this.view.width / this.view.fullWidth),
                    b = this.zoom / (this.view.height / this.view.fullHeight),
                    f = (this.right - this.left) / this.view.width,
                    d = (this.top - this.bottom) / this.view.height,
                    e = e + this.view.offsetX / c * f,
                    c = e + this.view.width / c * f,
                    a = a - this.view.offsetY / b * d,
                    b = a - this.view.height / b * d;
                this.projectionMatrix.makeOrthographic(e, c, a, b, this.near, this.far)
            },
            toJSON: function(a) {
                return a = ea.prototype.toJSON.call(this, a), a.object.zoom = this.zoom, a.object.left = this.left, a.object.right = this.right, a.object.top = this.top, a.object.bottom = this.bottom, a.object.near = this.near, a.object.far = this.far, null !== this.view && (a.object.view = Object.assign({}, this.view)), a
            }
        });
        var Yd = 0;
        Wa.prototype.isFogExp2 = !0, Wa.prototype.clone = function() {
            return new Wa(this.color.getHex(), this.density)
        }, Wa.prototype.toJSON = function(a) {
            return {
                type: "FogExp2",
                color: this.color.getHex(),
                density: this.density
            }
        }, Xa.prototype.isFog = !0, Xa.prototype.clone = function() {
            return new Xa(this.color.getHex(), this.near, this.far)
        }, Xa.prototype.toJSON = function(a) {
            return {
                type: "Fog",
                color: this.color.getHex(),
                near: this.near,
                far: this.far
            }
        }, Ya.prototype = Object.create(ea.prototype), Ya.prototype.constructor = Ya, Ya.prototype.copy = function(a, b) {
            return ea.prototype.copy.call(this, a, b), null !== a.background && (this.background = a.background.clone()), null !== a.fog && (this.fog = a.fog.clone()), null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone()), this.autoUpdate = a.autoUpdate, this.matrixAutoUpdate = a.matrixAutoUpdate, this
        }, Ya.prototype.toJSON = function(a) {
            var b = ea.prototype.toJSON.call(this, a);
            return null !== this.background && (b.object.background = this.background.toJSON(a)), null !== this.fog && (b.object.fog = this.fog.toJSON()), b
        }, Za.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: Za,
            isLensFlare: !0,
            copy: function(a) {
                ea.prototype.copy.call(this, a), this.positionScreen.copy(a.positionScreen), this.customUpdateCallback = a.customUpdateCallback;
                for (var b = 0, c = a.lensFlares.length; b < c; b++) this.lensFlares.push(a.lensFlares[b]);
                return this
            },
            add: function(a, b, c, d, e, f) {
                void 0 === b && (b = -1), void 0 === c && (c = 0), void 0 === f && (f = 1), void 0 === e && (e = new Q(16777215)), void 0 === d && (d = 1), c = Math.min(c, Math.max(0, c)), this.lensFlares.push({
                    texture: a,
                    size: b,
                    distance: c,
                    x: 0,
                    y: 0,
                    z: 0,
                    scale: 1,
                    rotation: 0,
                    opacity: f,
                    color: e,
                    blending: d
                })
            },
            updateLensFlares: function() {
                var a, b, c = this.lensFlares.length,
                    d = 2 * -this.positionScreen.x,
                    e = 2 * -this.positionScreen.y;
                for (a = 0; a < c; a++) b = this.lensFlares[a], b.x = this.positionScreen.x + d * b.distance, b.y = this.positionScreen.y + e * b.distance, b.wantedRotation = b.x * Math.PI * .25, b.rotation += .25 * (b.wantedRotation - b.rotation)
            }
        }), $a.prototype = Object.create(U.prototype), $a.prototype.constructor = $a, $a.prototype.copy = function(a) {
            return U.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.rotation = a.rotation, this
        }, _a.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: _a,
            isSprite: !0,
            raycast: function() {
                var a = new i;
                return function(b, c) {
                    a.setFromMatrixPosition(this.matrixWorld);
                    var d = b.ray.distanceSqToPoint(a);
                    d > this.scale.x * this.scale.y / 4 || c.push({
                        distance: Math.sqrt(d),
                        point: this.position,
                        face: null,
                        object: this
                    })
                }
            }(),
            clone: function() {
                return new this.constructor(this.material).copy(this)
            }
        }), ab.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: ab,
            copy: function(a) {
                ea.prototype.copy.call(this, a, !1), a = a.levels;
                for (var b = 0, c = a.length; b < c; b++) {
                    var d = a[b];
                    this.addLevel(d.object.clone(), d.distance)
                }
                return this
            },
            addLevel: function(a, b) {
                void 0 === b && (b = 0), b = Math.abs(b);
                for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++);
                c.splice(d, 0, {
                    distance: b,
                    object: a
                }), this.add(a)
            },
            getObjectForDistance: function(a) {
                for (var b = this.levels, c = 1, d = b.length; c < d && !(a < b[c].distance); c++);
                return b[c - 1].object
            },
            raycast: function() {
                var a = new i;
                return function(b, c) {
                    a.setFromMatrixPosition(this.matrixWorld);
                    var d = b.ray.origin.distanceTo(a);
                    this.getObjectForDistance(d).raycast(b, c)
                }
            }(),
            update: function() {
                var a = new i,
                    b = new i;
                return function(c) {
                    var d = this.levels;
                    if (1 < d.length) {
                        a.setFromMatrixPosition(c.matrixWorld), b.setFromMatrixPosition(this.matrixWorld), c = a.distanceTo(b), d[0].object.visible = !0;
                        for (var e = 1, f = d.length; e < f && c >= d[e].distance; e++) d[e - 1].object.visible = !1, d[e].object.visible = !0;
                        for (; e < f; e++) d[e].object.visible = !1
                    }
                }
            }(),
            toJSON: function(a) {
                a = ea.prototype.toJSON.call(this, a), a.object.levels = [];
                for (var b = this.levels, c = 0, d = b.length; c < d; c++) {
                    var e = b[c];
                    a.object.levels.push({
                        object: e.object.uuid,
                        distance: e.distance
                    })
                }
                return a
            }
        }), bb.prototype = Object.create(d.prototype), bb.prototype.constructor = bb, bb.prototype.isDataTexture = !0, Object.assign(cb.prototype, {
            calculateInverses: function() {
                this.boneInverses = [];
                for (var a = 0, b = this.bones.length; a < b; a++) {
                    var c = new j;
                    this.bones[a] && c.getInverse(this.bones[a].matrixWorld), this.boneInverses.push(c)
                }
            },
            pose: function() {
                for (var a, b = 0, c = this.bones.length; b < c; b++)(a = this.bones[b]) && a.matrixWorld.getInverse(this.boneInverses[b]);
                for (b = 0, c = this.bones.length; b < c; b++)(a = this.bones[b]) && (a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale))
            },
            update: function() {
                var a = new j;
                return function() {
                    for (var b = 0, c = this.bones.length; b < c; b++) a.multiplyMatrices(this.bones[b] ? this.bones[b].matrixWorld : this.identityMatrix, this.boneInverses[b]), a.toArray(this.boneMatrices, 16 * b);
                    this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
                }
            }(),
            clone: function() {
                return new cb(this.bones, this.boneInverses, this.useVertexTexture)
            }
        }), db.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: db,
            isBone: !0,
            copy: function(a) {
                return ea.prototype.copy.call(this, a), this.skin = a.skin, this
            }
        }), eb.prototype = Object.assign(Object.create(qa.prototype), {
            constructor: eb,
            isSkinnedMesh: !0,
            bind: function(a, b) {
                this.skeleton = a, void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), b = this.matrixWorld), this.bindMatrix.copy(b), this.bindMatrixInverse.getInverse(b)
            },
            pose: function() {
                this.skeleton.pose()
            },
            normalizeSkinWeights: function() {
                if (this.geometry && this.geometry.isGeometry)
                    for (var a = 0; a < this.geometry.skinWeights.length; a++) {
                        var b = this.geometry.skinWeights[a],
                            c = 1 / b.lengthManhattan();
                        1 / 0 !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0)
                    } else if (this.geometry && this.geometry.isBufferGeometry)
                        for (var b = new e, d = this.geometry.attributes.skinWeight, a = 0; a < d.count; a++) b.x = d.getX(a), b.y = d.getY(a), b.z = d.getZ(a), b.w = d.getW(a), c = 1 / b.lengthManhattan(), 1 / 0 !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0), d.setXYZW(a, b.x, b.y, b.z, b.w)
            },
            updateMatrixWorld: function(a) {
                qa.prototype.updateMatrixWorld.call(this, !0), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode)
            },
            clone: function() {
                return new this.constructor(this.geometry, this.material, this.skeleton.useVertexTexture).copy(this)
            }
        }), fb.prototype = Object.create(U.prototype), fb.prototype.constructor = fb, fb.prototype.isLineBasicMaterial = !0, fb.prototype.copy = function(a) {
            return U.prototype.copy.call(this, a), this.color.copy(a.color), this.linewidth = a.linewidth, this.linecap = a.linecap, this.linejoin = a.linejoin, this
        }, gb.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: gb,
            isLine: !0,
            raycast: function() {
                var a = new j,
                    b = new ba,
                    c = new Y;
                return function(d, e) {
                    var f = d.linePrecision,
                        f = f * f,
                        g = this.geometry,
                        h = this.matrixWorld;
                    if (null === g.boundingSphere && g.computeBoundingSphere(), c.copy(g.boundingSphere), c.applyMatrix4(h), !1 !== d.ray.intersectsSphere(c)) {
                        a.getInverse(h), b.copy(d.ray).applyMatrix4(a);
                        var j = new i,
                            k = new i,
                            h = new i,
                            l = new i,
                            m = this && this.isLineSegments ? 2 : 1;
                        if (g && g.isBufferGeometry) {
                            var n = g.index,
                                o = g.attributes.position.array;
                            if (null !== n)
                                for (var n = n.array, g = 0, p = n.length - 1; g < p; g += m) {
                                    var q = n[g + 1];
                                    j.fromArray(o, 3 * n[g]), k.fromArray(o, 3 * q), q = b.distanceSqToSegment(j, k, l, h), q > f || (l.applyMatrix4(this.matrixWorld), q = d.ray.origin.distanceTo(l), q < d.near || q > d.far || e.push({
                                        distance: q,
                                        point: h.clone().applyMatrix4(this.matrixWorld),
                                        index: g,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    }))
                                } else
                                    for (g = 0, p = o.length / 3 - 1; g < p; g += m) j.fromArray(o, 3 * g), k.fromArray(o, 3 * g + 3), q = b.distanceSqToSegment(j, k, l, h), q > f || (l.applyMatrix4(this.matrixWorld), q = d.ray.origin.distanceTo(l), q < d.near || q > d.far || e.push({
                                        distance: q,
                                        point: h.clone().applyMatrix4(this.matrixWorld),
                                        index: g,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    }))
                        } else if (g && g.isGeometry)
                            for (j = g.vertices, k = j.length, g = 0; g < k - 1; g += m) q = b.distanceSqToSegment(j[g], j[g + 1], l, h), q > f || (l.applyMatrix4(this.matrixWorld), q = d.ray.origin.distanceTo(l), q < d.near || q > d.far || e.push({
                                distance: q,
                                point: h.clone().applyMatrix4(this.matrixWorld),
                                index: g,
                                face: null,
                                faceIndex: null,
                                object: this
                            }))
                    }
                }
            }(),
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), hb.prototype = Object.assign(Object.create(gb.prototype), {
            constructor: hb,
            isLineSegments: !0
        }), ib.prototype = Object.create(U.prototype), ib.prototype.constructor = ib, ib.prototype.isPointsMaterial = !0, ib.prototype.copy = function(a) {
            return U.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.size = a.size, this.sizeAttenuation = a.sizeAttenuation, this
        }, jb.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: jb,
            isPoints: !0,
            raycast: function() {
                var a = new j,
                    b = new ba,
                    c = new Y;
                return function(d, e) {
                    function f(a, c) {
                        var f = b.distanceSqToPoint(a);
                        if (f < l) {
                            var h = b.closestPointToPoint(a);
                            h.applyMatrix4(j);
                            var i = d.ray.origin.distanceTo(h);
                            i < d.near || i > d.far || e.push({
                                distance: i,
                                distanceToRay: Math.sqrt(f),
                                point: h.clone(),
                                index: c,
                                face: null,
                                object: g
                            })
                        }
                    }
                    var g = this,
                        h = this.geometry,
                        j = this.matrixWorld,
                        k = d.params.Points.threshold;
                    if (null === h.boundingSphere && h.computeBoundingSphere(), c.copy(h.boundingSphere), c.applyMatrix4(j), !1 !== d.ray.intersectsSphere(c)) {
                        a.getInverse(j), b.copy(d.ray).applyMatrix4(a);
                        var k = k / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            l = k * k,
                            k = new i;
                        if (h && h.isBufferGeometry) {
                            var m = h.index,
                                h = h.attributes.position.array;
                            if (null !== m)
                                for (var n = m.array, m = 0, o = n.length; m < o; m++) {
                                    var p = n[m];
                                    k.fromArray(h, 3 * p), f(k, p)
                                } else
                                    for (m = 0, n = h.length / 3; m < n; m++) k.fromArray(h, 3 * m), f(k, m)
                        } else
                            for (k = h.vertices, m = 0, n = k.length; m < n; m++) f(k[m], m)
                    }
                }
            }(),
            clone: function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }
        }), kb.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: kb
        }), lb.prototype = Object.create(d.prototype), lb.prototype.constructor = lb, mb.prototype = Object.create(d.prototype), mb.prototype.constructor = mb, mb.prototype.isCompressedTexture = !0, nb.prototype = Object.create(d.prototype), nb.prototype.constructor = nb, ob.prototype = Object.create(d.prototype), ob.prototype.constructor = ob, ob.prototype.isDepthTexture = !0, pb.prototype = Object.create(pa.prototype), pb.prototype.constructor = pb, qb.prototype = Object.create(na.prototype), qb.prototype.constructor = qb, rb.prototype = Object.create(na.prototype), rb.prototype.constructor = rb, sb.prototype = Object.create(rb.prototype), sb.prototype.constructor = sb, tb.prototype = Object.create(rb.prototype), tb.prototype.constructor = tb, ub.prototype = Object.create(rb.prototype), ub.prototype.constructor = ub, vb.prototype = Object.create(rb.prototype), vb.prototype.constructor = vb, wb.prototype = Object.create(na.prototype), wb.prototype.constructor = wb, wb.NoTaper = function(a) {
            return 1
        }, wb.SinusoidalTaper = function(a) {
            return Math.sin(Math.PI * a)
        }, wb.FrenetFrames = function(b, c, d) {
            var e = new i,
                f = [],
                g = [],
                h = [],
                k = new i,
                l = new j;
            c += 1;
            var m, n, o;
            for (this.tangents = f, this.normals = g, this.binormals = h, m = 0; m < c; m++) n = m / (c - 1), f[m] = b.getTangentAt(n), f[m].normalize();
            for (g[0] = new i, h[0] = new i, b = Number.MAX_VALUE, m = Math.abs(f[0].x), n = Math.abs(f[0].y), o = Math.abs(f[0].z), m <= b && (b = m, e.set(1, 0, 0)), n <= b && (b = n, e.set(0, 1, 0)), o <= b && e.set(0, 0, 1), k.crossVectors(f[0], e).normalize(), g[0].crossVectors(f[0], k), h[0].crossVectors(f[0], g[0]), m = 1; m < c; m++) g[m] = g[m - 1].clone(), h[m] = h[m - 1].clone(), k.crossVectors(f[m - 1], f[m]), k.length() > Number.EPSILON && (k.normalize(), e = Math.acos(a.Math.clamp(f[m - 1].dot(f[m]), -1, 1)), g[m].applyMatrix4(l.makeRotationAxis(k, e))), h[m].crossVectors(f[m], g[m]);
            if (d)
                for (e = Math.acos(a.Math.clamp(g[0].dot(g[c - 1]), -1, 1)), e /= c - 1, 0 < f[0].dot(k.crossVectors(g[0], g[c - 1])) && (e = -e), m = 1; m < c; m++) g[m].applyMatrix4(l.makeRotationAxis(f[m], e * m)), h[m].crossVectors(f[m], g[m])
        }, xb.prototype = Object.create(pa.prototype), xb.prototype.constructor = xb, yb.prototype = Object.create(na.prototype), yb.prototype.constructor = yb, zb.prototype = Object.create(pa.prototype), zb.prototype.constructor = zb, Ab.prototype = Object.create(na.prototype), Ab.prototype.constructor = Ab, a.ShapeUtils = {
            area: function(a) {
                for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++) c += a[d].x * a[e].y - a[e].x * a[d].y;
                return .5 * c
            },
            triangulate: function() {
                return function(b, c) {
                    var d = b.length;
                    if (3 > d) return null;
                    var e, f, g, h = [],
                        i = [],
                        j = [];
                    if (0 < a.ShapeUtils.area(b))
                        for (f = 0; f < d; f++) i[f] = f;
                    else
                        for (f = 0; f < d; f++) i[f] = d - 1 - f;
                    var k = 2 * d;
                    for (f = d - 1; 2 < d;) {
                        if (0 >= k--) {
                            console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");
                            break
                        }
                        e = f, d <= e && (e = 0), f = e + 1, d <= f && (f = 0), g = f + 1, d <= g && (g = 0);
                        var l;
                        a: {
                            var m, n, o, p, q, r, s, t;
                            if (m = b[i[e]].x, n = b[i[e]].y, o = b[i[f]].x, p = b[i[f]].y, q = b[i[g]].x, r = b[i[g]].y, Number.EPSILON > (o - m) * (r - n) - (p - n) * (q - m)) l = !1;
                            else {
                                var u, v, w, x, y, z, A, B, C, D;
                                for (u = q - o, v = r - p, w = m - q, x = n - r, y = o - m, z = p - n, l = 0; l < d; l++)
                                    if (s = b[i[l]].x, t = b[i[l]].y, !(s === m && t === n || s === o && t === p || s === q && t === r) && (A = s - m, B = t - n, C = s - o, D = t - p, s -= q, t -= r, C = u * D - v * C, A = y * B - z * A, B = w * t - x * s, C >= -Number.EPSILON && B >= -Number.EPSILON && A >= -Number.EPSILON)) {
                                        l = !1;
                                        break a
                                    }
                                l = !0
                            }
                        }
                        if (l) {
                            for (h.push([b[i[e]], b[i[f]], b[i[g]]]), j.push([i[e], i[f], i[g]]), e = f, g = f + 1; g < d; e++, g++) i[e] = i[g];
                            d--, k = 2 * d
                        }
                    }
                    return c ? j : h
                }
            }(),
            triangulateShape: function(b, c) {
                function d(a) {
                    var b = a.length;
                    2 < b && a[b - 1].equals(a[0]) && a.pop()
                }

                function e(a, b, c) {
                    return a.x !== b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y
                }

                function f(a, b, c, d, f) {
                    var g = b.x - a.x,
                        h = b.y - a.y,
                        i = d.x - c.x,
                        j = d.y - c.y,
                        k = a.x - c.x,
                        l = a.y - c.y,
                        m = h * i - g * j,
                        n = h * k - g * l;
                    if (Math.abs(m) > Number.EPSILON) {
                        if (0 < m) {
                            if (0 > n || n > m) return [];
                            if (i = j * k - i * l, 0 > i || i > m) return []
                        } else {
                            if (0 < n || n < m) return [];
                            if (i = j * k - i * l, 0 < i || i < m) return []
                        }
                        return 0 === i ? !f || 0 !== n && n !== m ? [a] : [] : i === m ? !f || 0 !== n && n !== m ? [b] : [] : 0 === n ? [c] : n === m ? [d] : (f = i / m, [{
                            x: a.x + f * g,
                            y: a.y + f * h
                        }])
                    }
                    return 0 !== n || j * k !== i * l ? [] : (h = 0 === g && 0 === h, i = 0 === i && 0 === j, h && i ? a.x !== c.x || a.y !== c.y ? [] : [a] : h ? e(c, d, a) ? [a] : [] : i ? e(a, b, c) ? [c] : [] : (0 !== g ? (a.x < b.x ? (g = a, i = a.x, h = b, a = b.x) : (g = b, i = b.x, h = a, a = a.x), c.x < d.x ? (b = c, m = c.x, j = d, c = d.x) : (b = d, m = d.x, j = c, c = c.x)) : (a.y < b.y ? (g = a, i = a.y, h = b, a = b.y) : (g = b, i = b.y, h = a, a = a.y), c.y < d.y ? (b = c, m = c.y, j = d, c = d.y) : (b = d, m = d.y, j = c, c = c.y)), i <= m ? a < m ? [] : a === m ? f ? [] : [b] : a <= c ? [b, h] : [b, j] : i > c ? [] : i === c ? f ? [] : [g] : a <= c ? [g, h] : [g, j]))
                }

                function g(a, b, c, d) {
                    var e = b.x - a.x,
                        f = b.y - a.y;
                    b = c.x - a.x, c = c.y - a.y;
                    var g = d.x - a.x;
                    return d = d.y - a.y, a = e * c - f * b, e = e * d - f * g, Math.abs(a) > Number.EPSILON ? (b = g * c - d * b, 0 < a ? 0 <= e && 0 <= b : 0 <= e || 0 <= b) : 0 < e
                }
                d(b), c.forEach(d);
                var h, i, j, k, l, m = {};
                for (j = b.concat(), h = 0, i = c.length; h < i; h++) Array.prototype.push.apply(j, c[h]);
                for (h = 0, i = j.length; h < i; h++) l = j[h].x + ":" + j[h].y, void 0 !== m[l] && console.warn("THREE.ShapeUtils: Duplicate point", l, h), m[l] = h;
                h = function(a, b) {
                    function c(a, b) {
                        var c = q.length - 1,
                            d = a - 1;
                        0 > d && (d = c);
                        var e = a + 1;
                        return e > c && (e = 0), !!(c = g(q[a], q[d], q[e], h[b])) && (c = h.length - 1, d = b - 1, 0 > d && (d = c), e = b + 1, e > c && (e = 0), !!(c = g(h[b], h[d], h[e], q[a])))
                    }

                    function d(a, b) {
                        var c, d;
                        for (c = 0; c < q.length; c++)
                            if (d = c + 1, d %= q.length, d = f(a, b, q[c], q[d], !0), 0 < d.length) return !0;
                        return !1
                    }

                    function e(a, c) {
                        var d, e, g, h;
                        for (d = 0; d < r.length; d++)
                            for (e = b[r[d]], g = 0; g < e.length; g++)
                                if (h = g + 1, h %= e.length, h = f(a, c, e[g], e[h], !0), 0 < h.length) return !0;
                        return !1
                    }
                    var h, i, j, k, l, m, n, o, p, q = a.concat(),
                        r = [],
                        s = [],
                        t = 0;
                    for (i = b.length; t < i; t++) r.push(t);
                    n = 0;
                    for (var u = 2 * r.length; 0 < r.length;) {
                        if (u--, 0 > u) {
                            console.log("Infinite Loop! Holes left:" + r.length + ", Probably Hole outside Shape!");
                            break
                        }
                        for (j = n; j < q.length; j++) {
                            for (k = q[j], i = -1, t = 0; t < r.length; t++)
                                if (l = r[t], m = k.x + ":" + k.y + ":" + l, void 0 === s[m]) {
                                    for (h = b[l], o = 0; o < h.length; o++)
                                        if (l = h[o], c(j, o) && !d(k, l) && !e(k, l)) {
                                            i = o, r.splice(t, 1), n = q.slice(0, j + 1), l = q.slice(j), o = h.slice(i), p = h.slice(0, i + 1), q = n.concat(o).concat(p).concat(l), n = j;
                                            break
                                        }
                                    if (0 <= i) break;
                                    s[m] = !0
                                }
                            if (0 <= i) break
                        }
                    }
                    return q
                }(b, c);
                var n = a.ShapeUtils.triangulate(h, !1);
                for (h = 0, i = n.length; h < i; h++)
                    for (k = n[h], j = 0; 3 > j; j++) l = k[j].x + ":" + k[j].y, l = m[l], void 0 !== l && (k[j] = l);
                return n.concat()
            },
            isClockWise: function(b) {
                return 0 > a.ShapeUtils.area(b)
            },
            b2: function() {
                return function(a, b, c, d) {
                    var e = 1 - a;
                    return e * e * b + 2 * (1 - a) * a * c + a * a * d
                }
            }(),
            b3: function() {
                return function(a, b, c, d, e) {
                    var f = 1 - a,
                        g = 1 - a;
                    return f * f * f * b + 3 * g * g * a * c + 3 * (1 - a) * a * a * d + a * a * a * e
                }
            }()
        }, Bb.prototype = Object.create(na.prototype), Bb.prototype.constructor = Bb, Bb.prototype.addShapeList = function(a, b) {
            for (var c = a.length, d = 0; d < c; d++) this.addShape(a[d], b)
        }, Bb.prototype.addShape = function(b, d) {
            function e(a, b, c) {
                return b || console.error("THREE.ExtrudeGeometry: vec does not exist"), b.clone().multiplyScalar(c).add(a)
            }

            function f(a, b, d) {
                var e, f, g;
                f = a.x - b.x, g = a.y - b.y, e = d.x - a.x;
                var h = d.y - a.y,
                    i = f * f + g * g;
                if (Math.abs(f * h - g * e) > Number.EPSILON) {
                    var j = Math.sqrt(i),
                        k = Math.sqrt(e * e + h * h),
                        i = b.x - g / j;
                    if (b = b.y + f / j, h = ((d.x - h / k - i) * h - (d.y + e / k - b) * e) / (f * h - g * e), e = i + f * h - a.x, f = b + g * h - a.y, g = e * e + f * f, 2 >= g) return new c(e, f);
                    g = Math.sqrt(g / 2)
                } else a = !1, f > Number.EPSILON ? e > Number.EPSILON && (a = !0) : f < -Number.EPSILON ? e < -Number.EPSILON && (a = !0) : Math.sign(g) === Math.sign(h) && (a = !0), a ? (e = -g, g = Math.sqrt(i)) : (e = f, f = g, g = Math.sqrt(i / 2));
                return new c(e / g, f / g)
            }

            function g(a, b) {
                var c, d;
                for (P = a.length; 0 <= --P;) {
                    c = P, d = P - 1, 0 > d && (d = a.length - 1);
                    var e, f = v + 2 * s;
                    for (e = 0; e < f; e++) {
                        var g = N * e,
                            h = N * (e + 1),
                            i = b + c + g,
                            g = b + d + g,
                            j = b + d + h,
                            h = b + c + h,
                            i = i + D,
                            g = g + D,
                            j = j + D,
                            h = h + D;
                        C.faces.push(new ha(i, g, h, null, null, 1)), C.faces.push(new ha(g, j, h, null, null, 1)), i = y.generateSideWallUV(C, i, g, j, h), C.faceVertexUvs[0].push([i[0], i[1], i[3]]), C.faceVertexUvs[0].push([i[1], i[2], i[3]])
                    }
                }
            }

            function h(a, b, c) {
                C.vertices.push(new i(a, b, c))
            }

            function j(a, b, c) {
                a += D, b += D, c += D, C.faces.push(new ha(a, b, c, null, null, 0)), a = y.generateTopUV(C, a, b, c), C.faceVertexUvs[0].push(a)
            }
            var k, l, m, n, o, p = void 0 !== d.amount ? d.amount : 100,
                q = void 0 !== d.bevelThickness ? d.bevelThickness : 6,
                r = void 0 !== d.bevelSize ? d.bevelSize : q - 2,
                s = void 0 !== d.bevelSegments ? d.bevelSegments : 3,
                t = void 0 === d.bevelEnabled || d.bevelEnabled,
                u = void 0 !== d.curveSegments ? d.curveSegments : 12,
                v = void 0 !== d.steps ? d.steps : 1,
                w = d.extrudePath,
                x = !1,
                y = void 0 !== d.UVGenerator ? d.UVGenerator : Bb.WorldUVGenerator;
            w && (k = w.getSpacedPoints(v), x = !0, t = !1, l = void 0 !== d.frames ? d.frames : new wb.FrenetFrames(w, v, !1), m = new i, n = new i, o = new i), t || (r = q = s = 0);
            var z, A, B, C = this,
                D = this.vertices.length,
                w = b.extractPoints(u),
                u = w.shape,
                E = w.holes;
            if (w = !a.ShapeUtils.isClockWise(u)) {
                for (u = u.reverse(), A = 0, B = E.length; A < B; A++) z = E[A], a.ShapeUtils.isClockWise(z) && (E[A] = z.reverse());
                w = !1
            }
            var F = a.ShapeUtils.triangulateShape(u, E),
                G = u;
            for (A = 0, B = E.length; A < B; A++) z = E[A], u = u.concat(z);
            var H, I, J, K, L, M, N = u.length,
                O = F.length,
                w = [],
                P = 0;
            for (J = G.length, H = J - 1, I = P + 1; P < J; P++, H++, I++) H === J && (H = 0), I === J && (I = 0), w[P] = f(G[P], G[H], G[I]);
            var Q, R = [],
                S = w.concat();
            for (A = 0, B = E.length; A < B; A++) {
                for (z = E[A], Q = [], P = 0, J = z.length, H = J - 1, I = P + 1; P < J; P++, H++, I++) H === J && (H = 0), I === J && (I = 0), Q[P] = f(z[P], z[H], z[I]);
                R.push(Q), S = S.concat(Q)
            }
            for (H = 0; H < s; H++) {
                for (J = H / s, K = q * Math.cos(J * Math.PI / 2), I = r * Math.sin(J * Math.PI / 2), P = 0, J = G.length; P < J; P++) L = e(G[P], w[P], I), h(L.x, L.y, -K);
                for (A = 0, B = E.length; A < B; A++)
                    for (z = E[A], Q = R[A], P = 0, J = z.length; P < J; P++) L = e(z[P], Q[P], I), h(L.x, L.y, -K)
            }
            for (I = r, P = 0; P < N; P++) L = t ? e(u[P], S[P], I) : u[P], x ? (n.copy(l.normals[0]).multiplyScalar(L.x), m.copy(l.binormals[0]).multiplyScalar(L.y), o.copy(k[0]).add(n).add(m), h(o.x, o.y, o.z)) : h(L.x, L.y, 0);
            for (J = 1; J <= v; J++)
                for (P = 0; P < N; P++) L = t ? e(u[P], S[P], I) : u[P], x ? (n.copy(l.normals[J]).multiplyScalar(L.x), m.copy(l.binormals[J]).multiplyScalar(L.y), o.copy(k[J]).add(n).add(m), h(o.x, o.y, o.z)) : h(L.x, L.y, p / v * J);
            for (H = s - 1; 0 <= H; H--) {
                for (J = H / s, K = q * Math.cos(J * Math.PI / 2), I = r * Math.sin(J * Math.PI / 2), P = 0, J = G.length; P < J; P++) L = e(G[P], w[P], I), h(L.x, L.y, p + K);
                for (A = 0, B = E.length; A < B; A++)
                    for (z = E[A], Q = R[A], P = 0, J = z.length; P < J; P++) L = e(z[P], Q[P], I), x ? h(L.x, L.y + k[v - 1].y, k[v - 1].x + K) : h(L.x, L.y, p + K)
            }! function() {
                if (t) {
                    var a = 0 * N;
                    for (P = 0; P < O; P++) M = F[P], j(M[2] + a, M[1] + a, M[0] + a);
                    for (a = N * (v + 2 * s), P = 0; P < O; P++) M = F[P], j(M[0] + a, M[1] + a, M[2] + a)
                } else {
                    for (P = 0; P < O; P++) M = F[P], j(M[2], M[1], M[0]);
                    for (P = 0; P < O; P++) M = F[P], j(M[0] + N * v, M[1] + N * v, M[2] + N * v)
                }
            }(),
            function() {
                var a = 0;
                for (g(G, a), a += G.length, A = 0, B = E.length; A < B; A++) z = E[A], g(z, a), a += z.length
            }()
        }, Bb.WorldUVGenerator = {
            generateTopUV: function(a, b, d, e) {
                return a = a.vertices, b = a[b], d = a[d], e = a[e], [new c(b.x, b.y), new c(d.x, d.y), new c(e.x, e.y)]
            },
            generateSideWallUV: function(a, b, d, e, f) {
                return a = a.vertices, b = a[b], d = a[d], e = a[e], f = a[f], .01 > Math.abs(b.y - d.y) ? [new c(b.x, 1 - b.z), new c(d.x, 1 - d.z), new c(e.x, 1 - e.z), new c(f.x, 1 - f.z)] : [new c(b.y, 1 - b.z), new c(d.y, 1 - d.z), new c(e.y, 1 - e.z), new c(f.y, 1 - f.z)]
            }
        }, Cb.prototype = Object.create(Bb.prototype), Cb.prototype.constructor = Cb, Db.prototype = Object.create(pa.prototype), Db.prototype.constructor = Db, Eb.prototype = Object.create(na.prototype), Eb.prototype.constructor = Eb, Fb.prototype = Object.create(pa.prototype), Fb.prototype.constructor = Fb, Gb.prototype = Object.create(na.prototype), Gb.prototype.constructor = Gb, Hb.prototype = Object.create(na.prototype), Hb.prototype.constructor = Hb, Ib.prototype = Object.create(pa.prototype), Ib.prototype.constructor = Ib, Jb.prototype = Object.create(na.prototype), Jb.prototype.constructor = Jb, Kb.prototype = Object.create(na.prototype), Kb.prototype.constructor = Kb, Kb.prototype.addShapeList = function(a, b) {
            for (var c = 0, d = a.length; c < d; c++) this.addShape(a[c], b);
            return this
        }, Kb.prototype.addShape = function(b, c) {
            void 0 === c && (c = {});
            var d, e, f, g = c.material,
                h = void 0 === c.UVGenerator ? Bb.WorldUVGenerator : c.UVGenerator,
                j = this.vertices.length;
            d = b.extractPoints(void 0 !== c.curveSegments ? c.curveSegments : 12);
            var k = d.shape,
                l = d.holes;
            if (!a.ShapeUtils.isClockWise(k))
                for (k = k.reverse(), d = 0, e = l.length; d < e; d++) f = l[d], a.ShapeUtils.isClockWise(f) && (l[d] = f.reverse());
            var m = a.ShapeUtils.triangulateShape(k, l);
            for (d = 0, e = l.length; d < e; d++) f = l[d], k = k.concat(f);
            for (l = k.length, e = m.length, d = 0; d < l; d++) f = k[d], this.vertices.push(new i(f.x, f.y, 0));
            for (d = 0; d < e; d++) l = m[d], k = l[0] + j, f = l[1] + j, l = l[2] + j, this.faces.push(new ha(k, f, l, null, null, g)), this.faceVertexUvs[0].push(h.generateTopUV(this, k, f, l))
        }, Lb.prototype = Object.create(pa.prototype), Lb.prototype.constructor = Lb, Mb.prototype = Object.create(pa.prototype), Mb.prototype.constructor = Mb, Nb.prototype = Object.create(na.prototype), Nb.prototype.constructor = Nb, Ob.prototype = Object.create(Nb.prototype), Ob.prototype.constructor = Ob, Pb.prototype = Object.create(pa.prototype), Pb.prototype.constructor = Pb, Qb.prototype = Object.create(pa.prototype), Qb.prototype.constructor = Qb, Rb.prototype = Object.create(na.prototype), Rb.prototype.constructor = Rb, Sb.prototype = Object.create(na.prototype), Sb.prototype.constructor = Sb;
        var Zd = Object.freeze({
            WireframeGeometry: pb,
            ParametricGeometry: qb,
            TetrahedronGeometry: sb,
            OctahedronGeometry: tb,
            IcosahedronGeometry: ub,
            DodecahedronGeometry: vb,
            PolyhedronGeometry: rb,
            TubeGeometry: wb,
            TorusKnotGeometry: yb,
            TorusKnotBufferGeometry: xb,
            TorusGeometry: Ab,
            TorusBufferGeometry: zb,
            TextGeometry: Cb,
            SphereBufferGeometry: Db,
            SphereGeometry: Eb,
            RingGeometry: Gb,
            RingBufferGeometry: Fb,
            PlaneBufferGeometry: sa,
            PlaneGeometry: Hb,
            LatheGeometry: Jb,
            LatheBufferGeometry: Ib,
            ShapeGeometry: Kb,
            ExtrudeGeometry: Bb,
            EdgesGeometry: Lb,
            ConeGeometry: Ob,
            ConeBufferGeometry: Pb,
            CylinderGeometry: Nb,
            CylinderBufferGeometry: Mb,
            CircleBufferGeometry: Qb,
            CircleGeometry: Rb,
            BoxBufferGeometry: ra,
            BoxGeometry: Sb
        });
        Tb.prototype = Object.create(V.prototype), Tb.prototype.constructor = Tb, Tb.prototype.isShadowMaterial = !0, Ub.prototype = Object.create(V.prototype), Ub.prototype.constructor = Ub, Ub.prototype.isRawShaderMaterial = !0, Vb.prototype = {
            constructor: Vb,
            isMultiMaterial: !0,
            toJSON: function(a) {
                for (var b = {
                        metadata: {
                            version: 4.2,
                            type: "material",
                            generator: "MaterialExporter"
                        },
                        uuid: this.uuid,
                        type: this.type,
                        materials: []
                    }, c = this.materials, d = 0, e = c.length; d < e; d++) {
                    var f = c[d].toJSON(a);
                    delete f.metadata, b.materials.push(f)
                }
                return b.visible = this.visible, b
            },
            clone: function() {
                for (var a = new this.constructor, b = 0; b < this.materials.length; b++) a.materials.push(this.materials[b].clone());
                return a.visible = this.visible, a
            }
        }, Wb.prototype = Object.create(U.prototype), Wb.prototype.constructor = Wb, Wb.prototype.isMeshStandardMaterial = !0, Wb.prototype.copy = function(a) {
            return U.prototype.copy.call(this, a), this.defines = {
                STANDARD: ""
            }, this.color.copy(a.color), this.roughness = a.roughness, this.metalness = a.metalness, this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.roughnessMap = a.roughnessMap, this.metalnessMap = a.metalnessMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.envMapIntensity = a.envMapIntensity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
        }, Xb.prototype = Object.create(Wb.prototype), Xb.prototype.constructor = Xb, Xb.prototype.isMeshPhysicalMaterial = !0, Xb.prototype.copy = function(a) {
            return Wb.prototype.copy.call(this, a), this.defines = {
                PHYSICAL: ""
            }, this.reflectivity = a.reflectivity, this.clearCoat = a.clearCoat, this.clearCoatRoughness = a.clearCoatRoughness, this
        }, Yb.prototype = Object.create(U.prototype), Yb.prototype.constructor = Yb, Yb.prototype.isMeshPhongMaterial = !0, Yb.prototype.copy = function(a) {
            return U.prototype.copy.call(this, a), this.color.copy(a.color), this.specular.copy(a.specular), this.shininess = a.shininess, this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, this.bumpMap = a.bumpMap, this.bumpScale = a.bumpScale, this.normalMap = a.normalMap, this.normalScale.copy(a.normalScale), this.displacementMap = a.displacementMap, this.displacementScale = a.displacementScale, this.displacementBias = a.displacementBias, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
        }, Zb.prototype = Object.create(U.prototype), Zb.prototype.constructor = Zb, Zb.prototype.isMeshNormalMaterial = !0, Zb.prototype.copy = function(a) {
            return U.prototype.copy.call(this, a), this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this
        }, $b.prototype = Object.create(U.prototype), $b.prototype.constructor = $b, $b.prototype.isMeshLambertMaterial = !0, $b.prototype.copy = function(a) {
            return U.prototype.copy.call(this, a), this.color.copy(a.color), this.map = a.map, this.lightMap = a.lightMap, this.lightMapIntensity = a.lightMapIntensity, this.aoMap = a.aoMap, this.aoMapIntensity = a.aoMapIntensity, this.emissive.copy(a.emissive), this.emissiveMap = a.emissiveMap, this.emissiveIntensity = a.emissiveIntensity, this.specularMap = a.specularMap, this.alphaMap = a.alphaMap, this.envMap = a.envMap, this.combine = a.combine, this.reflectivity = a.reflectivity, this.refractionRatio = a.refractionRatio, this.wireframe = a.wireframe, this.wireframeLinewidth = a.wireframeLinewidth, this.wireframeLinecap = a.wireframeLinecap, this.wireframeLinejoin = a.wireframeLinejoin, this.skinning = a.skinning, this.morphTargets = a.morphTargets, this.morphNormals = a.morphNormals, this
        }, _b.prototype = Object.create(U.prototype), _b.prototype.constructor = _b, _b.prototype.isLineDashedMaterial = !0, _b.prototype.copy = function(a) {
            return U.prototype.copy.call(this, a), this.color.copy(a.color), this.linewidth = a.linewidth, this.scale = a.scale, this.dashSize = a.dashSize, this.gapSize = a.gapSize, this
        };
        var $d = Object.freeze({
            ShadowMaterial: Tb,
            SpriteMaterial: $a,
            RawShaderMaterial: Ub,
            ShaderMaterial: V,
            PointsMaterial: ib,
            MultiMaterial: Vb,
            MeshPhysicalMaterial: Xb,
            MeshStandardMaterial: Wb,
            MeshPhongMaterial: Yb,
            MeshNormalMaterial: Zb,
            MeshLambertMaterial: $b,
            MeshDepthMaterial: W,
            MeshBasicMaterial: ia,
            LineDashedMaterial: _b,
            LineBasicMaterial: fb,
            Material: U
        });
        a.Cache = {
            enabled: !1,
            files: {},
            add: function(a, b) {
                !1 !== this.enabled && (this.files[a] = b)
            },
            get: function(a) {
                if (!1 !== this.enabled) return this.files[a]
            },
            remove: function(a) {
                delete this.files[a]
            },
            clear: function() {
                this.files = {}
            }
        }, a.DefaultLoadingManager = new ac, Object.assign(bc.prototype, {
            load: function(b, c, d, e) {
                void 0 !== this.path && (b = this.path + b);
                var f = this,
                    g = a.Cache.get(b);
                if (void 0 !== g) return f.manager.itemStart(b), setTimeout(function() {
                    c && c(g), f.manager.itemEnd(b)
                }, 0), g;
                var h = new XMLHttpRequest;
                return h.open("GET", b, !0), h.addEventListener("load", function(d) {
                    var g = d.target.response;
                    a.Cache.add(b, g), 200 === this.status ? (c && c(g), f.manager.itemEnd(b)) : 0 === this.status ? (console.warn("THREE.XHRLoader: HTTP Status 0 received."), c && c(g), f.manager.itemEnd(b)) : (e && e(d), f.manager.itemError(b))
                }, !1), void 0 !== d && h.addEventListener("progress", function(a) {
                    d(a)
                }, !1), h.addEventListener("error", function(a) {
                    e && e(a), f.manager.itemError(b)
                }, !1), void 0 !== this.responseType && (h.responseType = this.responseType), void 0 !== this.withCredentials && (h.withCredentials = this.withCredentials), h.overrideMimeType && h.overrideMimeType("text/plain"), h.send(null), f.manager.itemStart(b), h
            },
            setPath: function(a) {
                return this.path = a, this
            },
            setResponseType: function(a) {
                return this.responseType = a, this
            },
            setWithCredentials: function(a) {
                return this.withCredentials = a, this
            }
        }), Object.assign(cc.prototype, {
            load: function(a, b, c, d) {
                function e(e) {
                    i.load(a[e], function(a) {
                        a = f._parser(a, !0), g[e] = {
                            width: a.width,
                            height: a.height,
                            format: a.format,
                            mipmaps: a.mipmaps
                        }, j += 1, 6 === j && (1 === a.mipmapCount && (h.minFilter = 1006), h.format = a.format, h.needsUpdate = !0, b && b(h))
                    }, c, d)
                }
                var f = this,
                    g = [],
                    h = new mb;
                h.image = g;
                var i = new bc(this.manager);
                if (i.setPath(this.path), i.setResponseType("arraybuffer"), Array.isArray(a))
                    for (var j = 0, k = 0, l = a.length; k < l; ++k) e(k);
                else i.load(a, function(a) {
                    if (a = f._parser(a, !0), a.isCubemap)
                        for (var c = a.mipmaps.length / a.mipmapCount, d = 0; d < c; d++) {
                            g[d] = {
                                mipmaps: []
                            };
                            for (var e = 0; e < a.mipmapCount; e++) g[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]), g[d].format = a.format, g[d].width = a.width, g[d].height = a.height
                        } else h.image.width = a.width, h.image.height = a.height, h.mipmaps = a.mipmaps;
                    1 === a.mipmapCount && (h.minFilter = 1006), h.format = a.format, h.needsUpdate = !0, b && b(h)
                }, c, d);
                return h
            },
            setPath: function(a) {
                return this.path = a, this
            }
        }), Object.assign(dc.prototype, {
            load: function(a, b, c, d) {
                var e = this,
                    f = new bb,
                    g = new bc(this.manager);
                return g.setResponseType("arraybuffer"), g.load(a, function(a) {
                    (a = e._parser(a)) && (void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001, f.wrapT = void 0 !== a.wrapT ? a.wrapT : 1001, f.magFilter = void 0 !== a.magFilter ? a.magFilter : 1006, f.minFilter = void 0 !== a.minFilter ? a.minFilter : 1008, f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 1 === a.mipmapCount && (f.minFilter = 1006), f.needsUpdate = !0, b && b(f, a))
                }, c, d), f
            }
        }), Object.assign(ec.prototype, {
            load: function(a, b, c, d) {
                var e = this,
                    f = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
                if (f.onload = function() {
                        f.onload = null, URL.revokeObjectURL(f.src), b && b(f), e.manager.itemEnd(a)
                    }, 0 === a.indexOf("data:")) f.src = a;
                else {
                    var g = new bc;
                    g.setPath(this.path), g.setResponseType("blob"), g.setWithCredentials(this.withCredentials), g.load(a, function(a) {
                        f.src = URL.createObjectURL(a)
                    }, c, d)
                }
                return e.manager.itemStart(a), f
            },
            setCrossOrigin: function(a) {
                return this.crossOrigin = a, this
            },
            setWithCredentials: function(a) {
                return this.withCredentials = a, this
            },
            setPath: function(a) {
                return this.path = a, this
            }
        }), Object.assign(fc.prototype, {
            load: function(a, b, c, d) {
                function e(c) {
                    g.load(a[c], function(a) {
                        f.images[c] = a, h++, 6 === h && (f.needsUpdate = !0, b && b(f))
                    }, void 0, d)
                }
                var f = new k,
                    g = new ec(this.manager);
                g.setCrossOrigin(this.crossOrigin), g.setPath(this.path);
                var h = 0;
                for (c = 0; c < a.length; ++c) e(c);
                return f
            },
            setCrossOrigin: function(a) {
                return this.crossOrigin = a, this
            },
            setPath: function(a) {
                return this.path = a, this
            }
        }), Object.assign(gc.prototype, {
            load: function(a, b, c, e) {
                var f = new d,
                    g = new ec(this.manager);
                return g.setCrossOrigin(this.crossOrigin), g.setWithCredentials(this.withCredentials), g.setPath(this.path), g.load(a, function(c) {
                    var d = 0 < a.search(/\.(jpg|jpeg)$/) || 0 === a.search(/^data\:image\/jpeg/);
                    f.format = d ? 1022 : 1023, f.image = c, f.needsUpdate = !0, void 0 !== b && b(f)
                }, c, e), f
            },
            setCrossOrigin: function(a) {
                return this.crossOrigin = a, this
            },
            setWithCredentials: function(a) {
                return this.withCredentials = a, this
            },
            setPath: function(a) {
                return this.path = a, this
            }
        }), hc.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: hc,
            isLight: !0,
            copy: function(a) {
                return ea.prototype.copy.call(this, a), this.color.copy(a.color), this.intensity = a.intensity, this
            },
            toJSON: function(a) {
                return a = ea.prototype.toJSON.call(this, a), a.object.color = this.color.getHex(), a.object.intensity = this.intensity, void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (a.object.distance = this.distance), void 0 !== this.angle && (a.object.angle = this.angle), void 0 !== this.decay && (a.object.decay = this.decay), void 0 !== this.penumbra && (a.object.penumbra = this.penumbra), void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON()), a
            }
        }), ic.prototype = Object.assign(Object.create(hc.prototype), {
            constructor: ic,
            isHemisphereLight: !0,
            copy: function(a) {
                return hc.prototype.copy.call(this, a), this.groundColor.copy(a.groundColor), this
            }
        }), Object.assign(jc.prototype, {
            copy: function(a) {
                return this.camera = a.camera.clone(), this.bias = a.bias, this.radius = a.radius, this.mapSize.copy(a.mapSize), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            toJSON: function() {
                var a = {};
                return 0 !== this.bias && (a.bias = this.bias), 1 !== this.radius && (a.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (a.mapSize = this.mapSize.toArray()), a.camera = this.camera.toJSON(!1).object, delete a.camera.matrix, a
            }
        }), kc.prototype = Object.assign(Object.create(jc.prototype), {
            constructor: kc,
            isSpotLightShadow: !0,
            update: function(b) {
                var c = 2 * a.Math.RAD2DEG * b.angle,
                    d = this.mapSize.width / this.mapSize.height;
                b = b.distance || 500;
                var e = this.camera;
                c === e.fov && d === e.aspect && b === e.far || (e.fov = c, e.aspect = d, e.far = b, e.updateProjectionMatrix())
            }
        }), lc.prototype = Object.assign(Object.create(hc.prototype), {
            constructor: lc,
            isSpotLight: !0,
            copy: function(a) {
                return hc.prototype.copy.call(this, a), this.distance = a.distance, this.angle = a.angle, this.penumbra = a.penumbra, this.decay = a.decay, this.target = a.target.clone(), this.shadow = a.shadow.clone(), this
            }
        }), mc.prototype = Object.assign(Object.create(hc.prototype), {
            constructor: mc,
            isPointLight: !0,
            copy: function(a) {
                return hc.prototype.copy.call(this, a), this.distance = a.distance, this.decay = a.decay, this.shadow = a.shadow.clone(), this
            }
        }), nc.prototype = Object.assign(Object.create(jc.prototype), {
            constructor: nc
        }), oc.prototype = Object.assign(Object.create(hc.prototype), {
            constructor: oc,
            isDirectionalLight: !0,
            copy: function(a) {
                return hc.prototype.copy.call(this, a), this.target = a.target.clone(), this.shadow = a.shadow.clone(), this
            }
        }), pc.prototype = Object.assign(Object.create(hc.prototype), {
            constructor: pc,
            isAmbientLight: !0
        }), a.AnimationUtils = {
            arraySlice: function(b, c, d) {
                return a.AnimationUtils.isTypedArray(b) ? new b.constructor(b.subarray(c, d)) : b.slice(c, d)
            },
            convertArray: function(a, b, c) {
                return !a || !c && a.constructor === b ? a : "number" == typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a)
            },
            isTypedArray: function(a) {
                return ArrayBuffer.isView(a) && !(a instanceof DataView)
            },
            getKeyframeOrder: function(a) {
                for (var b = a.length, c = Array(b), d = 0; d !== b; ++d) c[d] = d;
                return c.sort(function(b, c) {
                    return a[b] - a[c]
                }), c
            },
            sortedArray: function(a, b, c) {
                for (var d = a.length, e = new a.constructor(d), f = 0, g = 0; g !== d; ++f)
                    for (var h = c[f] * b, i = 0; i !== b; ++i) e[g++] = a[h + i];
                return e
            },
            flattenJSON: function(a, b, c, d) {
                for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d];) f = a[e++];
                if (void 0 !== f) {
                    var g = f[d];
                    if (void 0 !== g)
                        if (Array.isArray(g)) {
                            do g = f[d], void 0 !== g && (b.push(f.time), c.push.apply(c, g)), f = a[e++]; while (void 0 !== f)
                        } else if (void 0 !== g.toArray) {
                        do g = f[d], void 0 !== g && (b.push(f.time), g.toArray(c, c.length)), f = a[e++]; while (void 0 !== f)
                    } else
                        do g = f[d], void 0 !== g && (b.push(f.time), c.push(g)), f = a[e++]; while (void 0 !== f)
                }
            }
        }, qc.prototype = {
            constructor: qc,
            evaluate: function(a) {
                var b = this.parameterPositions,
                    c = this._cachedIndex,
                    d = b[c],
                    e = b[c - 1];
                a: {
                    b: {
                        c: {
                            d: if (!(a < d)) {
                                for (var f = c + 2;;) {
                                    if (void 0 === d) {
                                        if (a < e) break d;
                                        return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, a, e)
                                    }
                                    if (c === f) break;
                                    if (e = d, d = b[++c], a < d) break b
                                }
                                d = b.length;
                                break c
                            }if (a >= e) break a;
                            for (f = b[1], a < f && (c = 2, e = f), f = c - 2;;) {
                                if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
                                if (c === f) break;
                                if (d = e, e = b[--c - 1], a >= e) break b
                            }
                            d = c,
                            c = 0
                        }
                        for (; c < d;) e = c + d >>> 1,
                        a < b[e] ? d = e : c = e + 1;
                        if (d = b[c], e = b[c - 1], void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
                        if (void 0 === d) return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, e, a)
                    }
                    this._cachedIndex = c,
                    this.intervalChanged_(c, e, d)
                }
                return this.interpolate_(c, e, a, d)
            },
            settings: null,
            DefaultSettings_: {},
            getSettings_: function() {
                return this.settings || this.DefaultSettings_
            },
            copySampleValue_: function(a) {
                var b = this.resultBuffer,
                    c = this.sampleValues,
                    d = this.valueSize;
                a *= d;
                for (var e = 0; e !== d; ++e) b[e] = c[a + e];
                return b
            },
            interpolate_: function(a, b, c, d) {
                throw Error("call to abstract method")
            },
            intervalChanged_: function(a, b, c) {}
        }, Object.assign(qc.prototype, {
            beforeStart_: qc.prototype.copySampleValue_,
            afterEnd_: qc.prototype.copySampleValue_
        }), rc.prototype = Object.assign(Object.create(qc.prototype), {
            constructor: rc,
            DefaultSettings_: {
                endingStart: 2400,
                endingEnd: 2400
            },
            intervalChanged_: function(a, b, c) {
                var d = this.parameterPositions,
                    e = a - 2,
                    f = a + 1,
                    g = d[e],
                    h = d[f];
                if (void 0 === g) switch (this.getSettings_().endingStart) {
                    case 2401:
                        e = a, g = 2 * b - c;
                        break;
                    case 2402:
                        e = d.length - 2, g = b + d[e] - d[e + 1];
                        break;
                    default:
                        e = a, g = c
                }
                if (void 0 === h) switch (this.getSettings_().endingEnd) {
                    case 2401:
                        f = a, h = 2 * c - b;
                        break;
                    case 2402:
                        f = 1, h = c + d[1] - d[0];
                        break;
                    default:
                        f = a - 1, h = b
                }
                a = .5 * (c - b), d = this.valueSize, this._weightPrev = a / (b - g), this._weightNext = a / (h - c), this._offsetPrev = e * d, this._offsetNext = f * d
            },
            interpolate_: function(a, b, c, d) {
                var e = this.resultBuffer,
                    f = this.sampleValues,
                    g = this.valueSize;
                a *= g;
                var h = a - g,
                    i = this._offsetPrev,
                    j = this._offsetNext,
                    k = this._weightPrev,
                    l = this._weightNext,
                    m = (c - b) / (d - b);
                for (c = m * m, d = c * m, b = -k * d + 2 * k * c - k * m, k = (1 + k) * d + (-1.5 - 2 * k) * c + (-.5 + k) * m + 1, m = (-1 - l) * d + (1.5 + l) * c + .5 * m, l = l * d - l * c, c = 0; c !== g; ++c) e[c] = b * f[i + c] + k * f[h + c] + m * f[a + c] + l * f[j + c];
                return e
            }
        }), sc.prototype = Object.assign(Object.create(qc.prototype), {
            constructor: sc,
            interpolate_: function(a, b, c, d) {
                var e = this.resultBuffer,
                    f = this.sampleValues,
                    g = this.valueSize;
                a *= g;
                var h = a - g;
                for (b = (c - b) / (d - b), c = 1 - b, d = 0; d !== g; ++d) e[d] = f[h + d] * c + f[a + d] * b;
                return e
            }
        }), tc.prototype = Object.assign(Object.create(qc.prototype), {
            constructor: tc,
            interpolate_: function(a, b, c, d) {
                return this.copySampleValue_(a - 1)
            }
        });
        var _d;
        _d = {
            TimeBufferType: Float32Array,
            ValueBufferType: Float32Array,
            DefaultInterpolation: 2301,
            InterpolantFactoryMethodDiscrete: function(a) {
                return new tc(this.times, this.values, this.getValueSize(), a)
            },
            InterpolantFactoryMethodLinear: function(a) {
                return new sc(this.times, this.values, this.getValueSize(), a)
            },
            InterpolantFactoryMethodSmooth: function(a) {
                return new rc(this.times, this.values, this.getValueSize(), a)
            },
            setInterpolation: function(a) {
                var b;
                switch (a) {
                    case 2300:
                        b = this.InterpolantFactoryMethodDiscrete;
                        break;
                    case 2301:
                        b = this.InterpolantFactoryMethodLinear;
                        break;
                    case 2302:
                        b = this.InterpolantFactoryMethodSmooth
                }
                if (void 0 === b) {
                    if (b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, void 0 === this.createInterpolant) {
                        if (a === this.DefaultInterpolation) throw Error(b);
                        this.setInterpolation(this.DefaultInterpolation)
                    }
                    console.warn(b)
                } else this.createInterpolant = b
            },
            getInterpolation: function() {
                switch (this.createInterpolant) {
                    case this.InterpolantFactoryMethodDiscrete:
                        return 2300;
                    case this.InterpolantFactoryMethodLinear:
                        return 2301;
                    case this.InterpolantFactoryMethodSmooth:
                        return 2302
                }
            },
            getValueSize: function() {
                return this.values.length / this.times.length
            },
            shift: function(a) {
                if (0 !== a)
                    for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] += a;
                return this
            },
            scale: function(a) {
                if (1 !== a)
                    for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] *= a;
                return this
            },
            trim: function(b, c) {
                for (var d = this.times, e = d.length, f = 0, g = e - 1; f !== e && d[f] < b;) ++f;
                for (; - 1 !== g && d[g] > c;) --g;
                return ++g, 0 === f && g === e || (f >= g && (g = Math.max(g, 1), f = g - 1), e = this.getValueSize(), this.times = a.AnimationUtils.arraySlice(d, f, g), this.values = a.AnimationUtils.arraySlice(this.values, f * e, g * e)), this
            },
            validate: function() {
                var b = !0,
                    c = this.getValueSize();
                0 !== c - Math.floor(c) && (console.error("invalid value size in track", this), b = !1);
                var d = this.times,
                    c = this.values,
                    e = d.length;
                0 === e && (console.error("track is empty", this), b = !1);
                for (var f = null, g = 0; g !== e; g++) {
                    var h = d[g];
                    if ("number" == typeof h && isNaN(h)) {
                        console.error("time is not a valid number", this, g, h), b = !1;
                        break
                    }
                    if (null !== f && f > h) {
                        console.error("out of order keys", this, g, h, f), b = !1;
                        break
                    }
                    f = h
                }
                if (void 0 !== c && a.AnimationUtils.isTypedArray(c))
                    for (g = 0, d = c.length; g !== d; ++g)
                        if (e = c[g], isNaN(e)) {
                            console.error("value is not a valid number", this, g, e), b = !1;
                            break
                        }
                return b
            },
            optimize: function() {
                for (var b = this.times, c = this.values, d = this.getValueSize(), e = 2302 === this.getInterpolation(), f = 1, g = b.length - 1, h = 1; h < g; ++h) {
                    var i = !1,
                        j = b[h];
                    if (j !== b[h + 1] && (1 !== h || j !== j[0]))
                        if (e) i = !0;
                        else
                            for (var k = h * d, l = k - d, m = k + d, j = 0; j !== d; ++j) {
                                var n = c[k + j];
                                if (n !== c[l + j] || n !== c[m + j]) {
                                    i = !0;
                                    break
                                }
                            }
                    if (i) {
                        if (h !== f)
                            for (b[f] = b[h], i = h * d, k = f * d, j = 0; j !== d; ++j) c[k + j] = c[i + j];
                        ++f
                    }
                }
                if (0 < g) {
                    for (b[f] = b[g], i = g * d, k = f * d, j = 0; j !== d; ++j) c[k + j] = c[i + j];
                    ++f
                }
                return f !== b.length && (this.times = a.AnimationUtils.arraySlice(b, 0, f), this.values = a.AnimationUtils.arraySlice(c, 0, f * d)), this
            }
        }, vc.prototype = Object.assign(Object.create(_d), {
            constructor: vc,
            ValueTypeName: "vector"
        }), wc.prototype = Object.assign(Object.create(qc.prototype), {
            constructor: wc,
            interpolate_: function(a, b, c, d) {
                var e = this.resultBuffer,
                    f = this.sampleValues,
                    g = this.valueSize;
                for (a *= g, b = (c - b) / (d - b), c = a + g; a !== c; a += 4) h.slerpFlat(e, 0, f, a - g, f, a, b);
                return e
            }
        }), xc.prototype = Object.assign(Object.create(_d), {
            constructor: xc,
            ValueTypeName: "quaternion",
            DefaultInterpolation: 2301,
            InterpolantFactoryMethodLinear: function(a) {
                return new wc(this.times, this.values, this.getValueSize(), a)
            },
            InterpolantFactoryMethodSmooth: void 0
        }), yc.prototype = Object.assign(Object.create(_d), {
            constructor: yc,
            ValueTypeName: "number"
        }), zc.prototype = Object.assign(Object.create(_d), {
            constructor: zc,
            ValueTypeName: "string",
            ValueBufferType: Array,
            DefaultInterpolation: 2300,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), Ac.prototype = Object.assign(Object.create(_d), {
            constructor: Ac,
            ValueTypeName: "bool",
            ValueBufferType: Array,
            DefaultInterpolation: 2300,
            InterpolantFactoryMethodLinear: void 0,
            InterpolantFactoryMethodSmooth: void 0
        }), Bc.prototype = Object.assign(Object.create(_d), {
            constructor: Bc,
            ValueTypeName: "color"
        }), Cc.prototype = _d, _d.constructor = Cc, Object.assign(Cc, {
            parse: function(b) {
                if (void 0 === b.type) throw Error("track type undefined, can not parse");
                var c = Cc._getTrackTypeForValueTypeName(b.type);
                if (void 0 === b.times) {
                    var d = [],
                        e = [];
                    a.AnimationUtils.flattenJSON(b.keys, d, e, "value"), b.times = d, b.values = e
                }
                return void 0 !== c.parse ? c.parse(b) : new c(b.name, b.times, b.values, b.interpolation)
            },
            toJSON: function(b) {
                var c = b.constructor;
                if (void 0 !== c.toJSON) c = c.toJSON(b);
                else {
                    var c = {
                            name: b.name,
                            times: a.AnimationUtils.convertArray(b.times, Array),
                            values: a.AnimationUtils.convertArray(b.values, Array)
                        },
                        d = b.getInterpolation();
                    d !== b.DefaultInterpolation && (c.interpolation = d)
                }
                return c.type = b.ValueTypeName, c
            },
            _getTrackTypeForValueTypeName: function(a) {
                switch (a.toLowerCase()) {
                    case "scalar":
                    case "double":
                    case "float":
                    case "number":
                    case "integer":
                        return yc;
                    case "vector":
                    case "vector2":
                    case "vector3":
                    case "vector4":
                        return vc;
                    case "color":
                        return Bc;
                    case "quaternion":
                        return xc;
                    case "bool":
                    case "boolean":
                        return Ac;
                    case "string":
                        return zc
                }
                throw Error("Unsupported typeName: " + a)
            }
        }), Dc.prototype = {
            constructor: Dc,
            resetDuration: function() {
                for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b) var d = this.tracks[b],
                    a = Math.max(a, d.times[d.times.length - 1]);
                this.duration = a
            },
            trim: function() {
                for (var a = 0; a < this.tracks.length; a++) this.tracks[a].trim(0, this.duration);
                return this
            },
            optimize: function() {
                for (var a = 0; a < this.tracks.length; a++) this.tracks[a].optimize();
                return this
            }
        }, Object.assign(Dc, {
            parse: function(a) {
                for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length; e !== f; ++e) b.push(Cc.parse(c[e]).scale(d));
                return new Dc(a.name, a.duration, b)
            },
            toJSON: function(a) {
                var b = [],
                    c = a.tracks;
                a = {
                    name: a.name,
                    duration: a.duration,
                    tracks: b
                };
                for (var d = 0, e = c.length; d !== e; ++d) b.push(Cc.toJSON(c[d]));
                return a
            },
            CreateFromMorphTargetSequence: function(b, c, d, e) {
                for (var f = c.length, g = [], h = 0; h < f; h++) {
                    var i = [],
                        j = [];
                    i.push((h + f - 1) % f, h, (h + 1) % f), j.push(0, 1, 0);
                    var k = a.AnimationUtils.getKeyframeOrder(i),
                        i = a.AnimationUtils.sortedArray(i, 1, k),
                        j = a.AnimationUtils.sortedArray(j, 1, k);
                    e || 0 !== i[0] || (i.push(f), j.push(j[0])), g.push(new yc(".morphTargetInfluences[" + c[h].name + "]", i, j).scale(1 / d))
                }
                return new Dc(b, -1, g)
            },
            findByName: function(a, b) {
                var c = a;
                Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations);
                for (var d = 0; d < c.length; d++)
                    if (c[d].name === b) return c[d];
                return null
            },
            CreateClipsFromMorphTargetSequences: function(a, b, c) {
                for (var d = {}, e = /^([\w-]*?)([\d]+)$/, f = 0, g = a.length; f < g; f++) {
                    var h = a[f],
                        i = h.name.match(e);
                    if (i && 1 < i.length) {
                        var j = i[1];
                        (i = d[j]) || (d[j] = i = []), i.push(h)
                    }
                }
                a = [];
                for (j in d) a.push(Dc.CreateFromMorphTargetSequence(j, d[j], b, c));
                return a
            },
            parseAnimation: function(b, c) {
                if (!b) return console.error("  no animation in JSONLoader data"), null;
                for (var d = function(b, c, d, e, f) {
                        if (0 !== d.length) {
                            var g = [],
                                h = [];
                            a.AnimationUtils.flattenJSON(d, g, h, e), 0 !== g.length && f.push(new b(c, g, h))
                        }
                    }, e = [], f = b.name || "default", g = b.length || -1, h = b.fps || 30, i = b.hierarchy || [], j = 0; j < i.length; j++) {
                    var k = i[j].keys;
                    if (k && 0 !== k.length)
                        if (k[0].morphTargets) {
                            for (var g = {}, l = 0; l < k.length; l++)
                                if (k[l].morphTargets)
                                    for (var m = 0; m < k[l].morphTargets.length; m++) g[k[l].morphTargets[m]] = -1;
                            for (var n in g) {
                                for (var o = [], p = [], m = 0; m !== k[l].morphTargets.length; ++m) {
                                    var q = k[l];
                                    o.push(q.time), p.push(q.morphTarget === n ? 1 : 0)
                                }
                                e.push(new yc(".morphTargetInfluence[" + n + "]", o, p))
                            }
                            g = g.length * (h || 1)
                        } else l = ".bones[" + c[j].name + "]", d(vc, l + ".position", k, "pos", e), d(xc, l + ".quaternion", k, "rot", e), d(vc, l + ".scale", k, "scl", e)
                }
                return 0 === e.length ? null : new Dc(f, g, e)
            }
        }), Object.assign(Ec.prototype, {
            load: function(a, b, c, d) {
                var e = this;
                new bc(e.manager).load(a, function(a) {
                    b(e.parse(JSON.parse(a)))
                }, c, d)
            },
            setTextures: function(a) {
                this.textures = a
            },
            parse: function(a) {
                function b(a) {
                    return void 0 === d[a] && console.warn("THREE.MaterialLoader: Undefined texture", a), d[a]
                }
                var d = this.textures,
                    e = new $d[a.type];
                if (void 0 !== a.uuid && (e.uuid = a.uuid), void 0 !== a.name && (e.name = a.name), void 0 !== a.color && e.color.setHex(a.color), void 0 !== a.roughness && (e.roughness = a.roughness), void 0 !== a.metalness && (e.metalness = a.metalness), void 0 !== a.emissive && e.emissive.setHex(a.emissive), void 0 !== a.specular && e.specular.setHex(a.specular), void 0 !== a.shininess && (e.shininess = a.shininess), void 0 !== a.uniforms && (e.uniforms = a.uniforms), void 0 !== a.vertexShader && (e.vertexShader = a.vertexShader), void 0 !== a.fragmentShader && (e.fragmentShader = a.fragmentShader), void 0 !== a.vertexColors && (e.vertexColors = a.vertexColors), void 0 !== a.fog && (e.fog = a.fog), void 0 !== a.shading && (e.shading = a.shading), void 0 !== a.blending && (e.blending = a.blending), void 0 !== a.side && (e.side = a.side), void 0 !== a.opacity && (e.opacity = a.opacity), void 0 !== a.transparent && (e.transparent = a.transparent), void 0 !== a.alphaTest && (e.alphaTest = a.alphaTest), void 0 !== a.depthTest && (e.depthTest = a.depthTest), void 0 !== a.depthWrite && (e.depthWrite = a.depthWrite), void 0 !== a.colorWrite && (e.colorWrite = a.colorWrite), void 0 !== a.wireframe && (e.wireframe = a.wireframe), void 0 !== a.wireframeLinewidth && (e.wireframeLinewidth = a.wireframeLinewidth), void 0 !== a.wireframeLinecap && (e.wireframeLinecap = a.wireframeLinecap), void 0 !== a.wireframeLinejoin && (e.wireframeLinejoin = a.wireframeLinejoin), void 0 !== a.skinning && (e.skinning = a.skinning), void 0 !== a.morphTargets && (e.morphTargets = a.morphTargets), void 0 !== a.size && (e.size = a.size), void 0 !== a.sizeAttenuation && (e.sizeAttenuation = a.sizeAttenuation), void 0 !== a.map && (e.map = b(a.map)), void 0 !== a.alphaMap && (e.alphaMap = b(a.alphaMap), e.transparent = !0), void 0 !== a.bumpMap && (e.bumpMap = b(a.bumpMap)), void 0 !== a.bumpScale && (e.bumpScale = a.bumpScale), void 0 !== a.normalMap && (e.normalMap = b(a.normalMap)), void 0 !== a.normalScale) {
                    var f = a.normalScale;
                    !1 === Array.isArray(f) && (f = [f, f]), e.normalScale = (new c).fromArray(f)
                }
                if (void 0 !== a.displacementMap && (e.displacementMap = b(a.displacementMap)), void 0 !== a.displacementScale && (e.displacementScale = a.displacementScale), void 0 !== a.displacementBias && (e.displacementBias = a.displacementBias), void 0 !== a.roughnessMap && (e.roughnessMap = b(a.roughnessMap)), void 0 !== a.metalnessMap && (e.metalnessMap = b(a.metalnessMap)), void 0 !== a.emissiveMap && (e.emissiveMap = b(a.emissiveMap)), void 0 !== a.emissiveIntensity && (e.emissiveIntensity = a.emissiveIntensity), void 0 !== a.specularMap && (e.specularMap = b(a.specularMap)), void 0 !== a.envMap && (e.envMap = b(a.envMap)), void 0 !== a.reflectivity && (e.reflectivity = a.reflectivity), void 0 !== a.lightMap && (e.lightMap = b(a.lightMap)), void 0 !== a.lightMapIntensity && (e.lightMapIntensity = a.lightMapIntensity), void 0 !== a.aoMap && (e.aoMap = b(a.aoMap)), void 0 !== a.aoMapIntensity && (e.aoMapIntensity = a.aoMapIntensity), void 0 !== a.materials)
                    for (var f = 0, g = a.materials.length; f < g; f++) e.materials.push(this.parse(a.materials[f]));
                return e
            }
        }), Object.assign(Fc.prototype, {
            load: function(a, b, c, d) {
                var e = this;
                new bc(e.manager).load(a, function(a) {
                    b(e.parse(JSON.parse(a)))
                }, c, d)
            },
            parse: function(a) {
                var b = new pa,
                    c = a.data.index,
                    d = {
                        Int8Array: Int8Array,
                        Uint8Array: Uint8Array,
                        Uint8ClampedArray: Uint8ClampedArray,
                        Int16Array: Int16Array,
                        Uint16Array: Uint16Array,
                        Int32Array: Int32Array,
                        Uint32Array: Uint32Array,
                        Float32Array: Float32Array,
                        Float64Array: Float64Array
                    };
                void 0 !== c && (c = new d[c.type](c.array), b.setIndex(new ja(c, 1)));
                var e, f = a.data.attributes;
                for (e in f) {
                    var g = f[e],
                        c = new d[g.type](g.array);
                    b.addAttribute(e, new ja(c, g.itemSize, g.normalized))
                }
                if (d = a.data.groups || a.data.drawcalls || a.data.offsets, void 0 !== d)
                    for (e = 0, c = d.length; e !== c; ++e) f = d[e], b.addGroup(f.start, f.count, f.materialIndex);
                return a = a.data.boundingSphere, void 0 !== a && (d = new i, void 0 !== a.center && d.fromArray(a.center), b.boundingSphere = new Y(d, a.radius)), b
            }
        }), Gc.prototype = {
            constructor: Gc,
            crossOrigin: void 0,
            extractUrlBase: function(a) {
                return a = a.split("/"), 1 === a.length ? "./" : (a.pop(), a.join("/") + "/")
            },
            initMaterials: function(a, b, c) {
                for (var d = [], e = 0; e < a.length; ++e) d[e] = this.createMaterial(a[e], b, c);
                return d
            },
            createMaterial: function() {
                var b, c, d;
                return function(e, f, g) {
                    function h(b, d, e, h, i) {
                        b = f + b;
                        var k = Gc.Handlers.get(b);
                        return null !== k ? b = k.load(b) : (c.setCrossOrigin(g), b = c.load(b)), void 0 !== d && (b.repeat.fromArray(d), 1 !== d[0] && (b.wrapS = 1e3), 1 !== d[1] && (b.wrapT = 1e3)), void 0 !== e && b.offset.fromArray(e), void 0 !== h && ("repeat" === h[0] && (b.wrapS = 1e3), "mirror" === h[0] && (b.wrapS = 1002), "repeat" === h[1] && (b.wrapT = 1e3), "mirror" === h[1] && (b.wrapT = 1002)), void 0 !== i && (b.anisotropy = i), d = a.Math.generateUUID(), j[d] = b, d
                    }
                    void 0 === b && (b = new Q), void 0 === c && (c = new gc), void 0 === d && (d = new Ec);
                    var i, j = {},
                        k = {
                            uuid: a.Math.generateUUID(),
                            type: "MeshLambertMaterial"
                        };
                    for (i in e) {
                        var l = e[i];
                        switch (i) {
                            case "DbgColor":
                            case "DbgIndex":
                            case "opticalDensity":
                            case "illumination":
                                break;
                            case "DbgName":
                                k.name = l;
                                break;
                            case "blending":
                                k.blending = Id[l];
                                break;
                            case "colorAmbient":
                            case "mapAmbient":
                                console.warn("THREE.Loader.createMaterial:", i, "is no longer supported.");
                                break;
                            case "colorDiffuse":
                                k.color = b.fromArray(l).getHex();
                                break;
                            case "colorSpecular":
                                k.specular = b.fromArray(l).getHex();
                                break;
                            case "colorEmissive":
                                k.emissive = b.fromArray(l).getHex();
                                break;
                            case "specularCoef":
                                k.shininess = l;
                                break;
                            case "shading":
                                "basic" === l.toLowerCase() && (k.type = "MeshBasicMaterial"), "phong" === l.toLowerCase() && (k.type = "MeshPhongMaterial"), "standard" === l.toLowerCase() && (k.type = "MeshStandardMaterial");
                                break;
                            case "mapDiffuse":
                                k.map = h(l, e.mapDiffuseRepeat, e.mapDiffuseOffset, e.mapDiffuseWrap, e.mapDiffuseAnisotropy);
                                break;
                            case "mapDiffuseRepeat":
                            case "mapDiffuseOffset":
                            case "mapDiffuseWrap":
                            case "mapDiffuseAnisotropy":
                                break;
                            case "mapEmissive":
                                k.emissiveMap = h(l, e.mapEmissiveRepeat, e.mapEmissiveOffset, e.mapEmissiveWrap, e.mapEmissiveAnisotropy);
                                break;
                            case "mapEmissiveRepeat":
                            case "mapEmissiveOffset":
                            case "mapEmissiveWrap":
                            case "mapEmissiveAnisotropy":
                                break;
                            case "mapLight":
                                k.lightMap = h(l, e.mapLightRepeat, e.mapLightOffset, e.mapLightWrap, e.mapLightAnisotropy);
                                break;
                            case "mapLightRepeat":
                            case "mapLightOffset":
                            case "mapLightWrap":
                            case "mapLightAnisotropy":
                                break;
                            case "mapAO":
                                k.aoMap = h(l, e.mapAORepeat, e.mapAOOffset, e.mapAOWrap, e.mapAOAnisotropy);
                                break;
                            case "mapAORepeat":
                            case "mapAOOffset":
                            case "mapAOWrap":
                            case "mapAOAnisotropy":
                                break;
                            case "mapBump":
                                k.bumpMap = h(l, e.mapBumpRepeat, e.mapBumpOffset, e.mapBumpWrap, e.mapBumpAnisotropy);
                                break;
                            case "mapBumpScale":
                                k.bumpScale = l;
                                break;
                            case "mapBumpRepeat":
                            case "mapBumpOffset":
                            case "mapBumpWrap":
                            case "mapBumpAnisotropy":
                                break;
                            case "mapNormal":
                                k.normalMap = h(l, e.mapNormalRepeat, e.mapNormalOffset, e.mapNormalWrap, e.mapNormalAnisotropy);
                                break;
                            case "mapNormalFactor":
                                k.normalScale = [l, l];
                                break;
                            case "mapNormalRepeat":
                            case "mapNormalOffset":
                            case "mapNormalWrap":
                            case "mapNormalAnisotropy":
                                break;
                            case "mapSpecular":
                                k.specularMap = h(l, e.mapSpecularRepeat, e.mapSpecularOffset, e.mapSpecularWrap, e.mapSpecularAnisotropy);
                                break;
                            case "mapSpecularRepeat":
                            case "mapSpecularOffset":
                            case "mapSpecularWrap":
                            case "mapSpecularAnisotropy":
                                break;
                            case "mapMetalness":
                                k.metalnessMap = h(l, e.mapMetalnessRepeat, e.mapMetalnessOffset, e.mapMetalnessWrap, e.mapMetalnessAnisotropy);
                                break;
                            case "mapMetalnessRepeat":
                            case "mapMetalnessOffset":
                            case "mapMetalnessWrap":
                            case "mapMetalnessAnisotropy":
                                break;
                            case "mapRoughness":
                                k.roughnessMap = h(l, e.mapRoughnessRepeat, e.mapRoughnessOffset, e.mapRoughnessWrap, e.mapRoughnessAnisotropy);
                                break;
                            case "mapRoughnessRepeat":
                            case "mapRoughnessOffset":
                            case "mapRoughnessWrap":
                            case "mapRoughnessAnisotropy":
                                break;
                            case "mapAlpha":
                                k.alphaMap = h(l, e.mapAlphaRepeat, e.mapAlphaOffset, e.mapAlphaWrap, e.mapAlphaAnisotropy);
                                break;
                            case "mapAlphaRepeat":
                            case "mapAlphaOffset":
                            case "mapAlphaWrap":
                            case "mapAlphaAnisotropy":
                                break;
                            case "flipSided":
                                k.side = 1;
                                break;
                            case "doubleSided":
                                k.side = 2;
                                break;
                            case "transparency":
                                console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), k.opacity = l;
                                break;
                            case "depthTest":
                            case "depthWrite":
                            case "colorWrite":
                            case "opacity":
                            case "reflectivity":
                            case "transparent":
                            case "visible":
                            case "wireframe":
                                k[i] = l;
                                break;
                            case "vertexColors":
                                !0 === l && (k.vertexColors = 2), "face" === l && (k.vertexColors = 1);
                                break;
                            default:
                                console.error("THREE.Loader.createMaterial: Unsupported", i, l)
                        }
                    }
                    return "MeshBasicMaterial" === k.type && delete k.emissive, "MeshPhongMaterial" !== k.type && delete k.specular, 1 > k.opacity && (k.transparent = !0), d.setTextures(j), d.parse(k)
                }
            }()
        }, Gc.Handlers = {
            handlers: [],
            add: function(a, b) {
                this.handlers.push(a, b)
            },
            get: function(a) {
                for (var b = this.handlers, c = 0, d = b.length; c < d; c += 2) {
                    var e = b[c + 1];
                    if (b[c].test(a)) return e
                }
                return null
            }
        }, Object.assign(Hc.prototype, {
            load: function(a, b, c, d) {
                var e = this,
                    f = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : Gc.prototype.extractUrlBase(a),
                    g = new bc(this.manager);
                g.setWithCredentials(this.withCredentials), g.load(a, function(c) {
                    c = JSON.parse(c);
                    var d = c.metadata;
                    if (void 0 !== d && (d = d.type, void 0 !== d)) {
                        if ("object" === d.toLowerCase()) return void console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.ObjectLoader instead.");
                        if ("scene" === d.toLowerCase()) return void console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.SceneLoader instead.")
                    }
                    c = e.parse(c, f), b(c.geometry, c.materials)
                }, c, d)
            },
            setTexturePath: function(a) {
                this.texturePath = a
            },
            parse: function(a, b) {
                var d = new na,
                    f = void 0 !== a.scale ? 1 / a.scale : 1;
                return function(b) {
                        var e, f, g, h, j, k, l, m, n, o, p, q, r, s = a.faces;
                        k = a.vertices;
                        var t = a.normals,
                            u = a.colors,
                            v = 0;
                        if (void 0 !== a.uvs) {
                            for (e = 0; e < a.uvs.length; e++) a.uvs[e].length && v++;
                            for (e = 0; e < v; e++) d.faceVertexUvs[e] = []
                        }
                        for (h = 0, j = k.length; h < j;) e = new i, e.x = k[h++] * b, e.y = k[h++] * b, e.z = k[h++] * b, d.vertices.push(e);
                        for (h = 0, j = s.length; h < j;)
                            if (b = s[h++], n = 1 & b, g = 2 & b, e = 8 & b, l = 16 & b, o = 32 & b, k = 64 & b, b &= 128, n) {
                                if (n = new ha, n.a = s[h], n.b = s[h + 1], n.c = s[h + 3], p = new ha, p.a = s[h + 1], p.b = s[h + 2], p.c = s[h + 3], h += 4, g && (g = s[h++], n.materialIndex = g, p.materialIndex = g), g = d.faces.length, e)
                                    for (e = 0; e < v; e++)
                                        for (q = a.uvs[e], d.faceVertexUvs[e][g] = [], d.faceVertexUvs[e][g + 1] = [], f = 0; 4 > f; f++) m = s[h++], r = q[2 * m], m = q[2 * m + 1], r = new c(r, m), 2 !== f && d.faceVertexUvs[e][g].push(r), 0 !== f && d.faceVertexUvs[e][g + 1].push(r);
                                if (l && (l = 3 * s[h++], n.normal.set(t[l++], t[l++], t[l]), p.normal.copy(n.normal)), o)
                                    for (e = 0; 4 > e; e++) l = 3 * s[h++], o = new i(t[l++], t[l++], t[l]), 2 !== e && n.vertexNormals.push(o), 0 !== e && p.vertexNormals.push(o);
                                if (k && (k = s[h++], k = u[k], n.color.setHex(k), p.color.setHex(k)), b)
                                    for (e = 0; 4 > e; e++) k = s[h++], k = u[k], 2 !== e && n.vertexColors.push(new Q(k)), 0 !== e && p.vertexColors.push(new Q(k));
                                d.faces.push(n), d.faces.push(p)
                            } else {
                                if (n = new ha, n.a = s[h++], n.b = s[h++], n.c = s[h++], g && (g = s[h++], n.materialIndex = g), g = d.faces.length, e)
                                    for (e = 0; e < v; e++)
                                        for (q = a.uvs[e], d.faceVertexUvs[e][g] = [], f = 0; 3 > f; f++) m = s[h++], r = q[2 * m], m = q[2 * m + 1], r = new c(r, m), d.faceVertexUvs[e][g].push(r);
                                if (l && (l = 3 * s[h++], n.normal.set(t[l++], t[l++], t[l])), o)
                                    for (e = 0; 3 > e; e++) l = 3 * s[h++], o = new i(t[l++], t[l++], t[l]), n.vertexNormals.push(o);
                                if (k && (k = s[h++], n.color.setHex(u[k])), b)
                                    for (e = 0; 3 > e; e++) k = s[h++], n.vertexColors.push(new Q(u[k]));
                                d.faces.push(n)
                            }
                    }(f),
                    function() {
                        var b = void 0 !== a.influencesPerVertex ? a.influencesPerVertex : 2;
                        if (a.skinWeights)
                            for (var c = 0, f = a.skinWeights.length; c < f; c += b) d.skinWeights.push(new e(a.skinWeights[c], 1 < b ? a.skinWeights[c + 1] : 0, 2 < b ? a.skinWeights[c + 2] : 0, 3 < b ? a.skinWeights[c + 3] : 0));
                        if (a.skinIndices)
                            for (c = 0, f = a.skinIndices.length; c < f; c += b) d.skinIndices.push(new e(a.skinIndices[c], 1 < b ? a.skinIndices[c + 1] : 0, 2 < b ? a.skinIndices[c + 2] : 0, 3 < b ? a.skinIndices[c + 3] : 0));
                        d.bones = a.bones, d.bones && 0 < d.bones.length && (d.skinWeights.length !== d.skinIndices.length || d.skinIndices.length !== d.vertices.length) && console.warn("When skinning, number of vertices (" + d.vertices.length + "), skinIndices (" + d.skinIndices.length + "), and skinWeights (" + d.skinWeights.length + ") should match.")
                    }(),
                    function(b) {
                        if (void 0 !== a.morphTargets)
                            for (var c = 0, e = a.morphTargets.length; c < e; c++) {
                                d.morphTargets[c] = {}, d.morphTargets[c].name = a.morphTargets[c].name, d.morphTargets[c].vertices = [];
                                for (var f = d.morphTargets[c].vertices, g = a.morphTargets[c].vertices, h = 0, j = g.length; h < j; h += 3) {
                                    var k = new i;
                                    k.x = g[h] * b, k.y = g[h + 1] * b, k.z = g[h + 2] * b, f.push(k)
                                }
                            }
                        if (void 0 !== a.morphColors && 0 < a.morphColors.length)
                            for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), b = d.faces, f = a.morphColors[0].colors, c = 0, e = b.length; c < e; c++) b[c].color.fromArray(f, 3 * c)
                    }(f),
                    function() {
                        var b = [],
                            c = [];
                        void 0 !== a.animation && c.push(a.animation), void 0 !== a.animations && (a.animations.length ? c = c.concat(a.animations) : c.push(a.animations));
                        for (var e = 0; e < c.length; e++) {
                            var f = Dc.parseAnimation(c[e], d.bones);
                            f && b.push(f)
                        }
                        d.morphTargets && (c = Dc.CreateClipsFromMorphTargetSequences(d.morphTargets, 10), b = b.concat(c)), 0 < b.length && (d.animations = b)
                    }(), d.computeFaceNormals(), d.computeBoundingSphere(), void 0 === a.materials || 0 === a.materials.length ? {
                        geometry: d
                    } : (f = Gc.prototype.initMaterials(a.materials, b, this.crossOrigin), {
                        geometry: d,
                        materials: f
                    })
            }
        }), Object.assign(Ic.prototype, {
            load: function(a, b, c, d) {
                "" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
                var e = this;
                new bc(e.manager).load(a, function(a) {
                    e.parse(JSON.parse(a), b)
                }, c, d)
            },
            setTexturePath: function(a) {
                this.texturePath = a
            },
            setCrossOrigin: function(a) {
                this.crossOrigin = a
            },
            parse: function(a, b) {
                var c = this.parseGeometries(a.geometries),
                    d = this.parseImages(a.images, function() {
                        void 0 !== b && b(e)
                    }),
                    d = this.parseTextures(a.textures, d),
                    d = this.parseMaterials(a.materials, d),
                    e = this.parseObject(a.object, c, d);
                return a.animations && (e.animations = this.parseAnimations(a.animations)), void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e), e
            },
            parseGeometries: function(a) {
                var b = {};
                if (void 0 !== a)
                    for (var c = new Hc, d = new Fc, e = 0, f = a.length; e < f; e++) {
                        var g, h = a[e];
                        switch (h.type) {
                            case "PlaneGeometry":
                            case "PlaneBufferGeometry":
                                g = new Zd[h.type](h.width, h.height, h.widthSegments, h.heightSegments);
                                break;
                            case "BoxGeometry":
                            case "BoxBufferGeometry":
                            case "CubeGeometry":
                                g = new Zd[h.type](h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
                                break;
                            case "CircleGeometry":
                            case "CircleBufferGeometry":
                                g = new Zd[h.type](h.radius, h.segments, h.thetaStart, h.thetaLength);
                                break;
                            case "CylinderGeometry":
                            case "CylinderBufferGeometry":
                                g = new Zd[h.type](h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
                                break;
                            case "ConeGeometry":
                            case "ConeBufferGeometry":
                                g = new Zd[h.type](h.radius, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
                                break;
                            case "SphereGeometry":
                            case "SphereBufferGeometry":
                                g = new Zd[h.type](h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
                                break;
                            case "DodecahedronGeometry":
                            case "IcosahedronGeometry":
                            case "OctahedronGeometry":
                            case "TetrahedronGeometry":
                                g = new Zd[h.type](h.radius, h.detail);
                                break;
                            case "RingGeometry":
                            case "RingBufferGeometry":
                                g = new Zd[h.type](h.innerRadius, h.outerRadius, h.thetaSegments, h.phiSegments, h.thetaStart, h.thetaLength);
                                break;
                            case "TorusGeometry":
                            case "TorusBufferGeometry":
                                g = new Zd[h.type](h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
                                break;
                            case "TorusKnotGeometry":
                            case "TorusKnotBufferGeometry":
                                g = new Zd[h.type](h.radius, h.tube, h.tubularSegments, h.radialSegments, h.p, h.q);
                                break;
                            case "LatheGeometry":
                            case "LatheBufferGeometry":
                                g = new Zd[h.type](h.points, h.segments, h.phiStart, h.phiLength);
                                break;
                            case "BufferGeometry":
                                g = d.parse(h);
                                break;
                            case "Geometry":
                                g = c.parse(h.data, this.texturePath).geometry;
                                break;
                            default:
                                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"');
                                continue
                        }
                        g.uuid = h.uuid, void 0 !== h.name && (g.name = h.name), b[h.uuid] = g
                    }
                return b
            },
            parseMaterials: function(a, b) {
                var c = {};
                if (void 0 !== a) {
                    var d = new Ec;
                    d.setTextures(b);
                    for (var e = 0, f = a.length; e < f; e++) {
                        var g = d.parse(a[e]);
                        c[g.uuid] = g
                    }
                }
                return c
            },
            parseAnimations: function(a) {
                for (var b = [], c = 0; c < a.length; c++) {
                    var d = Dc.parse(a[c]);
                    b.push(d)
                }
                return b
            },
            parseImages: function(a, b) {
                function c(a) {
                    return d.manager.itemStart(a), g.load(a, function() {
                        d.manager.itemEnd(a)
                    }, void 0, function() {
                        d.manager.itemError(a)
                    })
                }
                var d = this,
                    e = {};
                if (void 0 !== a && 0 < a.length) {
                    var f = new ac(b),
                        g = new ec(f);
                    g.setCrossOrigin(this.crossOrigin);
                    for (var f = 0, h = a.length; f < h; f++) {
                        var i = a[f],
                            j = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(i.url) ? i.url : d.texturePath + i.url;
                        e[i.uuid] = c(j)
                    }
                }
                return e
            },
            parseTextures: function(a, b) {
                function c(a, b) {
                    return "number" == typeof a ? a : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a), b[a])
                }
                var e = {};
                if (void 0 !== a)
                    for (var f = 0, g = a.length; f < g; f++) {
                        var h = a[f];
                        void 0 === h.image && console.warn('THREE.ObjectLoader: No "image" specified for', h.uuid), void 0 === b[h.image] && console.warn("THREE.ObjectLoader: Undefined image", h.image);
                        var i = new d(b[h.image]);
                        i.needsUpdate = !0, i.uuid = h.uuid, void 0 !== h.name && (i.name = h.name), void 0 !== h.mapping && (i.mapping = c(h.mapping, Jd)), void 0 !== h.offset && i.offset.fromArray(h.offset), void 0 !== h.repeat && i.repeat.fromArray(h.repeat), void 0 !== h.wrap && (i.wrapS = c(h.wrap[0], Kd), i.wrapT = c(h.wrap[1], Kd)), void 0 !== h.minFilter && (i.minFilter = c(h.minFilter, Ld)), void 0 !== h.magFilter && (i.magFilter = c(h.magFilter, Ld)), void 0 !== h.anisotropy && (i.anisotropy = h.anisotropy), void 0 !== h.flipY && (i.flipY = h.flipY), e[h.uuid] = i
                    }
                return e
            },
            parseObject: function() {
                var a = new j;
                return function(b, c, d) {
                    function e(a) {
                        return void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a), c[a]
                    }

                    function f(a) {
                        if (void 0 !== a) return void 0 === d[a] && console.warn("THREE.ObjectLoader: Undefined material", a), d[a]
                    }
                    var g;
                    switch (b.type) {
                        case "Scene":
                            g = new Ya, void 0 !== b.background && Number.isInteger(b.background) && (g.background = new Q(b.background)), void 0 !== b.fog && ("Fog" === b.fog.type ? g.fog = new Xa(b.fog.color, b.fog.near, b.fog.far) : "FogExp2" === b.fog.type && (g.fog = new Wa(b.fog.color, b.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            g = new ua(b.fov, b.aspect, b.near, b.far), void 0 !== b.focus && (g.focus = b.focus), void 0 !== b.zoom && (g.zoom = b.zoom), void 0 !== b.filmGauge && (g.filmGauge = b.filmGauge), void 0 !== b.filmOffset && (g.filmOffset = b.filmOffset), void 0 !== b.view && (g.view = Object.assign({}, b.view));
                            break;
                        case "OrthographicCamera":
                            g = new va(b.left, b.right, b.top, b.bottom, b.near, b.far);
                            break;
                        case "AmbientLight":
                            g = new pc(b.color, b.intensity);
                            break;
                        case "DirectionalLight":
                            g = new oc(b.color, b.intensity);
                            break;
                        case "PointLight":
                            g = new mc(b.color, b.intensity, b.distance, b.decay);
                            break;
                        case "SpotLight":
                            g = new lc(b.color, b.intensity, b.distance, b.angle, b.penumbra, b.decay);
                            break;
                        case "HemisphereLight":
                            g = new ic(b.color, b.groundColor, b.intensity);
                            break;
                        case "Mesh":
                            g = e(b.geometry);
                            var h = f(b.material);
                            g = g.bones && 0 < g.bones.length ? new eb(g, h) : new qa(g, h);
                            break;
                        case "LOD":
                            g = new ab;
                            break;
                        case "Line":
                            g = new gb(e(b.geometry), f(b.material), b.mode);
                            break;
                        case "LineSegments":
                            g = new hb(e(b.geometry), f(b.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            g = new jb(e(b.geometry), f(b.material));
                            break;
                        case "Sprite":
                            g = new _a(f(b.material));
                            break;
                        case "Group":
                            g = new kb;
                            break;
                        default:
                            g = new ea
                    }
                    if (g.uuid = b.uuid, void 0 !== b.name && (g.name = b.name), void 0 !== b.matrix ? (a.fromArray(b.matrix), a.decompose(g.position, g.quaternion, g.scale)) : (void 0 !== b.position && g.position.fromArray(b.position), void 0 !== b.rotation && g.rotation.fromArray(b.rotation), void 0 !== b.quaternion && g.quaternion.fromArray(b.quaternion), void 0 !== b.scale && g.scale.fromArray(b.scale)), void 0 !== b.castShadow && (g.castShadow = b.castShadow), void 0 !== b.receiveShadow && (g.receiveShadow = b.receiveShadow), b.shadow && (void 0 !== b.shadow.bias && (g.shadow.bias = b.shadow.bias), void 0 !== b.shadow.radius && (g.shadow.radius = b.shadow.radius), void 0 !== b.shadow.mapSize && g.shadow.mapSize.fromArray(b.shadow.mapSize), void 0 !== b.shadow.camera && (g.shadow.camera = this.parseObject(b.shadow.camera))), void 0 !== b.visible && (g.visible = b.visible), void 0 !== b.userData && (g.userData = b.userData), void 0 !== b.children)
                        for (var i in b.children) g.add(this.parseObject(b.children[i], c, d));
                    if ("LOD" === b.type)
                        for (b = b.levels, h = 0; h < b.length; h++) {
                            var j = b[h];
                            i = g.getObjectByProperty("uuid", j.object), void 0 !== i && g.addLevel(i, j.distance)
                        }
                    return g
                }
            }()
        }), Jc.prototype = {
            constructor: Jc,
            getPoint: function(a) {
                return console.warn("THREE.Curve: Warning, getPoint() not implemented!"), null
            },
            getPointAt: function(a) {
                return a = this.getUtoTmapping(a), this.getPoint(a)
            },
            getPoints: function(a) {
                a || (a = 5);
                for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
                return b
            },
            getSpacedPoints: function(a) {
                a || (a = 5);
                for (var b = [], c = 0; c <= a; c++) b.push(this.getPointAt(c / a));
                return b
            },
            getLength: function() {
                var a = this.getLengths();
                return a[a.length - 1]
            },
            getLengths: function(a) {
                if (a || (a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) return this.cacheArcLengths;
                this.needsUpdate = !1;
                var b, c, d = [],
                    e = this.getPoint(0),
                    f = 0;
                for (d.push(0), c = 1; c <= a; c++) b = this.getPoint(c / a), f += b.distanceTo(e), d.push(f), e = b;
                return this.cacheArcLengths = d
            },
            updateArcLengths: function() {
                this.needsUpdate = !0, this.getLengths()
            },
            getUtoTmapping: function(a, b) {
                var c, d, e = this.getLengths(),
                    f = e.length;
                d = b ? b : a * e[f - 1];
                for (var g, h = 0, i = f - 1; h <= i;)
                    if (c = Math.floor(h + (i - h) / 2), g = e[c] - d, 0 > g) h = c + 1;
                    else {
                        if (!(0 < g)) {
                            i = c;
                            break
                        }
                        i = c - 1
                    }
                return c = i, e[c] === d ? c / (f - 1) : (h = e[c], (c + (d - h) / (e[c + 1] - h)) / (f - 1))
            },
            getTangent: function(a) {
                var b = a - 1e-4;
                return a += 1e-4, 0 > b && (b = 0), 1 < a && (a = 1), b = this.getPoint(b), this.getPoint(a).clone().sub(b).normalize()
            },
            getTangentAt: function(a) {
                return a = this.getUtoTmapping(a), this.getTangent(a)
            }
        }, Jc.create = function(a, b) {
            return a.prototype = Object.create(Jc.prototype), a.prototype.constructor = a, a.prototype.getPoint = b, a
        }, Kc.prototype = Object.create(Jc.prototype), Kc.prototype.constructor = Kc, Kc.prototype.isLineCurve = !0, Kc.prototype.getPoint = function(a) {
            if (1 === a) return this.v2.clone();
            var b = this.v2.clone().sub(this.v1);
            return b.multiplyScalar(a).add(this.v1), b
        }, Kc.prototype.getPointAt = function(a) {
            return this.getPoint(a)
        }, Kc.prototype.getTangent = function(a) {
            return this.v2.clone().sub(this.v1).normalize()
        }, Lc.prototype = Object.assign(Object.create(Jc.prototype), {
            constructor: Lc,
            add: function(a) {
                this.curves.push(a)
            },
            closePath: function() {
                var a = this.curves[0].getPoint(0),
                    b = this.curves[this.curves.length - 1].getPoint(1);
                a.equals(b) || this.curves.push(new Kc(b, a))
            },
            getPoint: function(a) {
                var b = a * this.getLength(),
                    c = this.getCurveLengths();
                for (a = 0; a < c.length;) {
                    if (c[a] >= b) return b = c[a] - b, a = this.curves[a], c = a.getLength(), a.getPointAt(0 === c ? 0 : 1 - b / c);
                    a++
                }
                return null
            },
            getLength: function() {
                var a = this.getCurveLengths();
                return a[a.length - 1]
            },
            updateArcLengths: function() {
                this.needsUpdate = !0, this.cacheLengths = null, this.getLengths()
            },
            getCurveLengths: function() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++) b += this.curves[c].getLength(), a.push(b);
                return this.cacheLengths = a
            },
            getSpacedPoints: function(a) {
                a || (a = 40);
                for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
                return this.autoClose && b.push(b[0]), b
            },
            getPoints: function(a) {
                a = a || 12;
                for (var b, c = [], d = 0, e = this.curves; d < e.length; d++)
                    for (var f = e[d], f = f.getPoints(f && f.isEllipseCurve ? 2 * a : f && f.isLineCurve ? 1 : f && f.isSplineCurve ? a * f.points.length : a), g = 0; g < f.length; g++) {
                        var h = f[g];
                        b && b.equals(h) || (c.push(h), b = h)
                    }
                return this.autoClose && 1 < c.length && !c[c.length - 1].equals(c[0]) && c.push(c[0]), c
            },
            createPointsGeometry: function(a) {
                return a = this.getPoints(a), this.createGeometry(a)
            },
            createSpacedPointsGeometry: function(a) {
                return a = this.getSpacedPoints(a), this.createGeometry(a)
            },
            createGeometry: function(a) {
                for (var b = new na, c = 0, d = a.length; c < d; c++) {
                    var e = a[c];
                    b.vertices.push(new i(e.x, e.y, e.z || 0))
                }
                return b
            }
        }), Mc.prototype = Object.create(Jc.prototype), Mc.prototype.constructor = Mc, Mc.prototype.isEllipseCurve = !0, Mc.prototype.getPoint = function(a) {
            for (var b = 2 * Math.PI, d = this.aEndAngle - this.aStartAngle, e = Math.abs(d) < Number.EPSILON; 0 > d;) d += b;
            for (; d > b;) d -= b;
            d < Number.EPSILON && (d = e ? 0 : b), !0 !== this.aClockwise || e || (d = d === b ? -b : d - b), b = this.aStartAngle + a * d, a = this.aX + this.xRadius * Math.cos(b);
            var f = this.aY + this.yRadius * Math.sin(b);
            return 0 !== this.aRotation && (b = Math.cos(this.aRotation), d = Math.sin(this.aRotation), e = a - this.aX, f -= this.aY, a = e * b - f * d + this.aX, f = e * d + f * b + this.aY), new c(a, f)
        }, a.CurveUtils = {
            tangentQuadraticBezier: function(a, b, c, d) {
                return 2 * (1 - a) * (c - b) + 2 * a * (d - c)
            },
            tangentCubicBezier: function(a, b, c, d, e) {
                return -3 * b * (1 - a) * (1 - a) + 3 * c * (1 - a) * (1 - a) - 6 * a * c * (1 - a) + 6 * a * d * (1 - a) - 3 * a * a * d + 3 * a * a * e
            },
            tangentSpline: function(a, b, c, d, e) {
                return 6 * a * a - 6 * a + (3 * a * a - 4 * a + 1) + (-6 * a * a + 6 * a) + (3 * a * a - 2 * a)
            },
            interpolate: function(a, b, c, d, e) {
                a = .5 * (c - a), d = .5 * (d - b);
                var f = e * e;
                return (2 * b - 2 * c + a + d) * e * f + (-3 * b + 3 * c - 2 * a - d) * f + a * e + b
            }
        }, Nc.prototype = Object.create(Jc.prototype), Nc.prototype.constructor = Nc, Nc.prototype.isSplineCurve = !0, Nc.prototype.getPoint = function(b) {
            var d = this.points;
            b *= d.length - 1;
            var e = Math.floor(b);
            b -= e;
            var f = d[0 === e ? e : e - 1],
                g = d[e],
                h = d[e > d.length - 2 ? d.length - 1 : e + 1],
                d = d[e > d.length - 3 ? d.length - 1 : e + 2],
                e = a.CurveUtils.interpolate;
            return new c(e(f.x, g.x, h.x, d.x, b), e(f.y, g.y, h.y, d.y, b))
        }, Oc.prototype = Object.create(Jc.prototype), Oc.prototype.constructor = Oc, Oc.prototype.getPoint = function(b) {
            var d = a.ShapeUtils.b3;
            return new c(d(b, this.v0.x, this.v1.x, this.v2.x, this.v3.x), d(b, this.v0.y, this.v1.y, this.v2.y, this.v3.y))
        }, Oc.prototype.getTangent = function(b) {
            var d = a.CurveUtils.tangentCubicBezier;
            return new c(d(b, this.v0.x, this.v1.x, this.v2.x, this.v3.x), d(b, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize()
        }, Pc.prototype = Object.create(Jc.prototype), Pc.prototype.constructor = Pc, Pc.prototype.getPoint = function(b) {
            var d = a.ShapeUtils.b2;
            return new c(d(b, this.v0.x, this.v1.x, this.v2.x), d(b, this.v0.y, this.v1.y, this.v2.y))
        }, Pc.prototype.getTangent = function(b) {
            var d = a.CurveUtils.tangentQuadraticBezier;
            return new c(d(b, this.v0.x, this.v1.x, this.v2.x), d(b, this.v0.y, this.v1.y, this.v2.y)).normalize()
        };
        var ae = Object.assign(Object.create(Lc.prototype), {
            fromPoints: function(a) {
                this.moveTo(a[0].x, a[0].y);
                for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y)
            },
            moveTo: function(a, b) {
                this.currentPoint.set(a, b)
            },
            lineTo: function(a, b) {
                var d = new Kc(this.currentPoint.clone(), new c(a, b));
                this.curves.push(d), this.currentPoint.set(a, b)
            },
            quadraticCurveTo: function(a, b, d, e) {
                a = new Pc(this.currentPoint.clone(), new c(a, b), new c(d, e)), this.curves.push(a), this.currentPoint.set(d, e)
            },
            bezierCurveTo: function(a, b, d, e, f, g) {
                a = new Oc(this.currentPoint.clone(), new c(a, b), new c(d, e), new c(f, g)), this.curves.push(a), this.currentPoint.set(f, g)
            },
            splineThru: function(a) {
                var b = [this.currentPoint.clone()].concat(a),
                    b = new Nc(b);
                this.curves.push(b), this.currentPoint.copy(a[a.length - 1])
            },
            arc: function(a, b, c, d, e, f) {
                this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f)
            },
            absarc: function(a, b, c, d, e, f) {
                this.absellipse(a, b, c, c, d, e, f)
            },
            ellipse: function(a, b, c, d, e, f, g, h) {
                this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f, g, h)
            },
            absellipse: function(a, b, c, d, e, f, g, h) {
                a = new Mc(a, b, c, d, e, f, g, h), 0 < this.curves.length && (b = a.getPoint(0), b.equals(this.currentPoint) || this.lineTo(b.x, b.y)), this.curves.push(a), a = a.getPoint(1), this.currentPoint.copy(a)
            }
        });
        Qc.prototype = Object.assign(Object.create(ae), {
            constructor: Qc,
            getPointsHoles: function(a) {
                for (var b = [], c = 0, d = this.holes.length; c < d; c++) b[c] = this.holes[c].getPoints(a);
                return b
            },
            extractAllPoints: function(a) {
                return {
                    shape: this.getPoints(a),
                    holes: this.getPointsHoles(a)
                }
            },
            extractPoints: function(a) {
                return this.extractAllPoints(a)
            }
        }), Rc.prototype = ae, ae.constructor = Rc, Sc.prototype = {
            moveTo: function(a, b) {
                this.currentPath = new Rc, this.subPaths.push(this.currentPath), this.currentPath.moveTo(a, b)
            },
            lineTo: function(a, b) {
                this.currentPath.lineTo(a, b)
            },
            quadraticCurveTo: function(a, b, c, d) {
                this.currentPath.quadraticCurveTo(a, b, c, d)
            },
            bezierCurveTo: function(a, b, c, d, e, f) {
                this.currentPath.bezierCurveTo(a, b, c, d, e, f)
            },
            splineThru: function(a) {
                this.currentPath.splineThru(a)
            },
            toShapes: function(b, c) {
                function d(a) {
                    for (var b = [], c = 0, d = a.length; c < d; c++) {
                        var e = a[c],
                            f = new Qc;
                        f.curves = e.curves, b.push(f)
                    }
                    return b
                }

                function e(a, b) {
                    for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
                        var g = b[e],
                            h = b[f],
                            i = h.x - g.x,
                            j = h.y - g.y;
                        if (Math.abs(j) > Number.EPSILON) {
                            if (0 > j && (g = b[f], i = -i, h = b[e], j = -j), !(a.y < g.y || a.y > h.y))
                                if (a.y === g.y) {
                                    if (a.x === g.x) return !0
                                } else {
                                    if (e = j * (a.x - g.x) - i * (a.y - g.y), 0 === e) return !0;
                                    0 > e || (d = !d)
                                }
                        } else if (a.y === g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x)) return !0
                    }
                    return d
                }
                var f = a.ShapeUtils.isClockWise,
                    g = this.subPaths;
                if (0 === g.length) return [];
                if (!0 === c) return d(g);
                var h, i, j, k = [];
                if (1 === g.length) return i = g[0], j = new Qc, j.curves = i.curves, k.push(j), k;
                var l = !f(g[0].getPoints()),
                    l = b ? !l : l;
                j = [];
                var m, n = [],
                    o = [],
                    p = 0;
                n[p] = void 0, o[p] = [];
                for (var q = 0, r = g.length; q < r; q++) i = g[q], m = i.getPoints(), h = f(m), (h = b ? !h : h) ? (!l && n[p] && p++, n[p] = {
                    s: new Qc,
                    p: m
                }, n[p].s.curves = i.curves, l && p++, o[p] = []) : o[p].push({
                    h: i,
                    p: m[0]
                });
                if (!n[0]) return d(g);
                if (1 < n.length) {
                    for (q = !1, i = [], f = 0, g = n.length; f < g; f++) j[f] = [];
                    for (f = 0, g = n.length; f < g; f++)
                        for (h = o[f], l = 0; l < h.length; l++) {
                            for (p = h[l], m = !0, r = 0; r < n.length; r++) e(p.p, n[r].p) && (f !== r && i.push({
                                froms: f,
                                tos: r,
                                hole: l
                            }), m ? (m = !1, j[r].push(p)) : q = !0);
                            m && j[f].push(p)
                        }
                    0 < i.length && (q || (o = j))
                }
                for (q = 0, f = n.length; q < f; q++)
                    for (j = n[q].s, k.push(j), i = o[q], g = 0, h = i.length; g < h; g++) j.holes.push(i[g].h);
                return k
            }
        }, Object.assign(Tc.prototype, {
            isFont: !0,
            generateShapes: function(b, c, d) {
                void 0 === c && (c = 100), void 0 === d && (d = 4);
                var e = this.data;
                b = String(b).split("");
                var f = c / e.resolution,
                    g = 0;
                c = [];
                for (var h = 0; h < b.length; h++) {
                    var i;
                    i = f;
                    var j = g,
                        k = e.glyphs[b[h]] || e.glyphs["?"];
                    if (k) {
                        var l, m, n, o, p, q, r, s, t = new Sc,
                            u = [],
                            v = a.ShapeUtils.b2,
                            w = a.ShapeUtils.b3;
                        if (k.o)
                            for (var x = k._cachedOutline || (k._cachedOutline = k.o.split(" ")), y = 0, z = x.length; y < z;) switch (x[y++]) {
                                case "m":
                                    l = x[y++] * i + j, m = x[y++] * i, t.moveTo(l, m);
                                    break;
                                case "l":
                                    l = x[y++] * i + j, m = x[y++] * i, t.lineTo(l, m);
                                    break;
                                case "q":
                                    if (l = x[y++] * i + j, m = x[y++] * i, p = x[y++] * i + j, q = x[y++] * i, t.quadraticCurveTo(p, q, l, m), o = u[u.length - 1]) {
                                        n = o.x, o = o.y;
                                        for (var A = 1; A <= d; A++) {
                                            var B = A / d;
                                            v(B, n, p, l), v(B, o, q, m)
                                        }
                                    }
                                    break;
                                case "b":
                                    if (l = x[y++] * i + j, m = x[y++] * i, p = x[y++] * i + j, q = x[y++] * i, r = x[y++] * i + j, s = x[y++] * i, t.bezierCurveTo(p, q, r, s, l, m), o = u[u.length - 1])
                                        for (n = o.x, o = o.y, A = 1; A <= d; A++) B = A / d, w(B, n, p, r, l), w(B, o, q, s, m)
                            }
                        i = {
                            offset: k.ha * i,
                            path: t
                        }
                    } else i = void 0;
                    g += i.offset, c.push(i.path)
                }
                for (d = [], e = 0, b = c.length; e < b; e++) Array.prototype.push.apply(d, c[e].toShapes());
                return d
            }
        }), Object.assign(Uc.prototype, {
            load: function(a, b, c, d) {
                var e = this;
                new bc(this.manager).load(a, function(a) {
                    var c;
                    try {
                        c = JSON.parse(a)
                    } catch (b) {
                        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), c = JSON.parse(a.substring(65, a.length - 2))
                    }
                    a = e.parse(c), b && b(a)
                }, c, d)
            },
            parse: function(a) {
                return new Tc(a)
            }
        });
        var be;
        Object.assign(Wc.prototype, {
            load: function(a, b, c, d) {
                var e = new bc(this.manager);
                e.setResponseType("arraybuffer"), e.load(a, function(a) {
                    Vc().decodeAudioData(a, function(a) {
                        b(a)
                    })
                }, c, d)
            }
        }), Object.assign(Xc.prototype, {
            update: function() {
                var b, c, d, e, f, g, h, i = new j,
                    k = new j;
                return function(j) {
                    if (b !== this || c !== j.focus || d !== j.fov || e !== j.aspect * this.aspect || f !== j.near || g !== j.far || h !== j.zoom) {
                        b = this, c = j.focus, d = j.fov, e = j.aspect * this.aspect, f = j.near, g = j.far, h = j.zoom;
                        var l, m = j.projectionMatrix.clone(),
                            n = this.eyeSep / 2,
                            o = n * f / c,
                            p = f * Math.tan(a.Math.DEG2RAD * d * .5) / h;
                        k.elements[12] = -n, i.elements[12] = n, n = -p * e + o, l = p * e + o, m.elements[0] = 2 * f / (l - n), m.elements[8] = (l + n) / (l - n), this.cameraL.projectionMatrix.copy(m), n = -p * e - o, l = p * e - o, m.elements[0] = 2 * f / (l - n), m.elements[8] = (l + n) / (l - n), this.cameraR.projectionMatrix.copy(m)
                    }
                    this.cameraL.matrixWorld.copy(j.matrixWorld).multiply(k), this.cameraR.matrixWorld.copy(j.matrixWorld).multiply(i)
                }
            }()
        }), Yc.prototype = Object.create(ea.prototype), Yc.prototype.constructor = Yc, Zc.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: Zc,
            getInput: function() {
                return this.gain
            },
            removeFilter: function() {
                null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
            },
            getFilter: function() {
                return this.filter
            },
            setFilter: function(a) {
                null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = a, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
            },
            getMasterVolume: function() {
                return this.gain.gain.value
            },
            setMasterVolume: function(a) {
                this.gain.gain.value = a
            },
            updateMatrixWorld: function() {
                var a = new i,
                    b = new h,
                    c = new i,
                    d = new i;
                return function(e) {
                    ea.prototype.updateMatrixWorld.call(this, e), e = this.context.listener;
                    var f = this.up;
                    this.matrixWorld.decompose(a, b, c), d.set(0, 0, -1).applyQuaternion(b), e.setPosition(a.x, a.y, a.z), e.setOrientation(d.x, d.y, d.z, f.x, f.y, f.z)
                }
            }()
        }), $c.prototype = Object.assign(Object.create(ea.prototype), {
            constructor: $c,
            getOutput: function() {
                return this.gain
            },
            setNodeSource: function(a) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = a, this.connect(), this
            },
            setBuffer: function(a) {
                return this.source.buffer = a, this.sourceType = "buffer", this.autoplay && this.play(), this
            },
            play: function() {
                if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
                else {
                    if (!1 !== this.hasPlaybackControl) {
                        var a = this.context.createBufferSource();
                        return a.buffer = this.source.buffer, a.loop = this.source.loop, a.onended = this.source.onended, a.start(0, this.startTime), a.playbackRate.value = this.playbackRate, this.isPlaying = !0, this.source = a, this.connect()
                    }
                    console.warn("THREE.Audio: this Audio has no playback control.")
                }
            },
            pause: function() {
                return !1 !== this.hasPlaybackControl ? (this.source.stop(), this.startTime = this.context.currentTime, this.isPlaying = !1, this) : void console.warn("THREE.Audio: this Audio has no playback control.")
            },
            stop: function() {
                return !1 !== this.hasPlaybackControl ? (this.source.stop(), this.startTime = 0, this.isPlaying = !1, this) : void console.warn("THREE.Audio: this Audio has no playback control.")
            },
            connect: function() {
                if (0 < this.filters.length) {
                    this.source.connect(this.filters[0]);
                    for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].connect(this.filters[a]);
                    this.filters[this.filters.length - 1].connect(this.getOutput())
                } else this.source.connect(this.getOutput());
                return this
            },
            disconnect: function() {
                if (0 < this.filters.length) {
                    this.source.disconnect(this.filters[0]);
                    for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].disconnect(this.filters[a]);
                    this.filters[this.filters.length - 1].disconnect(this.getOutput())
                } else this.source.disconnect(this.getOutput());
                return this
            },
            getFilters: function() {
                return this.filters
            },
            setFilters: function(a) {
                return a || (a = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a, this
            },
            getFilter: function() {
                return this.getFilters()[0]
            },
            setFilter: function(a) {
                return this.setFilters(a ? [a] : [])
            },
            setPlaybackRate: function(a) {
                return !1 !== this.hasPlaybackControl ? (this.playbackRate = a, !0 === this.isPlaying && (this.source.playbackRate.value = this.playbackRate), this) : void console.warn("THREE.Audio: this Audio has no playback control.")
            },
            getPlaybackRate: function() {
                return this.playbackRate
            },
            onEnded: function() {
                this.isPlaying = !1
            },
            getLoop: function() {
                return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.source.loop
            },
            setLoop: function(a) {
                !1 === this.hasPlaybackControl ? console.warn("THREE.Audio: this Audio has no playback control.") : this.source.loop = a
            },
            getVolume: function() {
                return this.gain.gain.value
            },
            setVolume: function(a) {
                return this.gain.gain.value = a, this
            }
        }), _c.prototype = Object.assign(Object.create($c.prototype), {
            constructor: _c,
            getOutput: function() {
                return this.panner
            },
            getRefDistance: function() {
                return this.panner.refDistance
            },
            setRefDistance: function(a) {
                this.panner.refDistance = a
            },
            getRolloffFactor: function() {
                return this.panner.rolloffFactor
            },
            setRolloffFactor: function(a) {
                this.panner.rolloffFactor = a
            },
            getDistanceModel: function() {
                return this.panner.distanceModel
            },
            setDistanceModel: function(a) {
                this.panner.distanceModel = a
            },
            getMaxDistance: function() {
                return this.panner.maxDistance
            },
            setMaxDistance: function(a) {
                this.panner.maxDistance = a
            },
            updateMatrixWorld: function() {
                var a = new i;
                return function(b) {
                    ea.prototype.updateMatrixWorld.call(this, b), a.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(a.x, a.y, a.z)
                }
            }()
        }), Object.assign(ad.prototype, {
            getFrequencyData: function() {
                return this.analyser.getByteFrequencyData(this.data), this.data
            },
            getAverageFrequency: function() {
                for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++) a += b[c];
                return a / b.length
            }
        }), bd.prototype = {
            constructor: bd,
            accumulate: function(a, b) {
                var c = this.buffer,
                    d = this.valueSize,
                    e = a * d + d,
                    f = this.cumulativeWeight;
                if (0 === f) {
                    for (f = 0; f !== d; ++f) c[e + f] = c[f];
                    f = b
                } else f += b, this._mixBufferRegion(c, e, 0, b / f, d);
                this.cumulativeWeight = f
            },
            apply: function(a) {
                var b = this.valueSize,
                    c = this.buffer;
                a = a * b + b;
                var d = this.cumulativeWeight,
                    e = this.binding;
                this.cumulativeWeight = 0, 1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b);
                for (var d = b, f = b + b; d !== f; ++d)
                    if (c[d] !== c[d + b]) {
                        e.setValue(c, a);
                        break
                    }
            },
            saveOriginalState: function() {
                var a = this.buffer,
                    b = this.valueSize,
                    c = 3 * b;
                this.binding.getValue(a, c);
                for (var d = b; d !== c; ++d) a[d] = a[c + d % b];
                this.cumulativeWeight = 0
            },
            restoreOriginalState: function() {
                this.binding.setValue(this.buffer, 3 * this.valueSize)
            },
            _select: function(a, b, c, d, e) {
                if (.5 <= d)
                    for (d = 0; d !== e; ++d) a[b + d] = a[c + d]
            },
            _slerp: function(a, b, c, d, e) {
                h.slerpFlat(a, b, a, b, a, c, d)
            },
            _lerp: function(a, b, c, d, e) {
                for (var f = 1 - d, g = 0; g !== e; ++g) {
                    var h = b + g;
                    a[h] = a[h] * f + a[c + g] * d
                }
            }
        }, cd.prototype = {
            constructor: cd,
            getValue: function(a, b) {
                this.bind(), this.getValue(a, b)
            },
            setValue: function(a, b) {
                this.bind(), this.setValue(a, b)
            },
            bind: function() {
                var a = this.node,
                    b = this.parsedPath,
                    c = b.objectName,
                    d = b.propertyName,
                    e = b.propertyIndex;
                if (a || (this.node = a = cd.findNode(this.rootNode, b.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, a) {
                    if (c) {
                        var f = b.objectIndex;
                        switch (c) {
                            case "materials":
                                if (!a.material) return void console.error("  can not bind to material as node does not have a material", this);
                                if (!a.material.materials) return void console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                                a = a.material.materials;
                                break;
                            case "bones":
                                if (!a.skeleton) return void console.error("  can not bind to bones as node does not have a skeleton", this);
                                for (a = a.skeleton.bones, c = 0; c < a.length; c++)
                                    if (a[c].name === f) {
                                        f = c;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === a[c]) return void console.error("  can not bind to objectName of node, undefined", this);
                                a = a[c]
                        }
                        if (void 0 !== f) {
                            if (void 0 === a[f]) return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, a);
                            a = a[f]
                        }
                    }
                    if (f = a[d], void 0 === f) console.error("  trying to update property for track: " + b.nodeName + "." + d + " but it wasn't found.", a);
                    else {
                        if (b = this.Versioning.None, void 0 !== a.needsUpdate ? (b = this.Versioning.NeedsUpdate, this.targetObject = a) : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = a), c = this.BindingType.Direct, void 0 !== e) {
                            if ("morphTargetInfluences" === d) {
                                if (!a.geometry) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                                if (!a.geometry.morphTargets) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
                                for (c = 0; c < this.node.geometry.morphTargets.length; c++)
                                    if (a.geometry.morphTargets[c].name === e) {
                                        e = c;
                                        break
                                    }
                            }
                            c = this.BindingType.ArrayElement, this.resolvedProperty = f, this.propertyIndex = e
                        } else void 0 !== f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = f) : void 0 !== f.length ? (c = this.BindingType.EntireArray, this.resolvedProperty = f) : this.propertyName = d;
                        this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][b]
                    }
                } else console.error("  trying to update node for track: " + this.path + " but it wasn't found.")
            },
            unbind: function() {
                this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
            }
        }, Object.assign(cd.prototype, {
            _getValue_unavailable: function() {},
            _setValue_unavailable: function() {},
            _getValue_unbound: cd.prototype.getValue,
            _setValue_unbound: cd.prototype.setValue,
            BindingType: {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            },
            Versioning: {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            },
            GetterByBindingType: [function(a, b) {
                a[b] = this.node[this.propertyName]
            }, function(a, b) {
                for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) a[b++] = c[d]
            }, function(a, b) {
                a[b] = this.resolvedProperty[this.propertyIndex]
            }, function(a, b) {
                this.resolvedProperty.toArray(a, b)
            }],
            SetterByBindingTypeAndVersioning: [
                [function(a, b) {
                    this.node[this.propertyName] = a[b]
                }, function(a, b) {
                    this.node[this.propertyName] = a[b], this.targetObject.needsUpdate = !0
                }, function(a, b) {
                    this.node[this.propertyName] = a[b], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(a, b) {
                    for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++]
                }, function(a, b) {
                    for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
                    this.targetObject.needsUpdate = !0
                }, function(a, b) {
                    for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
                    this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(a, b) {
                    this.resolvedProperty[this.propertyIndex] = a[b];
                }, function(a, b) {
                    this.resolvedProperty[this.propertyIndex] = a[b], this.targetObject.needsUpdate = !0
                }, function(a, b) {
                    this.resolvedProperty[this.propertyIndex] = a[b], this.targetObject.matrixWorldNeedsUpdate = !0
                }],
                [function(a, b) {
                    this.resolvedProperty.fromArray(a, b)
                }, function(a, b) {
                    this.resolvedProperty.fromArray(a, b), this.targetObject.needsUpdate = !0
                }, function(a, b) {
                    this.resolvedProperty.fromArray(a, b), this.targetObject.matrixWorldNeedsUpdate = !0
                }]
            ]
        }), cd.Composite = function(a, b, c) {
            c = c || cd.parseTrackName(b), this._targetGroup = a, this._bindings = a.subscribe_(b, c)
        }, cd.Composite.prototype = {
            constructor: cd.Composite,
            getValue: function(a, b) {
                this.bind();
                var c = this._bindings[this._targetGroup.nCachedObjects_];
                void 0 !== c && c.getValue(a, b)
            },
            setValue: function(a, b) {
                for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !== e; ++d) c[d].setValue(a, b)
            },
            bind: function() {
                for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].bind()
            },
            unbind: function() {
                for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].unbind()
            }
        }, cd.create = function(a, b, c) {
            return a && a.isAnimationObjectGroup ? new cd.Composite(a, b, c) : new cd(a, b, c)
        }, cd.parseTrackName = function(a) {
            var b = /^((?:\w+[\/:])*)(\w+)?(?:\.(\w+)(?:\[(.+)\])?)?\.(\w+)(?:\[(.+)\])?$/.exec(a);
            if (!b) throw Error("cannot parse trackName at all: " + a);
            if (b = {
                    nodeName: b[2],
                    objectName: b[3],
                    objectIndex: b[4],
                    propertyName: b[5],
                    propertyIndex: b[6]
                }, null === b.propertyName || 0 === b.propertyName.length) throw Error("can not parse propertyName from trackName: " + a);
            return b
        }, cd.findNode = function(a, b) {
            if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a;
            if (a.skeleton) {
                var c = function(a) {
                    for (var c = 0; c < a.bones.length; c++) {
                        var d = a.bones[c];
                        if (d.name === b) return d
                    }
                    return null
                }(a.skeleton);
                if (c) return c
            }
            if (a.children) {
                var d = function(a) {
                    for (var c = 0; c < a.length; c++) {
                        var e = a[c];
                        if (e.name === b || e.uuid === b || (e = d(e.children))) return e
                    }
                    return null
                };
                if (c = d(a.children)) return c
            }
            return null
        }, dd.prototype = {
            constructor: dd,
            isAnimationObjectGroup: !0,
            add: function(a) {
                for (var b = this._objects, c = b.length, d = this.nCachedObjects_, e = this._indicesByUUID, f = this._paths, g = this._parsedPaths, h = this._bindings, i = h.length, j = 0, k = arguments.length; j !== k; ++j) {
                    var l = arguments[j],
                        m = l.uuid,
                        n = e[m];
                    if (void 0 === n) {
                        n = c++, e[m] = n, b.push(l);
                        for (var m = 0, o = i; m !== o; ++m) h[m].push(new cd(l, f[m], g[m]))
                    } else if (n < d) {
                        var p = b[n],
                            q = --d,
                            o = b[q];
                        for (e[o.uuid] = n, b[n] = o, e[m] = q, b[q] = l, m = 0, o = i; m !== o; ++m) {
                            var r = h[m],
                                s = r[n];
                            r[n] = r[q], void 0 === s && (s = new cd(l, f[m], g[m])), r[q] = s
                        }
                    } else b[n] !== p && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
                }
                this.nCachedObjects_ = d
            },
            remove: function(a) {
                for (var b = this._objects, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._bindings, f = e.length, g = 0, h = arguments.length; g !== h; ++g) {
                    var i = arguments[g],
                        j = i.uuid,
                        k = d[j];
                    if (void 0 !== k && k >= c) {
                        var l = c++,
                            m = b[l];
                        for (d[m.uuid] = k, b[k] = m, d[j] = l, b[l] = i, i = 0, j = f; i !== j; ++i) {
                            var m = e[i],
                                n = m[k];
                            m[k] = m[l], m[l] = n
                        }
                    }
                }
                this.nCachedObjects_ = c
            },
            uncache: function(a) {
                for (var b = this._objects, c = b.length, d = this.nCachedObjects_, e = this._indicesByUUID, f = this._bindings, g = f.length, h = 0, i = arguments.length; h !== i; ++h) {
                    var j = arguments[h].uuid,
                        k = e[j];
                    if (void 0 !== k)
                        if (delete e[j], k < d) {
                            var j = --d,
                                l = b[j],
                                m = --c,
                                n = b[m];
                            for (e[l.uuid] = k, b[k] = l, e[n.uuid] = j, b[j] = n, b.pop(), l = 0, n = g; l !== n; ++l) {
                                var o = f[l],
                                    p = o[m];
                                o[k] = o[j], o[j] = p, o.pop()
                            }
                        } else
                            for (m = --c, n = b[m], e[n.uuid] = k, b[k] = n, b.pop(), l = 0, n = g; l !== n; ++l) o = f[l], o[k] = o[m], o.pop()
                }
                this.nCachedObjects_ = d
            },
            subscribe_: function(a, b) {
                var c = this._bindingsIndicesByPath,
                    d = c[a],
                    e = this._bindings;
                if (void 0 !== d) return e[d];
                var f = this._paths,
                    g = this._parsedPaths,
                    h = this._objects,
                    i = this.nCachedObjects_,
                    j = Array(h.length),
                    d = e.length;
                for (c[a] = d, f.push(a), g.push(b), e.push(j), c = i, d = h.length; c !== d; ++c) j[c] = new cd(h[c], a, b);
                return j
            },
            unsubscribe_: function(a) {
                var b = this._bindingsIndicesByPath,
                    c = b[a];
                if (void 0 !== c) {
                    var d = this._paths,
                        e = this._parsedPaths,
                        f = this._bindings,
                        g = f.length - 1,
                        h = f[g];
                    b[a[g]] = c, f[c] = h, f.pop(), e[c] = e[g], e.pop(), d[c] = d[g], d.pop()
                }
            }
        }, ed.prototype = {
            constructor: ed,
            play: function() {
                return this._mixer._activateAction(this), this
            },
            stop: function() {
                return this._mixer._deactivateAction(this), this.reset()
            },
            reset: function() {
                return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
            },
            isRunning: function() {
                return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
            },
            isScheduled: function() {
                return this._mixer._isActiveAction(this)
            },
            startAt: function(a) {
                return this._startTime = a, this
            },
            setLoop: function(a, b) {
                return this.loop = a, this.repetitions = b, this
            },
            setEffectiveWeight: function(a) {
                return this.weight = a, this._effectiveWeight = this.enabled ? a : 0, this.stopFading()
            },
            getEffectiveWeight: function() {
                return this._effectiveWeight
            },
            fadeIn: function(a) {
                return this._scheduleFading(a, 0, 1)
            },
            fadeOut: function(a) {
                return this._scheduleFading(a, 1, 0)
            },
            crossFadeFrom: function(a, b, c) {
                if (a.fadeOut(b), this.fadeIn(b), c) {
                    c = this._clip.duration;
                    var d = a._clip.duration,
                        e = c / d;
                    a.warp(1, d / c, b), this.warp(e, 1, b)
                }
                return this
            },
            crossFadeTo: function(a, b, c) {
                return a.crossFadeFrom(this, b, c)
            },
            stopFading: function() {
                var a = this._weightInterpolant;
                return null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a)), this
            },
            setEffectiveTimeScale: function(a) {
                return this.timeScale = a, this._effectiveTimeScale = this.paused ? 0 : a, this.stopWarping()
            },
            getEffectiveTimeScale: function() {
                return this._effectiveTimeScale
            },
            setDuration: function(a) {
                return this.timeScale = this._clip.duration / a, this.stopWarping()
            },
            syncWith: function(a) {
                return this.time = a.time, this.timeScale = a.timeScale, this.stopWarping()
            },
            halt: function(a) {
                return this.warp(this._effectiveTimeScale, 0, a)
            },
            warp: function(a, b, c) {
                var d = this._mixer,
                    e = d.time,
                    f = this._timeScaleInterpolant,
                    g = this.timeScale;
                return null === f && (this._timeScaleInterpolant = f = d._lendControlInterpolant()), d = f.parameterPositions, f = f.sampleValues, d[0] = e, d[1] = e + c, f[0] = a / g, f[1] = b / g, this
            },
            stopWarping: function() {
                var a = this._timeScaleInterpolant;
                return null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a)), this
            },
            getMixer: function() {
                return this._mixer
            },
            getClip: function() {
                return this._clip
            },
            getRoot: function() {
                return this._localRoot || this._mixer._root
            },
            _update: function(a, b, c, d) {
                var e = this._startTime;
                if (null !== e) {
                    if (b = (a - e) * c, 0 > b || 0 === c) return;
                    this._startTime = null, b *= c
                }
                if (b *= this._updateTimeScale(a), c = this._updateTime(b), a = this._updateWeight(a), 0 < a) {
                    b = this._interpolants;
                    for (var e = this._propertyBindings, f = 0, g = b.length; f !== g; ++f) b[f].evaluate(c), e[f].accumulate(d, a)
                }
            },
            _updateWeight: function(a) {
                var b = 0;
                if (this.enabled) {
                    var b = this.weight,
                        c = this._weightInterpolant;
                    if (null !== c) {
                        var d = c.evaluate(a)[0],
                            b = b * d;
                        a > c.parameterPositions[1] && (this.stopFading(), 0 === d && (this.enabled = !1))
                    }
                }
                return this._effectiveWeight = b
            },
            _updateTimeScale: function(a) {
                var b = 0;
                if (!this.paused) {
                    var b = this.timeScale,
                        c = this._timeScaleInterpolant;
                    if (null !== c) {
                        var d = c.evaluate(a)[0],
                            b = b * d;
                        a > c.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = !0 : this.timeScale = b)
                    }
                }
                return this._effectiveTimeScale = b
            },
            _updateTime: function(a) {
                var b = this.time + a;
                if (0 === a) return b;
                var c = this._clip.duration,
                    d = this.loop,
                    e = this._loopCount;
                if (2200 === d) a: {
                    if (-1 === e && (this.loopCount = 0, this._setEndings(!0, !0, !1)), b >= c) b = c;
                    else {
                        if (!(0 > b)) break a;
                        b = 0
                    }
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: 0 > a ? -1 : 1
                    })
                }
                else {
                    if (d = 2202 === d, -1 === e && (0 <= a ? (e = 0, this._setEndings(!0, 0 === this.repetitions, d)) : this._setEndings(0 === this.repetitions, !0, d)), b >= c || 0 > b) {
                        var f = Math.floor(b / c),
                            b = b - c * f,
                            e = e + Math.abs(f),
                            g = this.repetitions - e;
                        0 > g ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, b = 0 < a ? c : 0, this._mixer.dispatchEvent({
                            type: "finished",
                            action: this,
                            direction: 0 < a ? 1 : -1
                        })) : (0 === g ? (a = 0 > a, this._setEndings(a, !a, d)) : this._setEndings(!1, !1, d), this._loopCount = e, this._mixer.dispatchEvent({
                            type: "loop",
                            action: this,
                            loopDelta: f
                        }))
                    }
                    if (d && 1 === (1 & e)) return this.time = b, c - b
                }
                return this.time = b
            },
            _setEndings: function(a, b, c) {
                var d = this._interpolantSettings;
                c ? (d.endingStart = 2401, d.endingEnd = 2401) : (d.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, d.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
            },
            _scheduleFading: function(a, b, c) {
                var d = this._mixer,
                    e = d.time,
                    f = this._weightInterpolant;
                return null === f && (this._weightInterpolant = f = d._lendControlInterpolant()), d = f.parameterPositions, f = f.sampleValues, d[0] = e, f[0] = b, d[1] = e + a, f[1] = c, this
            }
        }, Object.assign(fd.prototype, b.prototype, {
            clipAction: function(a, b) {
                var c = b || this._root,
                    d = c.uuid,
                    e = "string" == typeof a ? Dc.findByName(c, a) : a,
                    c = null !== e ? e.uuid : a,
                    f = this._actionsByClip[c],
                    g = null;
                if (void 0 !== f) {
                    if (g = f.actionByRoot[d], void 0 !== g) return g;
                    g = f.knownActions[0], null === e && (e = g._clip)
                }
                return null === e ? null : (e = new ed(this, e, b), this._bindAction(e, g), this._addInactiveAction(e, c, d), e)
            },
            existingAction: function(a, b) {
                var c = b || this._root,
                    d = c.uuid,
                    c = "string" == typeof a ? Dc.findByName(c, a) : a,
                    c = this._actionsByClip[c ? c.uuid : a];
                return void 0 !== c ? c.actionByRoot[d] || null : null
            },
            stopAllAction: function() {
                for (var a = this._actions, b = this._nActiveActions, c = this._bindings, d = this._nActiveBindings, e = this._nActiveBindings = this._nActiveActions = 0; e !== b; ++e) a[e].reset();
                for (e = 0; e !== d; ++e) c[e].useCount = 0;
                return this
            },
            update: function(a) {
                a *= this.timeScale;
                for (var b = this._actions, c = this._nActiveActions, d = this.time += a, e = Math.sign(a), f = this._accuIndex ^= 1, g = 0; g !== c; ++g) {
                    var h = b[g];
                    h.enabled && h._update(d, a, e, f)
                }
                for (a = this._bindings, b = this._nActiveBindings, g = 0; g !== b; ++g) a[g].apply(f);
                return this
            },
            getRoot: function() {
                return this._root
            },
            uncacheClip: function(a) {
                var b = this._actions;
                a = a.uuid;
                var c = this._actionsByClip,
                    d = c[a];
                if (void 0 !== d) {
                    for (var d = d.knownActions, e = 0, f = d.length; e !== f; ++e) {
                        var g = d[e];
                        this._deactivateAction(g);
                        var h = g._cacheIndex,
                            i = b[b.length - 1];
                        g._cacheIndex = null, g._byClipCacheIndex = null, i._cacheIndex = h, b[h] = i, b.pop(), this._removeInactiveBindingsForAction(g)
                    }
                    delete c[a]
                }
            },
            uncacheRoot: function(a) {
                a = a.uuid;
                var b, c = this._actionsByClip;
                for (b in c) {
                    var d = c[b].actionByRoot[a];
                    void 0 !== d && (this._deactivateAction(d), this._removeInactiveAction(d))
                }
                if (b = this._bindingsByRootAndName[a], void 0 !== b)
                    for (var e in b) a = b[e], a.restoreOriginalState(), this._removeInactiveBinding(a)
            },
            uncacheAction: function(a, b) {
                var c = this.existingAction(a, b);
                null !== c && (this._deactivateAction(c), this._removeInactiveAction(c))
            }
        }), Object.assign(fd.prototype, {
            _bindAction: function(a, b) {
                var c = a._localRoot || this._root,
                    d = a._clip.tracks,
                    e = d.length,
                    f = a._propertyBindings,
                    g = a._interpolants,
                    h = c.uuid,
                    i = this._bindingsByRootAndName,
                    j = i[h];
                for (void 0 === j && (j = {}, i[h] = j), i = 0; i !== e; ++i) {
                    var k = d[i],
                        l = k.name,
                        m = j[l];
                    if (void 0 === m) {
                        if (m = f[i], void 0 !== m) {
                            null === m._cacheIndex && (++m.referenceCount, this._addInactiveBinding(m, h, l));
                            continue
                        }
                        m = new bd(cd.create(c, l, b && b._propertyBindings[i].binding.parsedPath), k.ValueTypeName, k.getValueSize()), ++m.referenceCount, this._addInactiveBinding(m, h, l)
                    }
                    f[i] = m, g[i].resultBuffer = m.buffer
                }
            },
            _activateAction: function(a) {
                if (!this._isActiveAction(a)) {
                    if (null === a._cacheIndex) {
                        var b = (a._localRoot || this._root).uuid,
                            c = a._clip.uuid,
                            d = this._actionsByClip[c];
                        this._bindAction(a, d && d.knownActions[0]), this._addInactiveAction(a, c, b)
                    }
                    for (b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
                        var e = b[c];
                        0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState())
                    }
                    this._lendAction(a)
                }
            },
            _deactivateAction: function(a) {
                if (this._isActiveAction(a)) {
                    for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
                        var e = b[c];
                        0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e))
                    }
                    this._takeBackAction(a)
                }
            },
            _initMemoryManager: function() {
                this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                var a = this;
                this.stats = {
                    actions: {
                        get total() {
                            return a._actions.length
                        },
                        get inUse() {
                            return a._nActiveActions
                        }
                    },
                    bindings: {
                        get total() {
                            return a._bindings.length
                        },
                        get inUse() {
                            return a._nActiveBindings
                        }
                    },
                    controlInterpolants: {
                        get total() {
                            return a._controlInterpolants.length
                        },
                        get inUse() {
                            return a._nActiveControlInterpolants
                        }
                    }
                }
            },
            _isActiveAction: function(a) {
                return a = a._cacheIndex, null !== a && a < this._nActiveActions
            },
            _addInactiveAction: function(a, b, c) {
                var d = this._actions,
                    e = this._actionsByClip,
                    f = e[b];
                void 0 === f ? (f = {
                    knownActions: [a],
                    actionByRoot: {}
                }, a._byClipCacheIndex = 0, e[b] = f) : (b = f.knownActions, a._byClipCacheIndex = b.length, b.push(a)), a._cacheIndex = d.length, d.push(a), f.actionByRoot[c] = a
            },
            _removeInactiveAction: function(a) {
                var b = this._actions,
                    c = b[b.length - 1],
                    d = a._cacheIndex;
                c._cacheIndex = d, b[d] = c, b.pop(), a._cacheIndex = null;
                var c = a._clip.uuid,
                    d = this._actionsByClip,
                    e = d[c],
                    f = e.knownActions,
                    g = f[f.length - 1],
                    h = a._byClipCacheIndex;
                g._byClipCacheIndex = h, f[h] = g, f.pop(), a._byClipCacheIndex = null, delete e.actionByRoot[(b._localRoot || this._root).uuid], 0 === f.length && delete d[c], this._removeInactiveBindingsForAction(a)
            },
            _removeInactiveBindingsForAction: function(a) {
                a = a._propertyBindings;
                for (var b = 0, c = a.length; b !== c; ++b) {
                    var d = a[b];
                    0 === --d.referenceCount && this._removeInactiveBinding(d)
                }
            },
            _lendAction: function(a) {
                var b = this._actions,
                    c = a._cacheIndex,
                    d = this._nActiveActions++,
                    e = b[d];
                a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e
            },
            _takeBackAction: function(a) {
                var b = this._actions,
                    c = a._cacheIndex,
                    d = --this._nActiveActions,
                    e = b[d];
                a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e
            },
            _addInactiveBinding: function(a, b, c) {
                var d = this._bindingsByRootAndName,
                    e = d[b],
                    f = this._bindings;
                void 0 === e && (e = {}, d[b] = e), e[c] = a, a._cacheIndex = f.length, f.push(a)
            },
            _removeInactiveBinding: function(a) {
                var b = this._bindings,
                    c = a.binding,
                    d = c.rootNode.uuid,
                    c = c.path,
                    e = this._bindingsByRootAndName,
                    f = e[d],
                    g = b[b.length - 1];
                a = a._cacheIndex, g._cacheIndex = a, b[a] = g, b.pop(), delete f[c];
                a: {
                    for (var h in f) break a;delete e[d]
                }
            },
            _lendBinding: function(a) {
                var b = this._bindings,
                    c = a._cacheIndex,
                    d = this._nActiveBindings++,
                    e = b[d];
                a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e
            },
            _takeBackBinding: function(a) {
                var b = this._bindings,
                    c = a._cacheIndex,
                    d = --this._nActiveBindings,
                    e = b[d];
                a._cacheIndex = d, b[d] = a, e._cacheIndex = c, b[c] = e
            },
            _lendControlInterpolant: function() {
                var a = this._controlInterpolants,
                    b = this._nActiveControlInterpolants++,
                    c = a[b];
                return void 0 === c && (c = new sc(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), c.__cacheIndex = b, a[b] = c), c
            },
            _takeBackControlInterpolant: function(a) {
                var b = this._controlInterpolants,
                    c = a.__cacheIndex,
                    d = --this._nActiveControlInterpolants,
                    e = b[d];
                a.__cacheIndex = d, b[d] = a, e.__cacheIndex = c, b[c] = e
            },
            _controlInterpolantsResultBuffer: new Float32Array(1)
        }), gd.prototype = {
            constructor: gd,
            onUpdate: function(a) {
                return this.dynamic = !0, this.onUpdateCallback = a, this
            }
        }, hd.prototype = Object.create(pa.prototype), hd.prototype.constructor = hd, hd.prototype.isInstancedBufferGeometry = !0, hd.prototype.addGroup = function(a, b, c) {
            this.groups.push({
                start: a,
                count: b,
                instances: c
            })
        }, hd.prototype.copy = function(a) {
            var b = a.index;
            null !== b && this.setIndex(b.clone());
            var c, b = a.attributes;
            for (c in b) this.addAttribute(c, b[c].clone());
            for (a = a.groups, c = 0, b = a.length; c < b; c++) {
                var d = a[c];
                this.addGroup(d.start, d.count, d.instances)
            }
            return this
        }, id.prototype = {
            constructor: id,
            isInterleavedBufferAttribute: !0,
            get count() {
                return this.data.count
            },
            get array() {
                return this.data.array
            },
            setX: function(a, b) {
                return this.data.array[a * this.data.stride + this.offset] = b, this
            },
            setY: function(a, b) {
                return this.data.array[a * this.data.stride + this.offset + 1] = b, this
            },
            setZ: function(a, b) {
                return this.data.array[a * this.data.stride + this.offset + 2] = b, this
            },
            setW: function(a, b) {
                return this.data.array[a * this.data.stride + this.offset + 3] = b, this
            },
            getX: function(a) {
                return this.data.array[a * this.data.stride + this.offset]
            },
            getY: function(a) {
                return this.data.array[a * this.data.stride + this.offset + 1]
            },
            getZ: function(a) {
                return this.data.array[a * this.data.stride + this.offset + 2]
            },
            getW: function(a) {
                return this.data.array[a * this.data.stride + this.offset + 3]
            },
            setXY: function(a, b, c) {
                return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, this
            },
            setXYZ: function(a, b, c, d) {
                return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, this.data.array[a + 2] = d, this
            },
            setXYZW: function(a, b, c, d, e) {
                return a = a * this.data.stride + this.offset, this.data.array[a + 0] = b, this.data.array[a + 1] = c, this.data.array[a + 2] = d, this.data.array[a + 3] = e, this
            }
        }, jd.prototype = {
            constructor: jd,
            isInterleavedBuffer: !0,
            set needsUpdate(a) {
                !0 === a && this.version++
            },
            setDynamic: function(a) {
                return this.dynamic = a, this
            },
            copy: function(a) {
                return this.array = new a.array.constructor(a.array), this.count = a.count, this.stride = a.stride, this.dynamic = a.dynamic, this
            },
            copyAt: function(a, b, c) {
                a *= this.stride, c *= b.stride;
                for (var d = 0, e = this.stride; d < e; d++) this.array[a + d] = b.array[c + d];
                return this
            },
            set: function(a, b) {
                return void 0 === b && (b = 0), this.array.set(a, b), this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            }
        }, kd.prototype = Object.create(jd.prototype), kd.prototype.constructor = kd, kd.prototype.isInstancedInterleavedBuffer = !0, kd.prototype.copy = function(a) {
            return jd.prototype.copy.call(this, a), this.meshPerAttribute = a.meshPerAttribute, this
        }, ld.prototype = Object.create(ja.prototype), ld.prototype.constructor = ld, ld.prototype.isInstancedBufferAttribute = !0, ld.prototype.copy = function(a) {
            return ja.prototype.copy.call(this, a), this.meshPerAttribute = a.meshPerAttribute, this
        }, md.prototype = {
            constructor: md,
            linePrecision: 1,
            set: function(a, b) {
                this.ray.set(a, b)
            },
            setFromCamera: function(a, b) {
                b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize()) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
            },
            intersectObject: function(a, b) {
                var c = [];
                return od(a, this, c, b), c.sort(nd), c
            },
            intersectObjects: function(a, b) {
                var c = [];
                if (!1 === Array.isArray(a)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), c;
                for (var d = 0, e = a.length; d < e; d++) od(a[d], this, c, b);
                return c.sort(nd), c
            }
        }, pd.prototype = {
            constructor: pd,
            start: function() {
                this.oldTime = this.startTime = (performance || Date).now(), this.running = !0
            },
            stop: function() {
                this.getElapsedTime(), this.running = !1
            },
            getElapsedTime: function() {
                return this.getDelta(), this.elapsedTime
            },
            getDelta: function() {
                var a = 0;
                if (this.autoStart && !this.running && this.start(), this.running) {
                    var b = (performance || Date).now(),
                        a = (b - this.oldTime) / 1e3;
                    this.oldTime = b, this.elapsedTime += a
                }
                return a
            }
        }, qd.prototype = {
            constructor: qd,
            set: function(a, b, c) {
                return this.radius = a, this.phi = b, this.theta = c, this
            },
            clone: function() {
                return (new this.constructor).copy(this)
            },
            copy: function(a) {
                return this.radius.copy(a.radius), this.phi.copy(a.phi), this.theta.copy(a.theta), this
            },
            makeSafe: function() {
                return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
            },
            setFromVector3: function(b) {
                return this.radius = b.length(), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(b.x, b.z), this.phi = Math.acos(a.Math.clamp(b.y / this.radius, -1, 1))), this
            }
        }, rd.prototype = Object.create(qa.prototype), rd.prototype.constructor = rd, rd.prototype.createAnimation = function(a, b, c, d) {
            b = {
                start: b,
                end: c,
                length: c - b + 1,
                fps: d,
                duration: (c - b) / d,
                lastFrame: 0,
                currentFrame: 0,
                active: !1,
                time: 0,
                direction: 1,
                weight: 1,
                directionBackwards: !1,
                mirroredLoop: !1
            }, this.animationsMap[a] = b, this.animationsList.push(b)
        }, rd.prototype.autoCreateAnimations = function(a) {
            for (var b, c = /([a-z]+)_?(\d+)/i, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; f < g; f++) {
                var h = e.morphTargets[f].name.match(c);
                if (h && 1 < h.length) {
                    var i = h[1];
                    d[i] || (d[i] = {
                        start: 1 / 0,
                        end: -(1 / 0)
                    }), h = d[i], f < h.start && (h.start = f), f > h.end && (h.end = f), b || (b = i)
                }
            }
            for (i in d) h = d[i], this.createAnimation(i, h.start, h.end, a);
            this.firstAnimation = b
        }, rd.prototype.setAnimationDirectionForward = function(a) {
            (a = this.animationsMap[a]) && (a.direction = 1, a.directionBackwards = !1)
        }, rd.prototype.setAnimationDirectionBackward = function(a) {
            (a = this.animationsMap[a]) && (a.direction = -1, a.directionBackwards = !0)
        }, rd.prototype.setAnimationFPS = function(a, b) {
            var c = this.animationsMap[a];
            c && (c.fps = b, c.duration = (c.end - c.start) / c.fps)
        }, rd.prototype.setAnimationDuration = function(a, b) {
            var c = this.animationsMap[a];
            c && (c.duration = b, c.fps = (c.end - c.start) / c.duration)
        }, rd.prototype.setAnimationWeight = function(a, b) {
            var c = this.animationsMap[a];
            c && (c.weight = b)
        }, rd.prototype.setAnimationTime = function(a, b) {
            var c = this.animationsMap[a];
            c && (c.time = b)
        }, rd.prototype.getAnimationTime = function(a) {
            var b = 0;
            return (a = this.animationsMap[a]) && (b = a.time), b
        }, rd.prototype.getAnimationDuration = function(a) {
            var b = -1;
            return (a = this.animationsMap[a]) && (b = a.duration), b
        }, rd.prototype.playAnimation = function(a) {
            var b = this.animationsMap[a];
            b ? (b.time = 0, b.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + a + "] undefined in .playAnimation()")
        }, rd.prototype.stopAnimation = function(a) {
            (a = this.animationsMap[a]) && (a.active = !1)
        }, rd.prototype.update = function(b) {
            for (var c = 0, d = this.animationsList.length; c < d; c++) {
                var e = this.animationsList[c];
                if (e.active) {
                    var f = e.duration / e.length;
                    e.time += e.direction * b, e.mirroredLoop ? (e.time > e.duration || 0 > e.time) && (e.direction *= -1, e.time > e.duration && (e.time = e.duration, e.directionBackwards = !0), 0 > e.time && (e.time = 0, e.directionBackwards = !1)) : (e.time %= e.duration, 0 > e.time && (e.time += e.duration));
                    var g = e.start + a.Math.clamp(Math.floor(e.time / f), 0, e.length - 1),
                        h = e.weight;
                    g !== e.currentFrame && (this.morphTargetInfluences[e.lastFrame] = 0, this.morphTargetInfluences[e.currentFrame] = 1 * h, this.morphTargetInfluences[g] = 0, e.lastFrame = e.currentFrame, e.currentFrame = g), f = e.time % f / f, e.directionBackwards && (f = 1 - f), e.currentFrame !== e.lastFrame ? (this.morphTargetInfluences[e.currentFrame] = f * h, this.morphTargetInfluences[e.lastFrame] = (1 - f) * h) : this.morphTargetInfluences[e.currentFrame] = h
                }
            }
        }, sd.prototype = Object.create(ea.prototype), sd.prototype.constructor = sd, sd.prototype.isImmediateRenderObject = !0, td.prototype = Object.create(hb.prototype), td.prototype.constructor = td, td.prototype.update = function() {
            var a = new i,
                b = new i,
                c = new Z;
            return function() {
                var d = ["a", "b", "c"];
                this.object.updateMatrixWorld(!0), c.getNormalMatrix(this.object.matrixWorld);
                var e = this.object.matrixWorld,
                    f = this.geometry.attributes.position,
                    g = this.object.geometry;
                if (g && g.isGeometry)
                    for (var h = g.vertices, i = g.faces, j = g = 0, k = i.length; j < k; j++)
                        for (var l = i[j], m = 0, n = l.vertexNormals.length; m < n; m++) {
                            var o = l.vertexNormals[m];
                            a.copy(h[l[d[m]]]).applyMatrix4(e), b.copy(o).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), f.setXYZ(g, a.x, a.y, a.z), g += 1, f.setXYZ(g, b.x, b.y, b.z), g += 1
                        } else if (g && g.isBufferGeometry)
                            for (d = g.attributes.position, h = g.attributes.normal, m = g = 0, n = d.count; m < n; m++) a.set(d.getX(m), d.getY(m), d.getZ(m)).applyMatrix4(e), b.set(h.getX(m), h.getY(m), h.getZ(m)), b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), f.setXYZ(g, a.x, a.y, a.z), g += 1, f.setXYZ(g, b.x, b.y, b.z), g += 1;
                return f.needsUpdate = !0, this
            }
        }(), ud.prototype = Object.create(ea.prototype), ud.prototype.constructor = ud, ud.prototype.dispose = function() {
            this.cone.geometry.dispose(), this.cone.material.dispose()
        }, ud.prototype.update = function() {
            var a = new i,
                b = new i;
            return function() {
                var c = this.light.distance ? this.light.distance : 1e3,
                    d = c * Math.tan(this.light.angle);
                this.cone.scale.set(d, d, c), a.setFromMatrixPosition(this.light.matrixWorld), b.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(b.sub(a)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
            }
        }(), vd.prototype = Object.create(hb.prototype), vd.prototype.constructor = vd, vd.prototype.getBoneList = function(a) {
            var b = [];
            a && a.isBone && b.push(a);
            for (var c = 0; c < a.children.length; c++) b.push.apply(b, this.getBoneList(a.children[c]));
            return b
        }, vd.prototype.update = function() {
            for (var a = this.geometry, b = (new j).getInverse(this.root.matrixWorld), c = new j, d = 0, e = 0; e < this.bones.length; e++) {
                var f = this.bones[e];
                f.parent && f.parent.isBone && (c.multiplyMatrices(b, f.matrixWorld), a.vertices[d].setFromMatrixPosition(c), c.multiplyMatrices(b, f.parent.matrixWorld), a.vertices[d + 1].setFromMatrixPosition(c), d += 2)
            }
            a.verticesNeedUpdate = !0, a.computeBoundingSphere()
        }, wd.prototype = Object.create(qa.prototype), wd.prototype.constructor = wd, wd.prototype.dispose = function() {
            this.geometry.dispose(), this.material.dispose()
        }, wd.prototype.update = function() {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
        }, xd.prototype = Object.create(ea.prototype), xd.prototype.constructor = xd, xd.prototype.dispose = function() {
            this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose()
        }, xd.prototype.update = function() {
            var a = new i;
            return function() {
                this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate()), this.lightSphere.geometry.colorsNeedUpdate = !0
            }
        }(), yd.prototype = Object.create(hb.prototype), yd.prototype.constructor = yd, yd.prototype.setColors = function() {
            console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
        }, zd.prototype = Object.create(hb.prototype), zd.prototype.constructor = zd, zd.prototype.update = function() {
            var a = new i,
                b = new i,
                c = new Z;
            return function() {
                this.object.updateMatrixWorld(!0), c.getNormalMatrix(this.object.matrixWorld);
                for (var d = this.object.matrixWorld, e = this.geometry.attributes.position, f = this.object.geometry, g = f.vertices, f = f.faces, h = 0, i = 0, j = f.length; i < j; i++) {
                    var k = f[i],
                        l = k.normal;
                    a.copy(g[k.a]).add(g[k.b]).add(g[k.c]).divideScalar(3).applyMatrix4(d), b.copy(l).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), e.setXYZ(h, a.x, a.y, a.z), h += 1, e.setXYZ(h, b.x, b.y, b.z), h += 1
                }
                return e.needsUpdate = !0, this
            }
        }(), Ad.prototype = Object.create(ea.prototype), Ad.prototype.constructor = Ad, Ad.prototype.dispose = function() {
            var a = this.children[0],
                b = this.children[1];
            a.geometry.dispose(), a.material.dispose(), b.geometry.dispose(), b.material.dispose()
        }, Ad.prototype.update = function() {
            var a = new i,
                b = new i,
                c = new i;
            return function() {
                a.setFromMatrixPosition(this.light.matrixWorld), b.setFromMatrixPosition(this.light.target.matrixWorld), c.subVectors(b, a);
                var d = this.children[0],
                    e = this.children[1];
                d.lookAt(c), d.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), e.lookAt(c), e.scale.z = c.length()
            }
        }(), Bd.prototype = Object.create(hb.prototype), Bd.prototype.constructor = Bd, Bd.prototype.update = function() {
            function a(a, f, g, h) {
                if (d.set(f, g, h).unproject(e), a = c[a], void 0 !== a)
                    for (f = 0, g = a.length; f < g; f++) b.vertices[a[f]].copy(d)
            }
            var b, c, d = new i,
                e = new ta;
            return function() {
                b = this.geometry, c = this.pointMap, e.projectionMatrix.copy(this.camera.projectionMatrix), a("c", 0, 0, -1), a("t", 0, 0, 1), a("n1", -1, -1, -1), a("n2", 1, -1, -1), a("n3", -1, 1, -1), a("n4", 1, 1, -1), a("f1", -1, -1, 1), a("f2", 1, -1, 1), a("f3", -1, 1, 1), a("f4", 1, 1, 1), a("u1", .7, 1.1, -1), a("u2", -.7, 1.1, -1), a("u3", 0, 2, -1), a("cf1", -1, 0, 1), a("cf2", 1, 0, 1), a("cf3", 0, -1, 1), a("cf4", 0, 1, 1), a("cn1", -1, 0, -1), a("cn2", 1, 0, -1), a("cn3", 0, -1, -1), a("cn4", 0, 1, -1), b.verticesNeedUpdate = !0
            }
        }(), Cd.prototype = Object.create(qa.prototype), Cd.prototype.constructor = Cd, Cd.prototype.update = function() {
            this.box.setFromObject(this.object), this.box.size(this.scale), this.box.getCenter(this.position)
        }, Dd.prototype = Object.create(hb.prototype), Dd.prototype.constructor = Dd, Dd.prototype.update = function() {
            var a = new X;
            return function(b) {
                if (b && b.isBox3 ? a.copy(b) : a.setFromObject(b), !a.isEmpty()) {
                    b = a.min;
                    var c = a.max,
                        d = this.geometry.attributes.position,
                        e = d.array;
                    e[0] = c.x, e[1] = c.y, e[2] = c.z, e[3] = b.x, e[4] = c.y, e[5] = c.z, e[6] = b.x, e[7] = b.y, e[8] = c.z, e[9] = c.x, e[10] = b.y, e[11] = c.z, e[12] = c.x, e[13] = c.y, e[14] = b.z, e[15] = b.x, e[16] = c.y, e[17] = b.z, e[18] = b.x, e[19] = b.y, e[20] = b.z, e[21] = c.x, e[22] = b.y, e[23] = b.z, d.needsUpdate = !0, this.geometry.computeBoundingSphere()
                }
            }
        }();
        var ce = new pa;
        ce.addAttribute("position", new ma([0, 0, 0, 0, 1, 0], 3));
        var de = new Mb(0, .5, 1, 5, 1);
        de.translate(0, -.5, 0), Ed.prototype = Object.create(ea.prototype), Ed.prototype.constructor = Ed, Ed.prototype.setDirection = function() {
            var a, b = new i;
            return function(c) {
                .99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (b.set(c.z, 0, -c.x).normalize(), a = Math.acos(c.y), this.quaternion.setFromAxisAngle(b, a))
            }
        }(), Ed.prototype.setLength = function(a, b, c) {
            void 0 === b && (b = .2 * a), void 0 === c && (c = .2 * b), this.line.scale.set(1, Math.max(0, a - b), 1), this.line.updateMatrix(), this.cone.scale.set(c, b, c), this.cone.position.y = a, this.cone.updateMatrix()
        }, Ed.prototype.setColor = function(a) {
            this.line.material.color.copy(a), this.cone.material.color.copy(a)
        }, Fd.prototype = Object.create(hb.prototype), Fd.prototype.constructor = Fd, a.CatmullRomCurve3 = function() {
            function a() {}
            var b = new i,
                c = new a,
                d = new a,
                e = new a;
            return a.prototype.init = function(a, b, c, d) {
                this.c0 = a, this.c1 = c, this.c2 = -3 * a + 3 * b - 2 * c - d, this.c3 = 2 * a - 2 * b + c + d
            }, a.prototype.initNonuniformCatmullRom = function(a, b, c, d, e, f, g) {
                this.init(b, c, ((b - a) / e - (c - a) / (e + f) + (c - b) / f) * f, ((c - b) / f - (d - b) / (f + g) + (d - c) / g) * f)
            }, a.prototype.initCatmullRom = function(a, b, c, d, e) {
                this.init(b, c, e * (c - a), e * (d - b))
            }, a.prototype.calc = function(a) {
                var b = a * a;
                return this.c0 + this.c1 * a + this.c2 * b + this.c3 * b * a
            }, Jc.create(function(a) {
                this.points = a || [], this.closed = !1
            }, function(a) {
                var f, g, h = this.points;
                g = h.length, 2 > g && console.log("duh, you need at least 2 points"), a *= g - (this.closed ? 0 : 1), f = Math.floor(a), a -= f, this.closed ? f += 0 < f ? 0 : (Math.floor(Math.abs(f) / h.length) + 1) * h.length : 0 === a && f === g - 1 && (f = g - 2, a = 1);
                var j, k, l;
                if (this.closed || 0 < f ? j = h[(f - 1) % g] : (b.subVectors(h[0], h[1]).add(h[0]), j = b), k = h[f % g], l = h[(f + 1) % g], this.closed || f + 2 < g ? h = h[(f + 2) % g] : (b.subVectors(h[g - 1], h[g - 2]).add(h[g - 1]), h = b), void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
                    var m = "chordal" === this.type ? .5 : .25;
                    g = Math.pow(j.distanceToSquared(k), m), f = Math.pow(k.distanceToSquared(l), m), m = Math.pow(l.distanceToSquared(h), m), 1e-4 > f && (f = 1), 1e-4 > g && (g = f), 1e-4 > m && (m = f), c.initNonuniformCatmullRom(j.x, k.x, l.x, h.x, g, f, m), d.initNonuniformCatmullRom(j.y, k.y, l.y, h.y, g, f, m), e.initNonuniformCatmullRom(j.z, k.z, l.z, h.z, g, f, m)
                } else "catmullrom" === this.type && (g = void 0 !== this.tension ? this.tension : .5, c.initCatmullRom(j.x, k.x, l.x, h.x, g), d.initCatmullRom(j.y, k.y, l.y, h.y, g), e.initCatmullRom(j.z, k.z, l.z, h.z, g));
                return new i(c.calc(a), d.calc(a), e.calc(a))
            })
        }(), Gd.prototype = Object.create(a.CatmullRomCurve3.prototype);
        var ee = Jc.create(function(a) {
            console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3"), this.points = void 0 === a ? [] : a
        }, function(b) {
            var c = this.points;
            b *= c.length - 1;
            var d = Math.floor(b);
            b -= d;
            var e = c[0 == d ? d : d - 1],
                f = c[d],
                g = c[d > c.length - 2 ? c.length - 1 : d + 1],
                c = c[d > c.length - 3 ? c.length - 1 : d + 2],
                d = a.CurveUtils.interpolate;
            return new i(d(e.x, f.x, g.x, c.x, b), d(e.y, f.y, g.y, c.y, b), d(e.z, f.z, g.z, c.z, b))
        });
        a.CubicBezierCurve3 = Jc.create(function(a, b, c, d) {
            this.v0 = a, this.v1 = b, this.v2 = c, this.v3 = d
        }, function(b) {
            var c = a.ShapeUtils.b3;
            return new i(c(b, this.v0.x, this.v1.x, this.v2.x, this.v3.x), c(b, this.v0.y, this.v1.y, this.v2.y, this.v3.y), c(b, this.v0.z, this.v1.z, this.v2.z, this.v3.z))
        }), a.QuadraticBezierCurve3 = Jc.create(function(a, b, c) {
            this.v0 = a, this.v1 = b, this.v2 = c
        }, function(b) {
            var c = a.ShapeUtils.b2;
            return new i(c(b, this.v0.x, this.v1.x, this.v2.x), c(b, this.v0.y, this.v1.y, this.v2.y), c(b, this.v0.z, this.v1.z, this.v2.z))
        }), a.LineCurve3 = Jc.create(function(a, b) {
            this.v1 = a, this.v2 = b
        }, function(a) {
            if (1 === a) return this.v2.clone();
            var b = new i;
            return b.subVectors(this.v2, this.v1), b.multiplyScalar(a), b.add(this.v1), b
        }), Hd.prototype = Object.create(Mc.prototype), Hd.prototype.constructor = Hd, a.SceneUtils = {
            createMultiMaterialObject: function(a, b) {
                for (var c = new kb, d = 0, e = b.length; d < e; d++) c.add(new qa(a, b[d]));
                return c
            },
            detach: function(a, b, c) {
                a.applyMatrix(b.matrixWorld), b.remove(a), c.add(a)
            },
            attach: function(a, b, c) {
                var d = new j;
                d.getInverse(c.matrixWorld), a.applyMatrix(d), b.remove(a), c.add(a)
            }
        }, Object.assign(R.prototype, {
            center: function(a) {
                return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(a)
            },
            empty: function() {
                return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            },
            isIntersectionBox: function(a) {
                return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
                    this.intersectsBox(a)
            },
            size: function(a) {
                return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(a)
            }
        }), Object.assign(X.prototype, {
            center: function(a) {
                return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(a)
            },
            empty: function() {
                return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
            },
            isIntersectionBox: function(a) {
                return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(a)
            },
            isIntersectionSphere: function(a) {
                return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(a)
            },
            size: function(a) {
                return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(a)
            }
        }), Object.assign(fa.prototype, {
            center: function(a) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(a)
            }
        }), Object.assign(Z.prototype, {
            multiplyVector3: function(a) {
                return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), a.applyMatrix3(this)
            },
            multiplyVector3Array: function(a) {
                return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(a)
            }
        }), Object.assign(j.prototype, {
            extractPosition: function(a) {
                return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(a)
            },
            setRotationFromQuaternion: function(a) {
                return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(a)
            },
            multiplyVector3: function(a) {
                return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), a.applyProjection(this)
            },
            multiplyVector4: function(a) {
                return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
            },
            multiplyVector3Array: function(a) {
                return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(a)
            },
            rotateAxis: function(a) {
                console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), a.transformDirection(this)
            },
            crossVector: function(a) {
                return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), a.applyMatrix4(this)
            },
            translate: function(a) {
                console.error("THREE.Matrix4: .translate() has been removed.")
            },
            rotateX: function(a) {
                console.error("THREE.Matrix4: .rotateX() has been removed.")
            },
            rotateY: function(a) {
                console.error("THREE.Matrix4: .rotateY() has been removed.")
            },
            rotateZ: function(a) {
                console.error("THREE.Matrix4: .rotateZ() has been removed.")
            },
            rotateByAxis: function(a, b) {
                console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
            }
        }), Object.assign($.prototype, {
            isIntersectionLine: function(a) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(a)
            }
        }), Object.assign(h.prototype, {
            multiplyVector3: function(a) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), a.applyQuaternion(this)
            }
        }), Object.assign(ba.prototype, {
            isIntersectionBox: function(a) {
                return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(a)
            },
            isIntersectionPlane: function(a) {
                return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(a)
            },
            isIntersectionSphere: function(a) {
                return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(a)
            }
        }), Object.assign(Qc.prototype, {
            extrude: function(a) {
                return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Bb(this, a)
            },
            makeGeometry: function(a) {
                return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new Kb(this, a)
            }
        }), Object.assign(i.prototype, {
            setEulerFromRotationMatrix: function() {
                console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
            },
            setEulerFromQuaternion: function() {
                console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
            },
            getPositionFromMatrix: function(a) {
                return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(a)
            },
            getScaleFromMatrix: function(a) {
                return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(a)
            },
            getColumnFromMatrix: function(a, b) {
                return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(b, a)
            }
        }), Object.assign(ea.prototype, {
            getChildByName: function(a) {
                return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(a)
            },
            renderDepth: function(a) {
                console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
            },
            translate: function(a, b) {
                return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(b, a)
            }
        }), Object.defineProperties(ea.prototype, {
            eulerOrder: {
                get: function() {
                    return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                },
                set: function(a) {
                    console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = a
                }
            },
            useQuaternion: {
                get: function() {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                },
                set: function(a) {
                    console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                }
            }
        }), Object.defineProperties(ab.prototype, {
            objects: {
                get: function() {
                    return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                }
            }
        }), ua.prototype.setLens = function(a, b) {
            console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== b && (this.filmGauge = b), this.setFocalLength(a)
        }, Object.defineProperties(hc.prototype, {
            onlyShadow: {
                set: function(a) {
                    console.warn("THREE.Light: .onlyShadow has been removed.")
                }
            },
            shadowCameraFov: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = a
                }
            },
            shadowCameraLeft: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = a
                }
            },
            shadowCameraRight: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = a
                }
            },
            shadowCameraTop: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = a
                }
            },
            shadowCameraBottom: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = a
                }
            },
            shadowCameraNear: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = a
                }
            },
            shadowCameraFar: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = a
                }
            },
            shadowCameraVisible: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                }
            },
            shadowBias: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = a
                }
            },
            shadowDarkness: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowDarkness has been removed.")
                }
            },
            shadowMapWidth: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = a
                }
            },
            shadowMapHeight: {
                set: function(a) {
                    console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = a
                }
            }
        }), Object.defineProperties(ja.prototype, {
            length: {
                get: function() {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."), this.array.length
                }
            }
        }), Object.assign(pa.prototype, {
            addIndex: function(a) {
                console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(a)
            },
            addDrawCall: function(a, b, c) {
                void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(a, b)
            },
            clearDrawCalls: function() {
                console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
            },
            computeTangents: function() {
                console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
            },
            computeOffsets: function() {
                console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
            }
        }), Object.defineProperties(pa.prototype, {
            drawcalls: {
                get: function() {
                    return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                }
            },
            offsets: {
                get: function() {
                    return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                }
            }
        }), Object.defineProperties(U.prototype, {
            wrapAround: {
                get: function() {
                    console.warn("THREE." + this.type + ": .wrapAround has been removed.")
                },
                set: function(a) {
                    console.warn("THREE." + this.type + ": .wrapAround has been removed.")
                }
            },
            wrapRGB: {
                get: function() {
                    return console.warn("THREE." + this.type + ": .wrapRGB has been removed."), new Q
                }
            }
        }), Object.defineProperties(Yb.prototype, {
            metal: {
                get: function() {
                    return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                },
                set: function(a) {
                    console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                }
            }
        }), Object.defineProperties(V.prototype, {
            derivatives: {
                get: function() {
                    return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                },
                set: function(a) {
                    console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = a
                }
            }
        }), b.prototype = Object.assign(Object.create({
            constructor: b,
            apply: function(a) {
                console.warn("THREE.EventDispatcher: .apply is deprecated, just inherit or Object.assign the prototype to mix-in."), Object.assign(a, this)
            }
        }), b.prototype), Object.assign(Va.prototype, {
            supportsFloatTextures: function() {
                return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
            },
            supportsHalfFloatTextures: function() {
                return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
            },
            supportsStandardDerivatives: function() {
                return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
            },
            supportsCompressedTextureS3TC: function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
            },
            supportsCompressedTexturePVRTC: function() {
                return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
            },
            supportsBlendMinMax: function() {
                return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
            },
            supportsVertexTextures: function() {
                return this.capabilities.vertexTextures
            },
            supportsInstancedArrays: function() {
                return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
            },
            enableScissorTest: function(a) {
                console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(a)
            },
            initMaterial: function() {
                console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
            },
            addPrePlugin: function() {
                console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
            },
            addPostPlugin: function() {
                console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
            },
            updateShadowMap: function() {
                console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
            }
        }), Object.defineProperties(Va.prototype, {
            shadowMapEnabled: {
                get: function() {
                    return this.shadowMap.enabled
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = a
                }
            },
            shadowMapType: {
                get: function() {
                    return this.shadowMap.type
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = a
                }
            },
            shadowMapCullFace: {
                get: function() {
                    return this.shadowMap.cullFace
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), this.shadowMap.cullFace = a
                }
            }
        }), Object.defineProperties(aa.prototype, {
            cullFace: {
                get: function() {
                    return this.renderReverseSided ? 2 : 1
                },
                set: function(a) {
                    a = 1 !== a, console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + a + "."), this.renderReverseSided = a
                }
            }
        }), Object.defineProperties(f.prototype, {
            wrapS: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = a
                }
            },
            wrapT: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = a
                }
            },
            magFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = a
                }
            },
            minFilter: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = a
                }
            },
            anisotropy: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = a
                }
            },
            offset: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = a
                }
            },
            repeat: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = a
                }
            },
            format: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = a
                }
            },
            type: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = a
                }
            },
            generateMipmaps: {
                get: function() {
                    return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                },
                set: function(a) {
                    console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = a
                }
            }
        }), Object.assign($c.prototype, {
            load: function(a) {
                console.warn("THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.");
                var b = this;
                return (new Wc).load(a, function(a) {
                    b.setBuffer(a)
                }), this
            }
        }), Object.assign(ad.prototype, {
            getData: function(a) {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
            }
        }), Object.defineProperty(a, "AudioContext", {
            get: function() {
                return a.getAudioContext()
            }
        }), a.WebGLRenderTargetCube = g, a.WebGLRenderTarget = f, a.WebGLRenderer = Va, a.ShaderLib = Ud, a.UniformsLib = Td, a.ShaderChunk = Sd, a.FogExp2 = Wa, a.Fog = Xa, a.Scene = Ya, a.LensFlare = Za, a.Sprite = _a, a.LOD = ab, a.SkinnedMesh = eb, a.Skeleton = cb, a.Bone = db, a.Mesh = qa, a.LineSegments = hb, a.Line = gb, a.Points = jb, a.Group = kb, a.VideoTexture = lb, a.DataTexture = bb, a.CompressedTexture = mb, a.CubeTexture = k, a.CanvasTexture = nb, a.DepthTexture = ob, a.TextureIdCount = function() {
            return Md++
        }, a.Texture = d, a.MaterialIdCount = function() {
            return Vd++
        }, a.CompressedTextureLoader = cc, a.BinaryTextureLoader = dc, a.DataTextureLoader = dc, a.CubeTextureLoader = fc, a.TextureLoader = gc, a.ObjectLoader = Ic, a.MaterialLoader = Ec, a.BufferGeometryLoader = Fc, a.LoadingManager = ac, a.JSONLoader = Hc, a.ImageLoader = ec, a.FontLoader = Uc, a.XHRLoader = bc, a.Loader = Gc, a.AudioLoader = Wc, a.SpotLightShadow = kc, a.SpotLight = lc, a.PointLight = mc, a.HemisphereLight = ic, a.DirectionalLightShadow = nc, a.DirectionalLight = oc, a.AmbientLight = pc, a.LightShadow = jc, a.Light = hc, a.StereoCamera = Xc, a.PerspectiveCamera = ua, a.OrthographicCamera = va, a.CubeCamera = Yc, a.Camera = ta, a.AudioListener = Zc, a.PositionalAudio = _c, a.getAudioContext = Vc, a.AudioAnalyser = ad, a.Audio = $c, a.VectorKeyframeTrack = vc, a.StringKeyframeTrack = zc, a.QuaternionKeyframeTrack = xc, a.NumberKeyframeTrack = yc, a.ColorKeyframeTrack = Bc, a.BooleanKeyframeTrack = Ac, a.PropertyMixer = bd, a.PropertyBinding = cd, a.KeyframeTrack = Cc, a.AnimationObjectGroup = dd, a.AnimationMixer = fd, a.AnimationClip = Dc, a.Uniform = gd, a.InstancedBufferGeometry = hd, a.BufferGeometry = pa, a.GeometryIdCount = function() {
            return Xd++
        }, a.Geometry = na, a.InterleavedBufferAttribute = id, a.InstancedInterleavedBuffer = kd, a.InterleavedBuffer = jd, a.InstancedBufferAttribute = ld, a.DynamicBufferAttribute = function(a, b) {
            return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new ja(a, b).setDynamic(!0)
        }, a.Float64Attribute = function(a, b) {
            return new ja(new Float64Array(a), b)
        }, a.Float32Attribute = ma, a.Uint32Attribute = la, a.Int32Attribute = function(a, b) {
            return new ja(new Int32Array(a), b)
        }, a.Uint16Attribute = ka, a.Int16Attribute = function(a, b) {
            return new ja(new Int16Array(a), b)
        }, a.Uint8ClampedAttribute = function(a, b) {
            return new ja(new Uint8ClampedArray(a), b)
        }, a.Uint8Attribute = function(a, b) {
            return new ja(new Uint8Array(a), b)
        }, a.Int8Attribute = function(a, b) {
            return new ja(new Int8Array(a), b)
        }, a.BufferAttribute = ja, a.Face3 = ha, a.Object3DIdCount = function() {
            return Wd++
        }, a.Object3D = ea, a.Raycaster = md, a.Layers = da, a.EventDispatcher = b, a.Clock = pd, a.QuaternionLinearInterpolant = wc, a.LinearInterpolant = sc, a.DiscreteInterpolant = tc, a.CubicInterpolant = rc, a.Interpolant = qc, a.Triangle = ga, a.Spline = function(a) {
            function b(a, b, c, d, e, f, g) {
                return a = .5 * (c - a), d = .5 * (d - b), (2 * (b - c) + a + d) * g + (-3 * (b - c) - 2 * a - d) * f + a * e + b
            }
            this.points = a;
            var c, d, e, f, g, h, j, k, l, m = [],
                n = {
                    x: 0,
                    y: 0,
                    z: 0
                };
            this.initFromArray = function(a) {
                this.points = [];
                for (var b = 0; b < a.length; b++) this.points[b] = {
                    x: a[b][0],
                    y: a[b][1],
                    z: a[b][2]
                }
            }, this.getPoint = function(a) {
                return c = (this.points.length - 1) * a, d = Math.floor(c), e = c - d, m[0] = 0 === d ? d : d - 1, m[1] = d, m[2] = d > this.points.length - 2 ? this.points.length - 1 : d + 1, m[3] = d > this.points.length - 3 ? this.points.length - 1 : d + 2, h = this.points[m[0]], j = this.points[m[1]], k = this.points[m[2]], l = this.points[m[3]], f = e * e, g = e * f, n.x = b(h.x, j.x, k.x, l.x, e, f, g), n.y = b(h.y, j.y, k.y, l.y, e, f, g), n.z = b(h.z, j.z, k.z, l.z, e, f, g), n
            }, this.getControlPointsArray = function() {
                var a, b, c = this.points.length,
                    d = [];
                for (a = 0; a < c; a++) b = this.points[a], d[a] = [b.x, b.y, b.z];
                return d
            }, this.getLength = function(a) {
                var b, c, d, e = 0,
                    f = new i,
                    g = new i,
                    h = [],
                    j = 0;
                for (h[0] = 0, a || (a = 100), c = this.points.length * a, f.copy(this.points[0]), a = 1; a < c; a++) b = a / c, d = this.getPoint(b), g.copy(d), j += g.distanceTo(f), f.copy(d), b *= this.points.length - 1, b = Math.floor(b), b !== e && (h[b] = j, e = b);
                return h[h.length] = j, {
                    chunks: h,
                    total: j
                }
            }, this.reparametrizeByArcLength = function(a) {
                var b, c, d, e, f, g, h = [],
                    j = new i,
                    k = this.getLength();
                for (h.push(j.copy(this.points[0]).clone()), b = 1; b < this.points.length; b++) {
                    for (c = k.chunks[b] - k.chunks[b - 1], g = Math.ceil(a * c / k.total), e = (b - 1) / (this.points.length - 1), f = b / (this.points.length - 1), c = 1; c < g - 1; c++) d = e + 1 / g * c * (f - e), d = this.getPoint(d), h.push(j.copy(d).clone());
                    h.push(j.copy(this.points[b]).clone())
                }
                this.points = h
            }
        }, a.Spherical = qd, a.Plane = $, a.Frustum = _, a.Sphere = Y, a.Ray = ba, a.Matrix4 = j, a.Matrix3 = Z, a.Box3 = X, a.Box2 = R, a.Line3 = fa, a.Euler = ca, a.Vector4 = e, a.Vector3 = i, a.Vector2 = c, a.Quaternion = h, a.Color = Q, a.MorphBlendMesh = rd, a.ImmediateRenderObject = sd, a.VertexNormalsHelper = td, a.SpotLightHelper = ud, a.SkeletonHelper = vd, a.PointLightHelper = wd, a.HemisphereLightHelper = xd, a.GridHelper = yd, a.FaceNormalsHelper = zd, a.DirectionalLightHelper = Ad, a.CameraHelper = Bd, a.BoundingBoxHelper = Cd, a.BoxHelper = Dd, a.ArrowHelper = Ed, a.AxisHelper = Fd, a.ClosedSplineCurve3 = Gd, a.SplineCurve3 = ee, a.ArcCurve = Hd, a.EllipseCurve = Mc, a.SplineCurve = Nc, a.CubicBezierCurve = Oc, a.QuadraticBezierCurve = Pc, a.LineCurve = Kc, a.Shape = Qc, a.ShapePath = Sc, a.Path = Rc, a.Font = Tc, a.CurvePath = Lc, a.Curve = Jc, a.WireframeGeometry = pb, a.ParametricGeometry = qb, a.TetrahedronGeometry = sb, a.OctahedronGeometry = tb, a.IcosahedronGeometry = ub, a.DodecahedronGeometry = vb, a.PolyhedronGeometry = rb, a.TubeGeometry = wb, a.TorusKnotGeometry = yb, a.TorusKnotBufferGeometry = xb, a.TorusGeometry = Ab;
        a.TorusBufferGeometry = zb;
        a.TextGeometry = Cb, a.SphereBufferGeometry = Db, a.SphereGeometry = Eb, a.RingGeometry = Gb, a.RingBufferGeometry = Fb, a.PlaneBufferGeometry = sa, a.PlaneGeometry = Hb, a.LatheGeometry = Jb, a.LatheBufferGeometry = Ib, a.ShapeGeometry = Kb, a.ExtrudeGeometry = Bb, a.EdgesGeometry = Lb, a.ConeGeometry = Ob, a.ConeBufferGeometry = Pb, a.CylinderGeometry = Nb, a.CylinderBufferGeometry = Mb, a.CircleBufferGeometry = Qb, a.CircleGeometry = Rb, a.BoxBufferGeometry = ra, a.BoxGeometry = Sb, a.ShadowMaterial = Tb, a.SpriteMaterial = $a, a.RawShaderMaterial = Ub, a.ShaderMaterial = V, a.PointsMaterial = ib, a.MultiMaterial = Vb, a.MeshPhysicalMaterial = Xb, a.MeshStandardMaterial = Wb, a.MeshPhongMaterial = Yb, a.MeshNormalMaterial = Zb, a.MeshLambertMaterial = $b, a.MeshDepthMaterial = W, a.MeshBasicMaterial = ia, a.LineDashedMaterial = _b, a.LineBasicMaterial = fb, a.Material = U, a.REVISION = "81", a.MOUSE = {
            LEFT: 0,
            MIDDLE: 1,
            RIGHT: 2
        }, a.CullFaceNone = 0, a.CullFaceBack = 1, a.CullFaceFront = 2, a.CullFaceFrontBack = 3, a.FrontFaceDirectionCW = 0, a.FrontFaceDirectionCCW = 1, a.BasicShadowMap = 0, a.PCFShadowMap = 1, a.PCFSoftShadowMap = 2, a.FrontSide = 0, a.BackSide = 1, a.DoubleSide = 2, a.FlatShading = 1, a.SmoothShading = 2, a.NoColors = 0, a.FaceColors = 1, a.VertexColors = 2, a.NoBlending = 0, a.NormalBlending = 1, a.AdditiveBlending = 2, a.SubtractiveBlending = 3, a.MultiplyBlending = 4, a.CustomBlending = 5, a.BlendingMode = Id, a.AddEquation = 100, a.SubtractEquation = 101, a.ReverseSubtractEquation = 102, a.MinEquation = 103, a.MaxEquation = 104, a.ZeroFactor = 200, a.OneFactor = 201, a.SrcColorFactor = 202, a.OneMinusSrcColorFactor = 203, a.SrcAlphaFactor = 204, a.OneMinusSrcAlphaFactor = 205, a.DstAlphaFactor = 206, a.OneMinusDstAlphaFactor = 207, a.DstColorFactor = 208, a.OneMinusDstColorFactor = 209, a.SrcAlphaSaturateFactor = 210, a.NeverDepth = 0, a.AlwaysDepth = 1, a.LessDepth = 2, a.LessEqualDepth = 3, a.EqualDepth = 4, a.GreaterEqualDepth = 5, a.GreaterDepth = 6, a.NotEqualDepth = 7, a.MultiplyOperation = 0, a.MixOperation = 1, a.AddOperation = 2, a.NoToneMapping = 0, a.LinearToneMapping = 1, a.ReinhardToneMapping = 2, a.Uncharted2ToneMapping = 3, a.CineonToneMapping = 4, a.UVMapping = 300, a.CubeReflectionMapping = 301, a.CubeRefractionMapping = 302, a.EquirectangularReflectionMapping = 303, a.EquirectangularRefractionMapping = 304, a.SphericalReflectionMapping = 305, a.CubeUVReflectionMapping = 306, a.CubeUVRefractionMapping = 307, a.TextureMapping = Jd, a.RepeatWrapping = 1e3, a.ClampToEdgeWrapping = 1001, a.MirroredRepeatWrapping = 1002, a.TextureWrapping = Kd, a.NearestFilter = 1003, a.NearestMipMapNearestFilter = 1004, a.NearestMipMapLinearFilter = 1005, a.LinearFilter = 1006, a.LinearMipMapNearestFilter = 1007, a.LinearMipMapLinearFilter = 1008, a.TextureFilter = Ld, a.UnsignedByteType = 1009, a.ByteType = 1010, a.ShortType = 1011, a.UnsignedShortType = 1012, a.IntType = 1013, a.UnsignedIntType = 1014, a.FloatType = 1015, a.HalfFloatType = 1016, a.UnsignedShort4444Type = 1017, a.UnsignedShort5551Type = 1018, a.UnsignedShort565Type = 1019, a.UnsignedInt248Type = 1020, a.AlphaFormat = 1021, a.RGBFormat = 1022, a.RGBAFormat = 1023, a.LuminanceFormat = 1024, a.LuminanceAlphaFormat = 1025, a.RGBEFormat = 1023, a.DepthFormat = 1026, a.DepthStencilFormat = 1027, a.RGB_S3TC_DXT1_Format = 2001, a.RGBA_S3TC_DXT1_Format = 2002, a.RGBA_S3TC_DXT3_Format = 2003, a.RGBA_S3TC_DXT5_Format = 2004, a.RGB_PVRTC_4BPPV1_Format = 2100, a.RGB_PVRTC_2BPPV1_Format = 2101, a.RGBA_PVRTC_4BPPV1_Format = 2102, a.RGBA_PVRTC_2BPPV1_Format = 2103, a.RGB_ETC1_Format = 2151, a.LoopOnce = 2200, a.LoopRepeat = 2201, a.LoopPingPong = 2202, a.InterpolateDiscrete = 2300, a.InterpolateLinear = 2301, a.InterpolateSmooth = 2302, a.ZeroCurvatureEnding = 2400, a.ZeroSlopeEnding = 2401, a.WrapAroundEnding = 2402, a.TrianglesDrawMode = 0, a.TriangleStripDrawMode = 1, a.TriangleFanDrawMode = 2, a.LinearEncoding = 3e3, a.sRGBEncoding = 3001, a.GammaEncoding = 3007, a.RGBEEncoding = 3002, a.LogLuvEncoding = 3003, a.RGBM7Encoding = 3004, a.RGBM16Encoding = 3005, a.RGBDEncoding = 3006, a.BasicDepthPacking = 3200, a.RGBADepthPacking = 3201, a.CubeGeometry = Sb, a.Face4 = function(a, b, c, d, e, f, g) {
            return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new ha(a, b, c, e, f, g)
        }, a.LineStrip = 0, a.LinePieces = 1, a.MeshFaceMaterial = Vb, a.PointCloud = function(a, b) {
            return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new jb(a, b)
        }, a.Particle = _a, a.ParticleSystem = function(a, b) {
            return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new jb(a, b)
        }, a.PointCloudMaterial = function(a) {
            return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new ib(a)
        }, a.ParticleBasicMaterial = function(a) {
            return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new ib(a)
        }, a.ParticleSystemMaterial = function(a) {
            return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new ib(a)
        }, a.Vertex = function(a, b, c) {
            return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new i(a, b, c)
        }, a.EdgesHelper = function(a, b) {
            return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new hb(new Lb(a.geometry), new fb({
                color: void 0 !== b ? b : 16777215
            }))
        }, a.WireframeHelper = function(a, b) {
            return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new hb(new pb(a.geometry), new fb({
                color: void 0 !== b ? b : 16777215
            }))
        }, a.GeometryUtils = {
            merge: function(a, b, c) {
                console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                var d;
                b.isMesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, b = b.geometry), a.merge(b, d, c)
            },
            center: function(a) {
                return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), a.center()
            }
        }, a.ImageUtils = {
            crossOrigin: void 0,
            loadTexture: function(a, b, c, d) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var e = new gc;
                return e.setCrossOrigin(this.crossOrigin), a = e.load(a, c, void 0, d), b && (a.mapping = b), a
            },
            loadTextureCube: function(a, b, c, d) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var e = new fc;
                return e.setCrossOrigin(this.crossOrigin), a = e.load(a, c, void 0, d), b && (a.mapping = b), a
            },
            loadCompressedTexture: function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            },
            loadCompressedTextureCube: function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            }
        }, a.Projector = function() {
            console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(a, b) {
                console.warn("THREE.Projector: .projectVector() is now vector.project()."), a.project(b)
            }, this.unprojectVector = function(a, b) {
                console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), a.unproject(b)
            }, this.pickingRay = function(a, b) {
                console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
            }
        }, a.CanvasRenderer = function() {
            console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
        }, Object.defineProperty(a, "__esModule", {
            value: !0
        })
    }), THREE.OBJLoader = function(a) {
            this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager, this.materials = null, this.regexp = {
                vertex_pattern: /^v\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
                normal_pattern: /^vn\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
                uv_pattern: /^vt\s+([\d|\.|\+|\-|e|E]+)\s+([\d|\.|\+|\-|e|E]+)/,
                face_vertex: /^f\s+(-?\d+)\s+(-?\d+)\s+(-?\d+)(?:\s+(-?\d+))?/,
                face_vertex_uv: /^f\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+))?/,
                face_vertex_uv_normal: /^f\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)\s+(-?\d+)\/(-?\d+)\/(-?\d+)(?:\s+(-?\d+)\/(-?\d+)\/(-?\d+))?/,
                face_vertex_normal: /^f\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)\s+(-?\d+)\/\/(-?\d+)(?:\s+(-?\d+)\/\/(-?\d+))?/,
                object_pattern: /^[og]\s*(.+)?/,
                smoothing_pattern: /^s\s+(\d+|on|off)/,
                material_library_pattern: /^mtllib /,
                material_use_pattern: /^usemtl /
            }
        }, THREE.OBJLoader.prototype = {
            constructor: THREE.OBJLoader,
            load: function(a, b, c, d) {
                var e = this;
                if (ya) fs = require("fs"), fs.readFile(a, "utf8", function(a, c) {
                    return a ? console.log(a) : void b(e.parse(c))
                });
                else {
                    var f = new THREE.XHRLoader(e.manager);
                    f.setPath(this.path), f.load(a, function(a) {
                        b(e.parse(a))
                    }, c, d)
                }
            },
            setPath: function(a) {
                this.path = a
            },
            setMaterials: function(a) {
                this.materials = a
            },
            _createParserState: function() {
                var a = {
                    objects: [],
                    object: {},
                    vertices: [],
                    normals: [],
                    uvs: [],
                    materialLibraries: [],
                    startObject: function(a, b) {
                        if (this.object && this.object.fromDeclaration === !1) return this.object.name = a, void(this.object.fromDeclaration = b !== !1);
                        this.object && "function" == typeof this.object._finalize && this.object._finalize();
                        var c = this.object && "function" == typeof this.object.currentMaterial ? this.object.currentMaterial() : void 0;
                        if (this.object = {
                                name: a || "",
                                fromDeclaration: b !== !1,
                                geometry: {
                                    vertices: [],
                                    normals: [],
                                    uvs: []
                                },
                                materials: [],
                                smooth: !0,
                                startMaterial: function(a, b) {
                                    var c = this._finalize(!1);
                                    c && (c.inherited || c.groupCount <= 0) && this.materials.splice(c.index, 1);
                                    var d = {
                                        index: this.materials.length,
                                        name: a || "",
                                        mtllib: Array.isArray(b) && b.length > 0 ? b[b.length - 1] : "",
                                        smooth: void 0 !== c ? c.smooth : this.smooth,
                                        groupStart: void 0 !== c ? c.groupEnd : 0,
                                        groupEnd: -1,
                                        groupCount: -1,
                                        inherited: !1,
                                        clone: function(a) {
                                            return {
                                                index: "number" == typeof a ? a : this.index,
                                                name: this.name,
                                                mtllib: this.mtllib,
                                                smooth: this.smooth,
                                                groupStart: this.groupEnd,
                                                groupEnd: -1,
                                                groupCount: -1,
                                                inherited: !1
                                            }
                                        }
                                    };
                                    return this.materials.push(d), d
                                },
                                currentMaterial: function() {
                                    if (this.materials.length > 0) return this.materials[this.materials.length - 1]
                                },
                                _finalize: function(a) {
                                    var b = this.currentMaterial();
                                    return b && b.groupEnd === -1 && (b.groupEnd = this.geometry.vertices.length / 3, b.groupCount = b.groupEnd - b.groupStart, b.inherited = !1), a !== !1 && 0 === this.materials.length && this.materials.push({
                                        name: "",
                                        smooth: this.smooth
                                    }), b
                                }
                            }, c && c.name && "function" == typeof c.clone) {
                            var d = c.clone(0);
                            d.inherited = !0, this.object.materials.push(d)
                        }
                        this.objects.push(this.object)
                    },
                    finalize: function() {
                        this.object && "function" == typeof this.object._finalize && this.object._finalize()
                    },
                    parseVertexIndex: function(a, b) {
                        var c = parseInt(a, 10);
                        return 3 * (c >= 0 ? c - 1 : c + b / 3)
                    },
                    parseNormalIndex: function(a, b) {
                        var c = parseInt(a, 10);
                        return 3 * (c >= 0 ? c - 1 : c + b / 3)
                    },
                    parseUVIndex: function(a, b) {
                        var c = parseInt(a, 10);
                        return 2 * (c >= 0 ? c - 1 : c + b / 2)
                    },
                    addVertex: function(a, b, c) {
                        var d = this.vertices,
                            e = this.object.geometry.vertices;
                        e.push(d[a + 0]), e.push(d[a + 1]), e.push(d[a + 2]), e.push(d[b + 0]), e.push(d[b + 1]), e.push(d[b + 2]), e.push(d[c + 0]), e.push(d[c + 1]), e.push(d[c + 2])
                    },
                    addVertexLine: function(a) {
                        var b = this.vertices,
                            c = this.object.geometry.vertices;
                        c.push(b[a + 0]), c.push(b[a + 1]), c.push(b[a + 2])
                    },
                    addNormal: function(a, b, c) {
                        var d = this.normals,
                            e = this.object.geometry.normals;
                        e.push(d[a + 0]), e.push(d[a + 1]), e.push(d[a + 2]), e.push(d[b + 0]), e.push(d[b + 1]), e.push(d[b + 2]), e.push(d[c + 0]), e.push(d[c + 1]), e.push(d[c + 2])
                    },
                    addUV: function(a, b, c) {
                        var d = this.uvs,
                            e = this.object.geometry.uvs;
                        e.push(d[a + 0]), e.push(d[a + 1]), e.push(d[b + 0]), e.push(d[b + 1]), e.push(d[c + 0]), e.push(d[c + 1])
                    },
                    addUVLine: function(a) {
                        var b = this.uvs,
                            c = this.object.geometry.uvs;
                        c.push(b[a + 0]), c.push(b[a + 1])
                    },
                    addFace: function(a, b, c, d, e, f, g, h, i, j, k, l) {
                        var m, n = this.vertices.length,
                            o = this.parseVertexIndex(a, n),
                            p = this.parseVertexIndex(b, n),
                            q = this.parseVertexIndex(c, n);
                        if (void 0 === d ? this.addVertex(o, p, q) : (m = this.parseVertexIndex(d, n), this.addVertex(o, p, m), this.addVertex(p, q, m)), void 0 !== e) {
                            var r = this.uvs.length;
                            o = this.parseUVIndex(e, r), p = this.parseUVIndex(f, r), q = this.parseUVIndex(g, r), void 0 === d ? this.addUV(o, p, q) : (m = this.parseUVIndex(h, r), this.addUV(o, p, m), this.addUV(p, q, m))
                        }
                        if (void 0 !== i) {
                            var s = this.normals.length;
                            o = this.parseNormalIndex(i, s), p = i === j ? o : this.parseNormalIndex(j, s), q = i === k ? o : this.parseNormalIndex(k, s), void 0 === d ? this.addNormal(o, p, q) : (m = this.parseNormalIndex(l, s), this.addNormal(o, p, m), this.addNormal(p, q, m))
                        }
                    },
                    addLineGeometry: function(a, b) {
                        this.object.geometry.type = "Line";
                        for (var c = this.vertices.length, d = this.uvs.length, e = 0, f = a.length; e < f; e++) this.addVertexLine(this.parseVertexIndex(a[e], c));
                        for (var g = 0, f = b.length; g < f; g++) this.addUVLine(this.parseUVIndex(b[g], d))
                    }
                };
                return a.startObject("", !1), a
            },
            parse: function(a) {
                console.time("OBJLoader");
                var b = this._createParserState();
                a.indexOf("\r\n") !== -1 && (a = a.replace("\r\n", "\n"));
                for (var c = a.split("\n"), d = "", e = "", f = "", g = 0, h = [], i = "function" == typeof "".trimLeft, j = 0, k = c.length; j < k; j++)
                    if (d = c[j], d = i ? d.trimLeft() : d.trim(), g = d.length, 0 !== g && (e = d.charAt(0), "#" !== e))
                        if ("v" === e)
                            if (f = d.charAt(1), " " === f && null !== (h = this.regexp.vertex_pattern.exec(d))) b.vertices.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3]));
                            else if ("n" === f && null !== (h = this.regexp.normal_pattern.exec(d))) b.normals.push(parseFloat(h[1]), parseFloat(h[2]), parseFloat(h[3]));
                else {
                    if ("t" !== f || null === (h = this.regexp.uv_pattern.exec(d))) throw new Error("Unexpected vertex/normal/uv line: '" + d + "'");
                    b.uvs.push(parseFloat(h[1]), parseFloat(h[2]))
                } else if ("f" === e)
                    if (null !== (h = this.regexp.face_vertex_uv_normal.exec(d))) b.addFace(h[1], h[4], h[7], h[10], h[2], h[5], h[8], h[11], h[3], h[6], h[9], h[12]);
                    else if (null !== (h = this.regexp.face_vertex_uv.exec(d))) b.addFace(h[1], h[3], h[5], h[7], h[2], h[4], h[6], h[8]);
                else if (null !== (h = this.regexp.face_vertex_normal.exec(d))) b.addFace(h[1], h[3], h[5], h[7], void 0, void 0, void 0, void 0, h[2], h[4], h[6], h[8]);
                else {
                    if (null === (h = this.regexp.face_vertex.exec(d))) throw new Error("Unexpected face line: '" + d + "'");
                    b.addFace(h[1], h[2], h[3], h[4])
                } else if ("l" === e) {
                    var l = d.substring(1).trim().split(" "),
                        m = [],
                        n = [];
                    if (d.indexOf("/") === -1) m = l;
                    else
                        for (var o = 0, p = l.length; o < p; o++) {
                            var q = l[o].split("/");
                            "" !== q[0] && m.push(q[0]), "" !== q[1] && n.push(q[1])
                        }
                    b.addLineGeometry(m, n)
                } else if (null !== (h = this.regexp.object_pattern.exec(d))) {
                    var r = h[0].substr(1).trim();
                    b.startObject(r)
                } else if (this.regexp.material_use_pattern.test(d)) b.object.startMaterial(d.substring(7).trim(), b.materialLibraries);
                else if (this.regexp.material_library_pattern.test(d)) b.materialLibraries.push(d.substring(7).trim());
                else {
                    if (null === (h = this.regexp.smoothing_pattern.exec(d))) {
                        if ("\0" === d) continue;
                        throw new Error("Unexpected line: '" + d + "'")
                    }
                    var s = h[1].trim().toLowerCase();
                    b.object.smooth = "1" === s || "on" === s;
                    var t = b.object.currentMaterial();
                    t && (t.smooth = b.object.smooth)
                }
                b.finalize();
                var u = new THREE.Group;
                u.materialLibraries = [].concat(b.materialLibraries);
                for (var j = 0, k = b.objects.length; j < k; j++) {
                    var v = b.objects[j],
                        w = v.geometry,
                        x = v.materials,
                        y = "Line" === w.type;
                    if (0 !== w.vertices.length) {
                        var z = new THREE.BufferGeometry;
                        z.addAttribute("position", new THREE.BufferAttribute(new Float32Array(w.vertices), 3)), w.normals.length > 0 ? z.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(w.normals), 3)) : z.computeVertexNormals(), w.uvs.length > 0 && z.addAttribute("uv", new THREE.BufferAttribute(new Float32Array(w.uvs), 2));
                        for (var A = [], B = 0, C = x.length; B < C; B++) {
                            var D = x[B],
                                t = void 0;
                            if (null !== this.materials && (t = this.materials.create(D.name), y && t && !(t instanceof THREE.LineBasicMaterial))) {
                                var E = new THREE.LineBasicMaterial;
                                E.copy(t), t = E
                            }
                            t || (t = y ? new THREE.LineBasicMaterial : new THREE.MeshPhongMaterial, t.name = D.name), t.shading = D.smooth ? THREE.SmoothShading : THREE.FlatShading, A.push(t)
                        }
                        var F;
                        if (A.length > 1) {
                            for (var B = 0, C = x.length; B < C; B++) {
                                var D = x[B];
                                z.addGroup(D.groupStart, D.groupCount, B)
                            }
                            var G = new THREE.MultiMaterial(A);
                            F = y ? new THREE.LineSegments(z, G) : new THREE.Mesh(z, G)
                        } else F = y ? new THREE.LineSegments(z, A[0]) : new THREE.Mesh(z, A[0]);
                        F.name = v.name, u.add(F)
                    }
                }
                return console.timeEnd("OBJLoader"), u
            }
        },
        function() {
            var a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t = {}.hasOwnProperty,
                u = [].indexOf || function(a) {
                    for (var b = 0, c = this.length; b < c; b++)
                        if (b in this && this[b] === a) return b;
                    return -1
                };
            f = {
                is_unordered: !1,
                is_counting: !1,
                is_exclusive: !1,
                is_solitary: !1,
                prevent_default: !1,
                prevent_repeat: !1
            }, r = "meta alt option ctrl shift cmd".split(" "), p = "ctrl", a = {
                debug: !1
            };
            var v = function(a) {
                var b, c;
                for (b in a) t.call(a, b) && (c = a[b], !1 !== c && (this[b] = c));
                this.keys = this.keys || [], this.count = this.count || 0
            };
            v.prototype.allows_key_repeat = function() {
                return !this.prevent_repeat && "function" == typeof this.on_keydown
            }, v.prototype.reset = function() {
                return this.count = 0, this.keyup_fired = null
            };
            var w = function(a, b) {
                var c, d;
                "undefined" != typeof jQuery && null !== jQuery && a instanceof jQuery && (1 !== a.length && o("Warning: your jQuery selector should have exactly one object."), a = a[0]), this.should_force_event_defaults = this.should_suppress_event_defaults = !1, this.sequence_delay = 800, this._registered_combos = [], this._keys_down = [], this._active_combos = [], this._sequence = [], this._sequence_timer = null, this._prevent_capture = !1, this._defaults = b || {};
                for (c in f) t.call(f, c) && (d = f[c], this._defaults[c] = this._defaults[c] || d);
                this.element = a || document.body, c = function(a, b, c) {
                    return a.addEventListener ? a.addEventListener(b, c) : a.attachEvent && a.attachEvent("on" + b, c), c
                };
                var e = this;
                this.keydown_event = c(this.element, "keydown", function(a) {
                    return a = a || window.event, e._receive_input(a, !0), e._bug_catcher(a)
                });
                var g = this;
                this.keyup_event = c(this.element, "keyup", function(a) {
                    return a = a || window.event, g._receive_input(a, !1)
                });
                var h = this;
                this.blur_event = c(window, "blur", function() {
                    var a, b, c, d;
                    for (d = h._keys_down, b = 0, c = d.length; b < c; b++) a = d[b], h._key_up(a, {});
                    return h._keys_down = []
                })
            };
            w.prototype.destroy = function() {
                var a;
                return a = function(a, b, c) {
                    return null != a.removeEventListener ? a.removeEventListener(b, c) : null != a.removeEvent ? a.removeEvent("on" + b, c) : void 0
                }, a(this.element, "keydown", this.keydown_event), a(this.element, "keyup", this.keyup_event), a(window, "blur", this.blur_event)
            }, w.prototype._bug_catcher = function(a) {
                var b, c;
                if ("cmd" === p && 0 <= u.call(this._keys_down, "cmd") && "cmd" !== (b = d(null != (c = a.keyCode) ? c : a.key)) && "shift" !== b && "alt" !== b && "caps" !== b && "tab" !== b) return this._receive_input(a, !1)
            }, w.prototype._cmd_bug_check = function(a) {
                return !("cmd" === p && 0 <= u.call(this._keys_down, "cmd") && 0 > u.call(a, "cmd"))
            }, w.prototype._prevent_default = function(a, b) {
                if ((b || this.should_suppress_event_defaults) && !this.should_force_event_defaults && (a.preventDefault ? a.preventDefault() : a.returnValue = !1, a.stopPropagation)) return a.stopPropagation()
            }, w.prototype._get_active_combos = function(a) {
                var b, c;
                return b = [], c = g(this._keys_down, function(b) {
                    return b !== a
                }), c.push(a), this._match_combo_arrays(c, function(a) {
                    return function(c) {
                        if (a._cmd_bug_check(c.keys)) return b.push(c)
                    }
                }(this)), this._fuzzy_match_combo_arrays(c, function(a) {
                    return function(c) {
                        if (!(0 <= u.call(b, c)) && !c.is_solitary && a._cmd_bug_check(c.keys)) return b.push(c)
                    }
                }(this)), b
            }, w.prototype._get_potential_combos = function(a) {
                var b, c, d, e, f;
                for (c = [], f = this._registered_combos, d = 0, e = f.length; d < e; d++) b = f[d], b.is_sequence || 0 <= u.call(b.keys, a) && this._cmd_bug_check(b.keys) && c.push(b);
                return c
            }, w.prototype._add_to_active_combos = function(a) {
                var b, c, d, e, f, g, h, i, j, k, l;
                if (g = !1, f = !0, d = !1, 0 <= u.call(this._active_combos, a)) return !0;
                if (this._active_combos.length)
                    for (e = h = 0, k = this._active_combos.length; 0 <= k ? h < k : h > k; e = 0 <= k ? ++h : --h)
                        if ((b = this._active_combos[e]) && b.is_exclusive && a.is_exclusive) {
                            if (b = b.keys, !g)
                                for (i = 0, j = b.length; i < j; i++)
                                    if (c = b[i], g = !0, 0 > u.call(a.keys, c)) {
                                        g = !1;
                                        break
                                    }
                            if (f && !g)
                                for (l = a.keys, i = 0, j = l.length; i < j; i++)
                                    if (c = l[i], f = !1, 0 > u.call(b, c)) {
                                        f = !0;
                                        break
                                    }
                            g && (d ? (b = this._active_combos.splice(e, 1)[0], null != b && b.reset()) : (b = this._active_combos.splice(e, 1, a)[0], null != b && b.reset(), d = !0), f = !1)
                        }
                return f && this._active_combos.unshift(a), g || f
            }, w.prototype._remove_from_active_combos = function(a) {
                var b, c, d, e;
                for (c = d = 0, e = this._active_combos.length; 0 <= e ? d < e : d > e; c = 0 <= e ? ++d : --d)
                    if (b = this._active_combos[c], b === a) {
                        a = this._active_combos.splice(c, 1)[0], a.reset();
                        break
                    }
            }, w.prototype._get_possible_sequences = function() {
                var a, b, c, d, e, f, h, i, j, k, l, m;
                for (d = [], k = this._registered_combos, f = 0, j = k.length; f < j; f++)
                    for (a = k[f], b = h = 1, l = this._sequence.length; 1 <= l ? h <= l : h >= l; b = 1 <= l ? ++h : --h)
                        if (e = this._sequence.slice(-b), a.is_sequence) {
                            if (0 > u.call(a.keys, "shift") && (e = g(e, function(a) {
                                    return "shift" !== a
                                }), !e.length)) continue;
                            for (b = i = 0, m = e.length; 0 <= m ? i < m : i > m; b = 0 <= m ? ++i : --i) {
                                if (a.keys[b] !== e[b]) {
                                    c = !1;
                                    break
                                }
                                c = !0
                            }
                            c && d.push(a)
                        }
                return d
            }, w.prototype._add_key_to_sequence = function(a, b) {
                var c, d, e, f;
                if (this._sequence.push(a), d = this._get_possible_sequences(), d.length) {
                    for (e = 0, f = d.length; e < f; e++) c = d[e], this._prevent_default(b, c.prevent_default);
                    this._sequence_timer && clearTimeout(this._sequence_timer), -1 < this.sequence_delay && (this._sequence_timer = setTimeout(function() {
                        return this._sequence = []
                    }, this.sequence_delay))
                } else this._sequence = []
            }, w.prototype._get_sequence = function(a) {
                var b, c, d, e, f, h, i, j, k, l, m, n;
                for (l = this._registered_combos, h = 0, k = l.length; h < k; h++)
                    if (b = l[h], b.is_sequence) {
                        for (c = i = 1, m = this._sequence.length; 1 <= m ? i <= m : i >= m; c = 1 <= m ? ++i : --i)
                            if (f = g(this._sequence, function(a) {
                                    return 0 <= u.call(b.keys, "shift") || "shift" !== a
                                }).slice(-c), b.keys.length === f.length)
                                for (c = j = 0, n = f.length; 0 <= n ? j < n : j > n; c = 0 <= n ? ++j : --j)
                                    if (e = f[c], !(0 > u.call(b.keys, "shift") && "shift" === e || "shift" === a && 0 > u.call(b.keys, "shift"))) {
                                        if (b.keys[c] !== e) {
                                            d = !1;
                                            break
                                        }
                                        d = !0
                                    }
                        if (d) return b.is_exclusive && (this._sequence = []), b
                    }
                return !1
            }, w.prototype._receive_input = function(a, b) {
                var c, e;
                if (this._prevent_capture) this._keys_down.length && (this._keys_down = []);
                else if (c = d(null != (e = a.keyCode) ? e : a.key), (b || this._keys_down.length || !("alt" === c || c === p)) && c) return b ? this._key_down(c, a) : this._key_up(c, a)
            }, w.prototype._fire = function(a, b, c, d) {
                if ("function" == typeof b["on_" + a] && this._prevent_default(c, !0 !== b["on_" + a].call(b.this, c, b.count, d)), "release" === a && (b.count = 0), "keyup" === a) return b.keyup_fired = !0
            }, w.prototype._match_combo_arrays = function(a, d) {
                var e, f, g, h;
                for (h = this._registered_combos, f = 0, g = h.length; f < g; f++) e = h[f], (!e.is_unordered && c(a, e.keys) || e.is_unordered && b(a, e.keys)) && d(e)
            }, w.prototype._fuzzy_match_combo_arrays = function(a, b) {
                var c, d, e, f;
                for (f = this._registered_combos, d = 0, e = f.length; d < e; d++) c = f[d], (!c.is_unordered && j(c.keys, a) || c.is_unordered && i(c.keys, a)) && b(c)
            }, w.prototype._keys_remain = function(a) {
                var b, c, d, e;
                for (e = a.keys, c = 0, d = e.length; c < d; c++)
                    if (a = e[c], 0 <= u.call(this._keys_down, a)) {
                        b = !0;
                        break
                    }
                return b
            }, w.prototype._key_down = function(a, b) {
                var c, d, f, g, h;
                (c = e(a, b)) && (a = c), this._add_key_to_sequence(a, b), (c = this._get_sequence(a)) && this._fire("keydown", c, b);
                for (f in q) c = q[f], b[c] && (f === a || 0 <= u.call(this._keys_down, f) || this._keys_down.push(f));
                for (f in q)
                    if (c = q[f], f !== a && 0 <= u.call(this._keys_down, f) && !b[c] && !("cmd" === f && "cmd" !== p))
                        for (c = d = 0, g = this._keys_down.length; 0 <= g ? d < g : d > g; c = 0 <= g ? ++d : --d) this._keys_down[c] === f && this._keys_down.splice(c, 1);
                for (d = this._get_active_combos(a), f = this._get_potential_combos(a), g = 0, h = d.length; g < h; g++) c = d[g], this._handle_combo_down(c, f, a, b);
                if (f.length)
                    for (d = 0, g = f.length; d < g; d++) c = f[d], this._prevent_default(b, c.prevent_default);
                0 > u.call(this._keys_down, a) && this._keys_down.push(a)
            }, w.prototype._handle_combo_down = function(a, b, c, d) {
                var e, f, g, h, i;
                if (0 > u.call(a.keys, c)) return !1;
                if (this._prevent_default(d, a && a.prevent_default), e = !1, 0 <= u.call(this._keys_down, c) && (e = !0, !a.allows_key_repeat())) return !1;
                if (g = this._add_to_active_combos(a, c), c = a.keyup_fired = !1, a.is_exclusive)
                    for (h = 0, i = b.length; h < i; h++)
                        if (f = b[h], f.is_exclusive && f.keys.length > a.keys.length) {
                            c = !0;
                            break
                        }
                return !c && (a.is_counting && "function" == typeof a.on_keydown && (a.count += 1), g) ? this._fire("keydown", a, d, e) : void 0
            }, w.prototype._key_up = function(a, b) {
                var c, d, f, g, h, i;
                if (c = a, (f = e(a, b)) && (a = f), f = n[c], b.shiftKey ? f && 0 <= u.call(this._keys_down, f) || (a = c) : c && 0 <= u.call(this._keys_down, c) || (a = f), (g = this._get_sequence(a)) && this._fire("keyup", g, b), 0 > u.call(this._keys_down, a)) return !1;
                for (g = h = 0, i = this._keys_down.length; 0 <= i ? h < i : h > i; g = 0 <= i ? ++h : --h)
                    if ((d = this._keys_down[g]) === a || d === f || d === c) {
                        this._keys_down.splice(g, 1);
                        break
                    }
                for (d = this._active_combos.length, f = [], i = this._active_combos, g = 0, h = i.length; g < h; g++) c = i[g], 0 <= u.call(c.keys, a) && f.push(c);
                for (g = 0, h = f.length; g < h; g++) c = f[g], this._handle_combo_up(c, b, a);
                if (1 < d)
                    for (h = this._active_combos, d = 0, g = h.length; d < g; d++) c = h[d], void 0 === c || 0 <= u.call(f, c) || this._keys_remain(c) || this._remove_from_active_combos(c)
            }, w.prototype._handle_combo_up = function(a, c, d) {
                var e, f;
                this._prevent_default(c, a && a.prevent_default), f = this._keys_remain(a), a.keyup_fired || (e = this._keys_down.slice(), e.push(d), a.is_solitary && !b(e, a.keys)) || (this._fire("keyup", a, c), a.is_counting && "function" == typeof a.on_keyup && "function" != typeof a.on_keydown && (a.count += 1)), f || (this._fire("release", a, c), this._remove_from_active_combos(a))
            }, w.prototype.simple_combo = function(a, b) {
                return this.register_combo({
                    keys: a,
                    on_keydown: b
                })
            }, w.prototype.counting_combo = function(a, b) {
                return this.register_combo({
                    keys: a,
                    is_counting: !0,
                    is_unordered: !1,
                    on_keydown: b
                })
            }, w.prototype.sequence_combo = function(a, b) {
                return this.register_combo({
                    keys: a,
                    on_keydown: b,
                    is_sequence: !0,
                    is_exclusive: !0
                })
            }, w.prototype.register_combo = function(a) {
                var b, c, d;
                "string" == typeof a.keys && (a.keys = a.keys.split(" ")), d = this._defaults;
                for (b in d) t.call(d, b) && (c = d[b], void 0 === a[b] && (a[b] = c));
                if (a = new v(a), s(a)) return this._registered_combos.push(a), a
            }, w.prototype.register_many = function(a) {
                var b, c, d, e;
                for (e = [], c = 0, d = a.length; c < d; c++) b = a[c], e.push(this.register_combo(b));
                return e
            }, w.prototype.unregister_combo = function(a) {
                var d, e, f, g, h, i;
                if (!a) return !1;
                var j = this;
                if (e = function(a) {
                        var b, c, d, e;
                        for (e = [], b = c = 0, d = j._registered_combos.length; 0 <= d ? c < d : c > d; b = 0 <= d ? ++c : --c) {
                            if (a === j._registered_combos[b]) {
                                j._registered_combos.splice(b, 1);
                                break
                            }
                            e.push(void 0)
                        }
                        return e
                    }, a instanceof v) return e(a);
                for ("string" == typeof a && (a = a.split(" ")), h = this._registered_combos, i = [], f = 0, g = h.length; f < g; f++) d = h[f], null != d && (d.is_unordered && b(a, d.keys) || !d.is_unordered && c(a, d.keys) ? i.push(e(d)) : i.push(void 0));
                return i
            }, w.prototype.unregister_many = function(a) {
                var b, c, d, e;
                for (e = [], c = 0, d = a.length; c < d; c++) b = a[c], e.push(this.unregister_combo(b));
                return e
            }, w.prototype.get_registered_combos = function() {
                return this._registered_combos
            }, w.prototype.reset = function() {
                return this._registered_combos = []
            }, w.prototype.listen = function() {
                return this._prevent_capture = !1
            }, w.prototype.stop_listening = function() {
                return this._prevent_capture = !0
            }, w.prototype.get_meta_key = function() {
                return p
            }, a.Listener = w, d = function(a) {
                return m[a]
            }, g = function(a, b) {
                var c;
                if (a.filter) return a.filter(b);
                var d, e, f;
                for (f = [], d = 0, e = a.length; d < e; d++) c = a[d], b(c) && f.push(c);
                return f
            }, b = function(a, b) {
                var c, d, e;
                if (a.length !== b.length) return !1;
                for (d = 0, e = a.length; d < e; d++)
                    if (c = a[d], !(0 <= u.call(b, c))) return !1;
                return !0
            }, c = function(a, b) {
                var c, d, e;
                if (a.length !== b.length) return !1;
                for (c = d = 0, e = a.length; 0 <= e ? d < e : d > e; c = 0 <= e ? ++d : --d)
                    if (a[c] !== b[c]) return !1;
                return !0
            }, i = function(a, b) {
                var c, d, e;
                for (d = 0, e = a.length; d < e; d++)
                    if (c = a[d], 0 > u.call(b, c)) return !1;
                return !0
            }, h = Array.prototype.indexOf || function(a, b) {
                var c, d, e;
                for (c = d = 0, e = a.length; 0 <= e ? d <= e : d >= e; c = 0 <= e ? ++d : --d)
                    if (a[c] === b) return c;
                return -1
            }, j = function(a, b) {
                var c, d, e, f;
                for (e = d = 0, f = a.length; e < f; e++) {
                    if (c = a[e], c = h.call(b, c), !(c >= d)) return !1;
                    d = c
                }
                return !0
            }, o = function() {
                if (a.debug) return console.log.apply(console, arguments)
            }, k = function(a) {
                var b, c, d;
                b = !1;
                for (d in m)
                    if (c = m[d], a === c) {
                        b = !0;
                        break
                    }
                if (!b)
                    for (d in n)
                        if (c = n[d], a === c) {
                            b = !0;
                            break
                        }
                return b
            }, s = function(a) {
                var b, c, d, e, g, i, j;
                for (g = !0, a.keys.length || o("You're trying to bind a combo with no keys:", a), c = i = 0, j = a.keys.length; 0 <= j ? i < j : i > j; c = 0 <= j ? ++i : --i) d = a.keys[c], (b = l[d]) && (d = a.keys[c] = b), "meta" === d && a.keys.splice(c, 1, p), "cmd" === d && o('Warning: use the "meta" key rather than "cmd" for Windows compatibility');
                for (j = a.keys, b = 0, i = j.length; b < i; b++) d = j[b], k(d) || (o('Do not recognize the key "' + d + '"'), g = !1);
                if (0 <= u.call(a.keys, "meta") || 0 <= u.call(a.keys, "cmd")) {
                    for (b = a.keys.slice(), i = 0, j = r.length; i < j; i++) d = r[i], -1 < (c = h.call(b, d)) && b.splice(c, 1);
                    1 < b.length && (o("META and CMD key combos cannot have more than 1 non-modifier keys", a, b), g = !1)
                }
                for (e in a) "undefined" === f[e] && o("The property " + e + " is not a valid combo property. Your combo has still been registered.");
                return g
            }, e = function(a, b) {
                var c;
                return !!b.shiftKey && (c = n[a], null != c && c)
            }, q = {
                cmd: "metaKey",
                ctrl: "ctrlKey",
                shift: "shiftKey",
                alt: "altKey"
            }, l = {
                escape: "esc",
                control: "ctrl",
                command: "cmd",
                break: "pause",
                windows: "cmd",
                option: "alt",
                caps_lock: "caps",
                apostrophe: "'",
                semicolon: ";",
                tilde: "~",
                accent: "`",
                scroll_lock: "scroll",
                num_lock: "num"
            }, n = {
                "/": "?",
                ".": ">",
                ",": "<",
                "'": '"',
                ";": ":",
                "[": "{",
                "]": "}",
                "\\": "|",
                "`": "~",
                "=": "+",
                "-": "_",
                1: "!",
                2: "@",
                3: "#",
                4: "$",
                5: "%",
                6: "^",
                7: "&",
                8: "*",
                9: "(",
                0: ")"
            }, m = {
                0: "\\",
                8: "backspace",
                9: "tab",
                12: "num",
                13: "enter",
                16: "shift",
                17: "ctrl",
                18: "alt",
                19: "pause",
                20: "caps",
                27: "esc",
                32: "space",
                33: "pageup",
                34: "pagedown",
                35: "end",
                36: "home",
                37: "left",
                38: "up",
                39: "right",
                40: "down",
                44: "print",
                45: "insert",
                46: "delete",
                48: "0",
                49: "1",
                50: "2",
                51: "3",
                52: "4",
                53: "5",
                54: "6",
                55: "7",
                56: "8",
                57: "9",
                65: "a",
                66: "b",
                67: "c",
                68: "d",
                69: "e",
                70: "f",
                71: "g",
                72: "h",
                73: "i",
                74: "j",
                75: "k",
                76: "l",
                77: "m",
                78: "n",
                79: "o",
                80: "p",
                81: "q",
                82: "r",
                83: "s",
                84: "t",
                85: "u",
                86: "v",
                87: "w",
                88: "x",
                89: "y",
                90: "z",
                91: "cmd",
                92: "cmd",
                93: "cmd",
                96: "num_0",
                97: "num_1",
                98: "num_2",
                99: "num_3",
                100: "num_4",
                101: "num_5",
                102: "num_6",
                103: "num_7",
                104: "num_8",
                105: "num_9",
                106: "num_multiply",
                107: "num_add",
                108: "num_enter",
                109: "num_subtract",
                110: "num_decimal",
                111: "num_divide",
                112: "f1",
                113: "f2",
                114: "f3",
                115: "f4",
                116: "f5",
                117: "f6",
                118: "f7",
                119: "f8",
                120: "f9",
                121: "f10",
                122: "f11",
                123: "f12",
                124: "print",
                144: "num",
                145: "scroll",
                186: ";",
                187: "=",
                188: ",",
                189: "-",
                190: ".",
                191: "/",
                192: "`",
                219: "[",
                220: "\\",
                221: "]",
                222: "'",
                223: "`",
                224: "cmd",
                225: "alt",
                57392: "ctrl",
                63289: "num",
                59: ";",
                61: "=",
                173: "-"
            }, a._keycode_dictionary = m, a._is_array_in_array_sorted = j, -1 !== navigator.userAgent.indexOf("Mac OS X") && (p = "cmd"), -1 !== navigator.userAgent.indexOf("Opera") && (m[17] = "cmd"), "function" == typeof define && define.amd ? define([], function() {
                return a
            }) : "undefined" != typeof exports && null !== exports ? exports.keypress = a : window.keypress = a
        }.call(this);
    var ca = {};
    $b = new Object, ca.entities = $b;
    var da, ea = function(a, b) {
            $b.hasOwnProperty(a) && ($b[a].timeSinceLastUpdate = 0, $b[a].parseDeltaMsg(b))
        },
        fa = function(a) {
            Zb && Zb.id == a && (Zb = void 0), $b.hasOwnProperty(a) && void 0 !== $b[a] && (Zb && Zb.target == $b[a] && (Zb.target = void 0), Ua($b[a]), $b[a].destroyBody(), $b[a] = void 0)
        },
        ga = function() {
            for (e in $b) $b.hasOwnProperty(e) && $b[e] && $b[e].id && fa($b[e].id);
            Zb = void 0
        },
        ha = !1,
        ia = !1,
        ja = !1,
        ka = !1,
        la = !1,
        ma = !1,
        na = function(a) {
            var b = {
                is_unordered: !0,
                prevent_repeat: !0,
                prevent_default: !0
            };
            da = new window.keypress.Listener(document.getElementById("body"), b), $("input[type=text]").bind("focus", function() {
                da.stop_listening()
            }).bind("blur", function() {
                da.listen()
            }), document.onkeyup = function(a) {
                a = a || window.event;
                var b = !1;
                b = "key" in a ? "Escape" == a.key : 27 == a.keyCode, b && Zb && (Zb.target = void 0)
            }, oa()
        },
        oa = function() {
            da.reset(), da.simple_combo(sa.get("toggleHelp"), function() {
                zb ? $("#infoText").fadeToggle("fast") : ($("#infoText").prepend("<h4>Hordes.io <small>alpha</small> </h4>"), $("#infoText").append("<kbd>wasd</kbd> Move <br> <kbd>1-4</kbd> Use spells <br> <kbd>left mouse</kbd> Select target / rotate camera <br><kbd>right mouse</kbd> Rotate character<br><kbd>tab</kbd> Cycle targets<br> <kbd>shift</kbd> Cycle allies</p> Commands:<br><kbd>/bindings</kbd> List of key bindings <br><kbd>/rebind</kbd> Change a key binding <br><kbd>/resetbindings</kbd> Reset bindings to default <br><kbd>/respawn</kbd> Suicide and go back to spawn"), zb = !0)
            }), da.register_combo({
                keys: sa.get("nextAlly"),
                on_keydown: function() {
                    Zb && Lc && (Zb.target = Lc)
                }
            }), da.register_combo({
                keys: sa.get("nextTarget"),
                on_keydown: function() {
                    Zb && Kc && (Zb.target = Kc)
                }
            }), da.register_combo({
                keys: sa.get("walkForward"),
                on_keydown: function() {
                    ja = !0
                },
                on_release: function() {
                    ja = !1
                }
            }), da.register_combo({
                keys: sa.get("walkBackward"),
                on_keydown: function() {
                    ka = !0
                },
                on_release: function() {
                    ka = !1
                }
            }), da.register_combo({
                keys: sa.get("walkRight"),
                on_keydown: function() {
                    ia = !0
                },
                on_release: function() {
                    ia = !1
                }
            }), da.register_combo({
                keys: sa.get("walkLeft"),
                on_keydown: function() {
                    ha = !0
                },
                on_release: function() {
                    ha = !1
                }
            }), da.register_combo({
                keys: sa.get("turnLeft"),
                on_keydown: function() {
                    ma = !0
                },
                on_release: function() {
                    ma = !1
                }
            }), da.register_combo({
                keys: sa.get("turnRight"),
                on_keydown: function() {
                    la = !0
                },
                on_release: function() {
                    la = !1
                }
            }), da.register_combo({
                keys: sa.get("walkForward2"),
                on_keydown: function() {
                    ja = !0
                },
                on_release: function() {
                    ja = !1
                }
            }), da.register_combo({
                keys: sa.get("walkBackward2"),
                on_keydown: function() {
                    ka = !0
                },
                on_release: function() {
                    ka = !1
                }
            }), da.register_combo({
                keys: "f",
                on_keydown: function() {
                    new n({
                        position: Zb.position
                    })
                }
            }), da.simple_combo(sa.get("skill1"), function() {
                Zb && Zb.useSkill(1)
            }), da.simple_combo(sa.get("skill2"), function() {
                Zb && Zb.useSkill(2)
            }), da.simple_combo(sa.get("skill3"), function() {
                Zb && Zb.useSkill(3)
            }), da.simple_combo(sa.get("skill4"), function() {
                Zb && Zb.useSkill(4)
            }), da.simple_combo("enter", function() {
                if (ub.chatboxWrapper) {
                    hb.unLock();
                    var a = ub.chatboxWrapper[0].scrollHeight - ub.chatboxWrapper[0].scrollTop === ub.chatboxWrapper[0].clientHeight;
                    $("#chatInput").show(), $("#chatInput").focus(), a && ub.chatboxWrapper.scrollTop(ub.chatboxWrapper[0].scrollHeight)
                }
            }), $("#skillButtonKbd1").html(sa.get("skill1")), $("#skillButtonKbd2").html(sa.get("skill2")), $("#skillButtonKbd3").html(sa.get("skill3")), $("#skillButtonKbd4").html(sa.get("skill4"))
        },
        pa = !1;
    "undefined" != typeof Storage ? (console.log("Webstorage found. loading settings.."), pa = !0) : console.log("Error: Webstorage not working.");
    var qa = {
            skill1: "1",
            skill2: "2",
            skill3: "3",
            skill4: "4",
            nextTarget: "tab",
            nextAlly: "shift",
            walkForward: "w",
            walkLeft: "a",
            walkRight: "d",
            walkBackward: "s",
            turnLeft: "left",
            turnRight: "right",
            walkForward2: "up",
            walkBackward2: "down",
            toggleHelp: "f1"
        },
        ra = function() {
            this.get = function(a) {
                return this.hasOwnProperty(a) ? this[a] : void 0
            }, this.parse = function(a, b) {
                var c = b;
                return pa && (c = localStorage.getItem(a), c || (c = b)), this[a] = c, c
            }, this.set = function(a, b) {
                return pa && localStorage.setItem(a, b), this[a] = b, b
            }, this.parse("name", void 0), this.parse("faction", void 0), this.parse("class", void 0), this.parse("server", void 0), this.parse("camlock", "true"), this.parse("resolution", "10"), this.parse("skillefx", "true"), this.parse("lastAd", "0"), this.parse("dmgnumbers", "true"), this.parse("nameplates", "true"), this.parse("shadows", "0"), this.parse("grass", "3"), this.parse("chat-loot", "true"), this.parse("chat-chat", "true"), this.parse("chat-exp", "true"), this.parse("chat-pvp", "true");
            for (k in qa) this.parse(k, qa[k])
        },
        sa = new ra,
        ta = function(a) {
            if ("string" != typeof a || a.length <= 0) return !1;
            if ("/" == a[0]) {
                var b = a.split(" ");
                if (b.length <= 0) return !1;
                var c = b.shift().substring(1),
                    e = a.substring(1);
                ua.hasOwnProperty(c) ? ua[c](b, e) : Q({
                    msg: "Unknown command: " + c,
                    src: "system"
                })
            } else d(a, "l")
        },
        ua = {
            respawn: function(a) {
                Q({
                    msg: "Respawning...",
                    src: "system"
                }), Oc.emit("respawn")
            },
            rebind: function(a) {
                return a.length < 2 ? void Q({
                    msg: "Wrong usage. Example: '/rebind skill1 e'. For a list of keybindings, try /bindings",
                    src: "system"
                }) : qa.hasOwnProperty(a[0]) ? (Q({
                    msg: "Changed binding '" + a[0] + "' to: " + a[1],
                    src: "system"
                }), sa.set(a[0], a[1]), void oa()) : void Q({
                    msg: "No such keybinding: '" + a[0] + "'. For a list of keybindings, try /bindings",
                    src: "system"
                })
            },
            resetbindings: function() {
                Q({
                    msg: "Keybindings have been reset to default.",
                    src: "system"
                });
                for (k in qa) sa.set(k, qa[k]);
                oa()
            },
            bindings: function() {
                Q({
                    msg: "List of keybindings: ",
                    src: "system"
                });
                for (k in qa) Q({
                    msg: k + ": " + sa.get(k),
                    src: "system"
                })
            },
            msg: function(a) {
                if (!(a.length < 1)) {
                    if (a.length > 1)
                        for (var b = 2; b < a.length; ++b) a[1] = a[1] + " " + a[b];
                    var c = {};
                    c[a[0]] = a[1] || "", Pc.emit("msg", c)
                }
            },
            global: function(a, b) {
                d(b.substring(6), "g")
            }
        },
        va = void 0,
        wa = void 0,
        xa = 2 * Math.PI,
        ya = !1,
        za = "144.217.80.63",
        Aa = 150;
    h.prototype.tick = function(a) {
        if (!this.stats.isDead()) {
            var b = new THREE.Vector3(0, 0, 0);
            if (b.z = -this.walkForward, b.x = this.walkSideward, b.lengthSq() > 0 && b.normalize(), this.walkForward == -1 && (b.z *= .5, b.x *= .5), b.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.rotation), this.velocity = b, !this.isAi && (0 != this.velocity.x || 0 != this.velocity.y)) {
                var c = b.clone();
                c.normalize();
                var d = .5,
                    e = hc(this.position.x, this.position.z),
                    f = hc(this.position.x + c.x, this.position.z),
                    g = hc(this.position.x, this.position.z + c.z),
                    h = f - e > d ? 0 : 1,
                    i = g - e > d ? 0 : 1;
                this.velocity.x *= h, this.velocity.z *= i
            }
            this.position.x += this.velocity.x * a * this.stats.movespeed, this.position.y += this.velocity.y * a * this.stats.movespeed, this.position.z += this.velocity.z * a * this.stats.movespeed, this.class && this.class.tick && this.class.tick(a), this.stats.tick(a)
        }
        for (; this.rotation < 0;) this.rotation += xa;
        for (; this.rotation > xa;) this.rotation -= xa;
        this.state.tick(a, this)
    }, h.prototype.getDeltaMsg = function() {
        var a = {};
        if (ya || !ya && !this.stats.incapacitated) {
            var b = this.walkForward != this.last.walkForward || this.walkSideward != this.last.walkSideward ? 0 : ya ? this.isAi ? 8 : .5 : .3;
            Ba(this.position, this.last.position, "x", b, a, "x", 1), Ba(this.position, this.last.position, "z", b, a, "z", 1);
            this.isAi || (Ca(this, this.last, "walkForward", a, "wf"), Ca(this, this.last, "walkSideward", a, "ws"), Ba(this, this.last, "rotation", .08, a, "r", 2))
        }
        ya && (Ca(this.state, this.last.state, "id", a, "s"), Ca(this, this.last, "faction", a, "f"), Da(this, this.last, "name", a, "n"), Da(this, this.last, "id", a, "id"), Da(this, this.last, "isAi", a, "ai") && (a.ai = 1 == a.ai ? 1 : 0), this.stats.parseStatChanges(a), Ca(this.class, this.last.class, "level", a, "lvl"), Da(this.class, this.last.class, "type", a, "class"), Da(this.stats, this.last.stats, "invincible", a, "ivc"), Da(this.stats, this.last.stats, "incapacitated", a, "inc"), Da(this.stats, this.last.stats, "stunned", a, "stn"), Da(this, this.last, "combat", a, "cbt"), this.isAi ? (Ca(this.class.ai, this.last.class.ai, "isresetting", a, "rs"), Ba(this.class.ai, this.last.class.ai, "goalx", .1, a, "gx", 1), Ba(this.class.ai, this.last.class.ai, "goalz", .1, a, "gz", 1)) : this.stats.incapacitated && this.lastPositionUpdate.copy(this.position), Da(this.visuals, this.last.visuals, "h", a, "vh")), (ya || this == Zb) && (this.target && this.target.id != this.last.target.id ? Da(this.target, this.last.target, "id", a, "tr") : void 0 == this.target && void 0 != this.last.target.id && (a.tr = "", this.last.target.id = void 0));
        for (var c in this.serverMsgQueue) this.serverMsgQueue.hasOwnProperty(c) && (a[c] = this.serverMsgQueue[c]);
        this.serverMsgQueue = {};
        var d = j(a);
        if (ya) {
            var e = Date.now();
            if (d) {
                if (!(e - this.lastserverheartbeat > 2e3)) return !1;
                this.lastserverheartbeat = e
            } else this.lastserverheartbeat = e
        } else {
            var e = Date.now();
            if (d) {
                if (!(e - this.last.updateTime > 2e3)) return !1;
                this.last.updateTime = e
            } else this.last.updateTime = e
        }
        return a
    }, h.prototype.parseDeltaMsg = function(a) {
        if (ya || !this.isPlayer) {
            var b = new THREE.Vector3;
            if (ya) {
                if (!this.stats.incapacitated && this.ignoreMovement <= 0) {
                    b.copy(this.position);
                    var c = Ea(a, "x", "x", b),
                        d = Ea(a, "z", "z", b);
                    (c || d) && this.verifyPosition(b)
                }
                a.hasOwnProperty("lus") && "number" == typeof a.lus && this.class.skills.hasOwnProperty(a.lus) && this.class.skills[a.lus].tryLevelUp()
            } else if (Ea(a, "x", "x", b) && (this.last.position.x = this.position.x, this.position.x = this.next.position.x, this.next.position.x = b.x), Ea(a, "z", "z", b) && (this.last.position.z = this.position.z, this.position.z = this.next.position.z, this.next.position.z = b.z), this.isAi) {
                Fa(a, "isresetting", "rs", this.class.ai);
                var e = Ea(a, "x", "gx", this.class.ai.goal),
                    f = Ea(a, "z", "gz", this.class.ai.goal);
                (e || f) && (this.class.ai.hasReachedGoal = !1)
            }(!ya || ya && !this.stats.incapacitated) && (Fa(a, "walkForward", "wf", this), Fa(a, "walkSideward", "ws", this), Ea(a, "rotation", "r", this), Ga(a, "queuedAction", "a", this))
        }
        if ((ya || this != Zb) && a.hasOwnProperty("tr") && ("" == a.tr ? (this.target = void 0, ya || (this.desiredTarget = "")) : ca.entities.hasOwnProperty(a.tr) ? (this.target = ca.entities[a.tr], ya || (this.desiredTarget = "")) : ya || (this.desiredTarget = a.tr)), a.hasOwnProperty("ab"))
            for (var g = 0; g < a.ab.length; ++g) !ya && this == Zb && this.class.skills[a.ab[g]].simulate || this.useSkill(a.ab[g], !0);
        if (a.hasOwnProperty("abi"))
            for (var g = 0; g < a.abi.length; ++g) this.class.skills[a.abi[g]] && !this.class.skills[a.abi[g]].ignoreEc && (this.class.skills[a.abi[g]].interruptCast(), this.class.skills[a.abi[g]].interruptChannel());
        if (!ya) {
            if (Ga(a, "invincible", "ivc", this.stats), Ga(a, "incapacitated", "inc", this.stats), Ga(a, "stunned", "stn", this.stats), a.hasOwnProperty("ec"))
                for (var g = 0; g < a.ec.length; ++g) this.class.skills.hasOwnProperty(a.ec[g]) && this.class.skills[a.ec[g]].endCast(!0);
            if (Ga(a, "isAi", "ai", this), Ga(a, "id", "id", this), a.hasOwnProperty("s") && a.s != this.state.id && (this.state = this.parseState(parseInt(a.s))), a.hasOwnProperty("f") && this.updateFaction(a.f), a.hasOwnProperty("n") && (this.name = a.n, this.namesprite && (this.namesprite._text = a.n.substring(0, 20), this.namesprite.updateText())), a.hasOwnProperty("d") && "true" == sa.get("dmgnumbers"))
                for (var g = 0; g < a.d.length; ++g) this.createCombatText(a.d[g], g);
            if (Zb && this.faction == Zb.faction && "true" == sa.get("dmgnumbers") && a.hasOwnProperty("hl"))
                for (var g = 0; g < a.hl.length; ++g) this.createCombatText(a.hl[g], g, !0);
            Fa(a, "h", "vh", this.visuals) && this.updateVisual("h"), Fa(a, "currenthp", "h", this.stats), Fa(a, "maxhp", "mh", this.stats), Ea(a, "servermovespeed", "ms", this.stats);
            var h = this.class.level;
            if (Fa(a, "level", "lvl", this.class)) {
                if (this == Zb && h < this.class.level) {
                    Q({
                        msg: "You have reached level " + this.class.level + "!",
                        src: "system"
                    })
                }
                this.levelsprite._text = this.class.level, this.levelsprite.updateText(), Zb && (this != Zb ? this.canFightPlayer = Ta(this, Zb).canFight() : Gc())
            }
            if (this.isPlayer) {
                Fa(a, "gold", "g", this), a.g && ub.gold.text(a.g), a.gd && Q({
                    msg: (a.gd > 0 ? "Gained " : "Lost ") + Math.abs(a.gd) + " $g",
                    src: "loot"
                }), this.class && a.sl && this.class.skills.hasOwnProperty(a.sl.i) && (this.class.skills[a.sl.i].setLevel(a.sl.l), Bb($("#skillLevelButton" + a.sl.i), a.sl.i), Q({
                    msg: this.class.skills[a.sl.i].name + " raised to ability level " + a.sl.l + "!",
                    src: "system"
                })), a.dexp && Q({
                    msg: (a.dexp > 0 ? "Gained " : "Lost ") + Math.abs(a.dexp) + " experience.",
                    src: "exp"
                });
                var i = Fa(a, "exp", "exp", this.class),
                    j = Fa(a, "nextLevelExp", "nxp", this.class);
                (i || j) && O();
                Fa(a, "fame", "fm", this);
                a.dfm && Q({
                    msg: (parseInt(a.dfm) > 0 ? "Earned " : "Lost ") + Math.abs(a.dfm) + " fame. ( You have " + this.fame + " fame)",
                    src: "exp"
                }), Ea(a, "x", "x", this.serverpos), Ea(a, "z", "z", this.serverpos), this.stats.incapacitated && (this.position.copy(this.serverpos), this.visualPosition.copy(this.position), Fa(a, "walkForward", "wf", this), Fa(a, "walkSideward", "ws", this)), a.hasOwnProperty("r") && Math.abs(y(this.geometry.rotation.y, a.r)) > .9 * Math.PI && (this.rotation = a.r, this.geometry.rotation.y = this.rotation);
                var k = Ea(a, "x", "hrx", this.position),
                    l = Ea(a, "z", "hrz", this.position);
                (k || l) && (this.serverpos.copy(this.position), this.visualPosition.copy(this.position))
            }
            if (a.hasOwnProperty("class") && a.class != this.class.type) {
                var m = this.class ? this.class.nextLevelExp : void 0;
                switch (a.class) {
                    case "warrior":
                        this.class = new I(this.class.level);
                        break;
                    case "shaman":
                        this.class = new L(this.class.level);
                        break;
                    case "mage":
                        this.class = new J(this.class.level);
                        break;
                    case "archer":
                        this.class = new K(this.class.level);
                        break;
                    case "monster":
                        this.class = new F(this.class.level), this.class.ai.class = this.class, this.class.ai.parent = this, this.isAi = !0;
                        break;
                    case "king":
                        this.class = G(), this.class.ai.class = this.class, this.class.ai.parent = this, this.isAi = !0;
                        break;
                    case "warden":
                        this.class = H(), this.class.ai.class = this.class,
                            this.class.ai.parent = this, this.isAi = !0;
                        break;
                    default:
                        console.log("warning: unknown class: " + a.class)
                }
                this.class.stats = this.stats, this.class.parent = this, this.class.initBodyGeometry.call(this), this.class.update(), this.stats.spawn(), this.body.scale.set(this.stats.scale, this.stats.scale, this.stats.scale), this.chest.material = this.class.color, m && (this.class.nextLevelExp = m), ya || this != Zb || (this.class.skills[1].configureUiElements($("#skillIcon1"), $("#skillOverlay1"), $("#skillCooldown1")), this.class.skills[2].configureUiElements($("#skillIcon2"), $("#skillOverlay2"), $("#skillCooldown2")), this.class.skills[3].configureUiElements($("#skillIcon3"), $("#skillOverlay3"), $("#skillCooldown3")), this.class.skills[4].configureUiElements($("#skillIcon4"), $("#skillOverlay4"), $("#skillCooldown4")), this.class.skills[1].setInfoPanel("skill1"), this.class.skills[2].setInfoPanel("skill2"), this.class.skills[3].setInfoPanel("skill3"), this.class.skills[4].setInfoPanel("skill4"))
            }
        }
    }, h.prototype.parseState = function(a) {
        switch (a) {
            case 0:
                return this.chest.material = this.class.color, new u;
            case 2:
                return this.animationQueue[0] = new M({
                    id: "dead",
                    type: "static",
                    duration: 5
                }), ya || this != Zb || (Q({
                    msg: "You have died and lost exp.",
                    src: "death"
                }), $("#deathScreen").fadeIn(400)), new w;
            default:
                return this.state
        }
    };
    var Ba = function(a, b, c, d, e, f, g) {
            return (Math.abs(a[c] - b[c]) > d || void 0 === b[c]) && (e[f] = parseFloat(a[c]).toFixed(g), b[c] = a[c], !0)
        },
        Ca = function(a, b, c, d, e) {
            return a[c] !== b[c] && (d[e] = parseInt(a[c]), b[c] = a[c], !0)
        },
        Da = function(a, b, c, d, e) {
            return a[c] !== b[c] && (d[e] = a[c], b[c] = a[c], !0)
        },
        Ea = function(a, b, c, d) {
            return !!a.hasOwnProperty(c) && (d[b] = parseFloat(a[c]), !0)
        },
        Fa = function(a, b, c, d) {
            return !!a.hasOwnProperty(c) && (d[b] = parseInt(a[c]), !0)
        },
        Ga = function(a, b, c, d) {
            return !!a.hasOwnProperty(c) && (d[b] = a[c], !0)
        },
        Ha = {
            linear: function(a) {
                return a
            },
            easeInQuad: function(a) {
                return a * a
            },
            easeOutQuad: function(a) {
                return a * (2 - a)
            },
            easeInOutQuad: function(a) {
                return a < .5 ? 2 * a * a : -1 + (4 - 2 * a) * a
            },
            easeInCubic: function(a) {
                return a * a * a
            },
            easeOutCubic: function(a) {
                return --a * a * a + 1
            },
            easeInOutCubic: function(a) {
                return a < .5 ? 4 * a * a * a : (a - 1) * (2 * a - 2) * (2 * a - 2) + 1
            },
            easeInQuart: function(a) {
                return a * a * a * a
            },
            easeOutQuart: function(a) {
                return 1 - --a * a * a * a
            },
            easeInOutQuart: function(a) {
                return a < .5 ? 8 * a * a * a * a : 1 - 8 * --a * a * a * a
            },
            easeInQuint: function(a) {
                return a * a * a * a * a
            },
            easeOutQuint: function(a) {
                return 1 + --a * a * a * a * a
            },
            easeInOutQuint: function(a) {
                return a < .5 ? 16 * a * a * a * a * a : 1 + 16 * --a * a * a * a * a
            }
        },
        Ia = function(a) {
            return a[Math.floor(Math.random() * a.length)]
        },
        Ja = {
            g: {
                type: "gold",
                name: "Gold"
            },
            sw: {
                type: "sword",
                name: ["Wooden Sword", "Rusty Ironsword", "Troll Blade", "Broadsword"],
                stats: {
                    mindmg: {
                        multi: 1,
                        low: .8,
                        high: 1
                    },
                    crit: {
                        multi: .5,
                        low: .8,
                        high: 1
                    }
                }
            },
            st: {
                type: "staff",
                name: ["Broken Twig", "Cracked Stick", "Gnarled Broomstick", "Oak Stave"],
                stats: {
                    mindmg: {
                        multi: 1,
                        low: .8,
                        high: 1
                    },
                    crit: {
                        multi: .5,
                        low: .8,
                        high: 1
                    }
                }
            },
            hm: {
                type: "hammer",
                name: ["Splintered Club", "Wooden Mallet", "Rusty Flail", "Orcish Bludgeon"],
                stats: {
                    mindmg: {
                        multi: 1,
                        low: .8,
                        high: 1
                    },
                    crit: {
                        multi: .5,
                        low: .8,
                        high: 1
                    }
                }
            },
            bw: {
                type: "bow",
                name: ["Driftwood Shortbow", "Novice Shortbow", "Curved Shortbow", "Adventurer's Shortbow"],
                stats: {
                    mindmg: {
                        multi: 1,
                        low: .8,
                        high: 1
                    },
                    crit: {
                        multi: .5,
                        low: .8,
                        high: 1
                    }
                }
            },
            ar: {
                type: "armor",
                name: ["Potato Sack", "Faded Garment", "Adventurer's Tunic", "Quilted Leather"],
                stats: {
                    mindmg: {
                        multi: 1,
                        low: .8,
                        high: 1
                    },
                    crit: {
                        multi: .5,
                        low: .8,
                        high: 1
                    }
                }
            }
        },
        Ka = {};
    n.prototype.clientInit = function(a) {
        if (void 0 !== a.x && void 0 !== a.z && void 0 !== a.t && void 0 !== a.i) {
            this.drop = !0, console.log(a), this.position = {
                x: parseFloat(a.x),
                z: parseFloat(a.z)
            }, this.id = a.i, this.type = a.t, this.identifier = Ja[this.type].type, this.name = Ja[this.type].name[a.o], this.spritename = this.identifier + ("g" == this.type ? "" : 1), this.timeout = Date.now() + 1e3 * parseInt(a.m), this.quad = new THREE.Mesh(Cc.items[this.spritename], mc.item), this.quad.position.set(this.position.x, hc(this.position.x, this.position.z) + .1, this.position.z);
            var b = ic(this.position.x, this.position.z);
            b.y < 0 && (b.y *= -1, b.x *= -1, b.z *= -1), b.x += this.quad.position.x, b.y += this.quad.position.y, b.z += this.quad.position.z, this.quad.lookAt(b), this.quad.rotation.z = Math.random() * xa, Rb.add(this.quad), this.quad.entity = this, this.shadow = new THREE.Mesh(Cc.shadow.geo, mc.shadow), this.shadow.scale.set(this.quad.geometry.sh_w, this.quad.geometry.sh_h, 1), this.shadow.position.set(this.position.x, hc(this.position.x, this.position.z) + .03 * Math.random(), this.position.z), this.shadow.rotation.copy(this.quad.rotation), Rb.add(this.shadow)
        }
    }, n.prototype.destroy = function() {
        this.quad && Rb.remove(this.quad), this.shadow && Rb.remove(this.shadow), void 0 !== Ka[this.id] && (Ka[this.id] = void 0, delete Ka[this.id])
    }, n.prototype.tick = function(a, b) {
        nc.push(this.quad), this.timeout < b && this.destroy()
    }, n.prototype.getInfoPanelString = function() {
        return "<div class='targetinfo targettext ally'><span class='targetname'>" + this.name + "</span></div> Item"
    };
    var La = 0;
    n.prototype.requestPickUp = function() {
        var a = Date.now();
        !Zb || a - La < 500 || l(this.position, Zb.position) < 4 && (La = a, Oc.emit("d", {
            i: this.id
        }))
    };
    var Ma = function(a) {
            var b = Date.now(),
                c = 1 + .1 * Math.sin(b / 100);
            mc.item.color.r = c, mc.item.color.g = c, mc.item.color.b = c;
            for (var d in Ka) Ka.hasOwnProperty(d) && Ka[d].tick(a, b)
        },
        Na = {},
        Oa = function(a) {
            console.log(a);
            for (i in a) a[i].del ? Na[i] && delete Na[i] : (Na[i] = a[i], Na[i].name = Ja[a[i].u].name[a[i].t], Na[i].img = Ja[a[i].u].type + "" + a[i].t + ".png");
            Pa()
        },
        Pa = function() {
            var a = $("#inventory-items");
            a.html(""), $.each(Na, function(b) {
                var c = Na[b],
                    d = $("<div/>", {
                        class: "item"
                    }),
                    e = $("<img/>", {
                        class: "itemPic"
                    });
                e.attr("src", "data/items/" + c.img), e.appendTo(d), d.appendTo(a)
            });
            for (var b = 20 - Object.keys(Na).length, c = 0; c < b; ++c) $("<div/>", {
                class: "itemEmpty"
            }).appendTo(a)
        },
        Qa = new Object,
        Ra = function() {
            for (var a in Qa)
                if (void 0 !== Qa[a]) {
                    var b = Qa[a];
                    Va(b.a) && Va(b.b) && (!ya || Wa(b.a, b.b)) ? b.clearIntervalData() : delete Qa[a]
                }
        },
        Sa = function(a, b) {
            return a.id < b.id ? a.id + "," + b.id : b.id + "," + a.id
        },
        Ta = function(a, b) {
            if (void 0 === a || void 0 === b || a == b) return null;
            var c = Sa(a, b);
            return void 0 === Qa[c] && (Qa[c] = new o(a, b)), Qa[c]
        },
        Ua = function(a) {
            for (var b in Qa) void 0 !== Qa[b] && (Qa[b].a != a && Qa[b].b != a || delete Qa[b])
        },
        Va = function(a) {
            if (void 0 == a) return !1;
            if (ya) {
                if (a.isAi ? void 0 == ca.npcs[a.id] : void 0 == ca.players[a.id]) return !1
            } else if (void 0 == ca.entities[a.id]) return !1;
            return !0
        },
        Wa = function(a, b) {
            if (void 0 != a && void 0 != b) {
                var c = getChunkCoord(a.position),
                    d = getChunkCoord(b.position);
                return Math.abs(c.x - d.x) < 2 && Math.abs(c.z - d.z) < 2
            }
        },
        Xa = {};
    Xa.damage = function(a) {
        var b = a.scaledmg || 1,
            c = a.spread || .1,
            d = a.basedmg || 1,
            e = a.attacker || void 0,
            f = a.target || void 0,
            g = a.mode || "single",
            h = a.aoeCenter || void 0,
            i = a.aoeRange || 1,
            j = a.aoeArc || void 0,
            k = a.heal || !1,
            l = a.buff || !1,
            m = a.debuff || !1,
            n = "aoe" == g ? ya ? getChunk(e ? e.position : h).entities : _b : void 0,
            o = a.mod || void 0,
            p = a.aggro || 1,
            q = a.targetFun || void 0,
            r = a.aoeFun || void 0;
        if (e || "aoe" != g || h) {
            var t = [];
            if (!f || e && f.faction != e.faction && !Ta(e, f).canFight() || t.push(f), "aoe" == g && n)
                for (var u = 0; u < n.length; ++u) {
                    var v = n[u];
                    if (!(void 0 === v || v.stats.isDead() || e && (k || l ? v.faction != e.faction : v.faction == e.faction || !Ta(e, v).canFight()))) {
                        if (j && e) {
                            var w = y(e.rotation, A(e.position, v.position));
                            if (Math.abs(w) > j) continue
                        }
                        var x = void 0;
                        x = h ? C(v, h) : v == e ? 0 : Ta(v, e).distance(), void 0 != x && x < i && t.push(v)
                    }
                }
            for (var z = 0; z < t.length; ++z) {
                if (!l && !m) {
                    var B = Math.max(0, (d + e.stats.currentdmg * b) * (1 + (Math.random() - .5) * c));
                    k ? t[z].takeHealing(B, e) : t[z].takeDamage(B, e, p)
                }
                void 0 != o && t[z].stats.addMod(new s(t[z], e, o)), q && q(t[z], e)
            }
            r && r(t, e)
        }
    }, Xa.interrupt = function(a, b) {
        if (Ta(b, a).canFight())
            for (skill in a.class.skills) a.class.skills.hasOwnProperty(skill) && a.class.skills[skill].interruptCast()
    };
    var Ya = [],
        Za = function(a) {
            for (var b = Ya.length; b--;) {
                var c = Ya[b];
                c.tick(a), c.deleteMe && (c.remove(), Ya.splice(b, 1))
            }
        };
    p.prototype.tick = function(a) {
        switch (this.mode) {
            case "attach":
                void 0 === this.target || this.target.stats.isDead() ? this.deleteMe = !0 : (ya && this.position.copy(this.target.position), ya || this.position.copy(this.target.chest.getWorldPosition()));
            case "static":
                this.effectCallback && this.effectInterval > 0 && (this.effectTimer -= a, this.effectTimer < 0 && (this.effectTimer = this.effectInterval, this.effectCallback({
                    spell: this,
                    target: this.target,
                    source: this.source
                }))), "static" == this.mode && this.movedir && (this.position.x += this.movedir.x * this.movespeed * a, this.position.y += this.movedir.y * this.movespeed * a, this.position.z += this.movedir.z * this.movespeed * a);
                break;
            case "follow":
                if (void 0 != this.target) {
                    var b = new THREE.Vector3;
                    ya ? b.subVectors(this.target.position, this.position) : b.subVectors(this.target.chest.getWorldPosition(), this.position);
                    var c = b.lengthSq();
                    c > Math.pow(this.movespeed * a, 2) ? (b.normalize(), b.multiplyScalar(this.movespeed * a), this.position.x += b.x, this.position.z += b.z, this.position.y += b.y) : (this.effectCallback && this.effectCallback({
                        spell: this,
                        target: this.target
                    }), this.deleteMe = !0)
                } else this.deleteMe = !0
        }!ya && this.visualtick && this.visualtick(a), this.timeout > 0 && (this.timeout -= a, this.timeout <= 0 && (this.deleteMe = !0))
    }, p.prototype.remove = function() {
        ya || (X(this.geometry), Rb.remove(this.geometry), this.geometry = void 0, this.ribbonObject && this.ribbon.deleteWithSpell && (this.ribbonObject.deleteMe = !0, this.ribbonObject = void 0))
    }, h.prototype.useSkill = function(a, b) {
        var c = !1;
        if (0 == this.state.id || !ya && b) switch (a) {
            case "test":
            case "sit":
            case "logOut":
                break;
            default:
                if (this.class && this.class.skills.hasOwnProperty(a)) {
                    var d = !0;
                    if (!ya && b && 1 == this.state.id)
                        if (d = !1, this.state.skill.slot != a) this.class.skills[a].interruptCast(), this.state = new u, d = !0;
                        else {
                            var e = this.state.duration / this.state.maxduration;
                            this.state.maxduration += this.state.skill.casttime - this.state.duration, this.state.duration = this.state.maxduration * e
                        }
                    d && this.class.skills[a].cast(ya ? void 0 : b) && (c = !0)
                }
        } else 1 != this.state.id || !ya && b && !(this.state.duration < .5 * this.state.maxduration) || (this.queuedSkill = a);
        (c && ya && (1 == b || this.class.ai) || !ya && this == Zb && !b) && (this.serverMsgQueue.ab || (this.serverMsgQueue.ab = []), this.serverMsgQueue.ab.push(a))
    }, q.prototype.tick = function(a) {
        this.class.parent && (this.parent = this.class.parent), this.isOnCooldown() && (this.cooldowntimer -= a), this.isCasting() ? (this.casttimer -= a, this.casttimer <= 0 ? ya ? this.endCast(!1) : this.casttimer = .01 : ya || this.addCastAnimation(), this.targetIsValid() || ya && this.interruptCast()) : ya || this.removeCastAnimation(), this.isChanneling() && (this.channelTimer -= a, this.channelInterval > 0 && (this.channelIntervalTimer -= a, this.channelIntervalTimer <= 0 && (this.hasChanneledSpell && this.channelspell ? this.channelspell.effectCallback({
            spell: this.channelspell,
            target: this.channelspell.target
        }) : this.confirmEffect(), this.channelIntervalTimer = this.channelInterval)), this.channelTimer <= 0 && (ya || this.removeChannelAnimation()), this.targetIsValid() || (ya || this.ignoreEc) && this.interruptChannel()), !ya && this.uielement && this.updateUiElement()
    }, q.prototype.addCastAnimation = function() {
        this.castAnimationActive || (this.castAnimation.deleteMe = !1, this.castAnimation.timer = 0, this.parent.animationQueue.push(this.castAnimation), this.castAnimationActive = !0)
    }, q.prototype.removeCastAnimation = function() {
        if (this.castAnimationActive) {
            var a = this.parent.animationQueue.indexOf(this.castAnimation);
            a > -1 && this.parent.animationQueue.splice(a, 1), this.castAnimationActive = !1
        }
    }, q.prototype.addChannelAnimation = function() {
        this.channelAnimationActive || (this.channelAnimation.deleteMe = !1, this.channelAnimation.timer = 0, this.parent.animationQueue.push(this.channelAnimation), this.channelAnimationActive = !0)
    }, q.prototype.removeChannelAnimation = function() {
        if (this.channelAnimationActive) {
            var a = this.parent.animationQueue.indexOf(this.channelAnimation);
            a > -1 && this.parent.animationQueue.splice(a, 1), this.channelAnimationActive = !1
        }
    }, q.prototype.cast = function(a) {
        if (this.parent && (a || this.level > 0 && !this.isOnCooldown() && !this.isCasting() && !this.isChanneling())) {
            var b = !1;
            switch (this.casttarget = this.parent.target, this.targettype) {
                case "enemy":
                    b = void 0 !== this.casttarget && this.casttarget.faction != this.parent.faction && !this.casttarget.stats.isDead(), ya || b || this.parent != Zb || !Kc || (Zb.target = Kc);
                    break;
                case "friendly":
                    void 0 != this.casttarget && this.casttarget.faction == this.parent.faction || (this.casttarget = this.parent, this.parent.target = this.parent), b = this.casttarget.faction == this.parent.faction;
                    break;
                case "none":
                    b = !0;
                    break;
                default:
                    console.log("error (" + this.name + "): unknwon target type:" + this.targettype)
            }
            if (b && (!!ya || this.predict) || a) switch (this.casttype) {
                case "timed":
                    return !(!a && !this.targetIsValid()) && (this.startCast(), this.causeGlobalCooldown && this.class.globalCooldown(), !0);
                case "instant":
                    if ("channel" == this.effecttype) {
                        var c = !this.spell || this.confirmEffect(!1);
                        return this.startChannel(), c
                    }
                    return this.confirmEffect(!1)
            }
        }
        return !1
    }, q.prototype.targetIsValid = function() {
        if ("none" != this.targettype && void 0 != this.casttarget) {
            if (!this.allowDeadTarget && this.casttarget.stats.isDead()) return !1;
            if ("enemy" == this.targettype && this.parent != this.casttarget && !Ta(this.parent, this.casttarget).canFight()) return !1;
            var a = this.parent != this.casttarget ? Ta(this.parent, this.casttarget).distance() : 0;
            return a <= (this.isCasting() ? 1.1 * this.maxrange : this.maxrange) + (ya ? 1.5 : 1.3)
        }
        return !0
    }, q.prototype.confirmEffect = function(a) {
        if (ya || this.removeCastAnimation(), this.effect && this.targetIsValid()) {
            if (this.cooldowntimer = Math.max(this.cooldown, this.cooldowntimer), this.causeGlobalCooldown && this.class.globalCooldown(), this.spell) {
                var b = this.spell(this.casttarget, this.parent, this.effectWrapper);
                b && Ya.push(b), this.hasChanneledSpell && (this.channelspell = b), this.unique && (void 0 != this.oldspell && (this.oldspell.deleteMe = !0), this.oldspell = b)
            } else this.effectWrapper({
                isParse: a
            });
            return this.simulate == !a && !ya && "channel" != this.effecttype && this.parent && this.parent.animationQueue.push(this.getCharacterAnim()), !0
        }
        return !1
    }, q.prototype.endCast = function(a) {
        ya ? (this.parent.serverMsgQueue.ec || (this.parent.serverMsgQueue.ec = []), this.parent.serverMsgQueue.ec.push(this.slot), this.parent.addPersonalMessage("ec", this.slot)) : this.casttimer <= .1 * this.casttime && (this.casttimer = -1);
        var b = !1;
        void 0 != this.casttarget && (this.parent.target != this.casttarget || ya && !this.targetIsValid()) ? this.interruptCast() : (b = !0, this.confirmEffect(a)), "channel" == this.effecttype && b && this.startChannel()
    }, q.prototype.interruptCast = function() {
        ya || this.removeCastAnimation(), ya && this.parent && this.parent.addServerMessage("abi", this.slot), this.casttimer = -1
    }, q.prototype.interruptChannel = function() {
        ya || this.removeChannelAnimation(), ya && this.parent && this.parent.addServerMessage("abi", this.slot), this.channelspell && (this.channelspell.deleteMe = !0, this.channelspell = void 0), this.channelTimer = -1
    }, q.prototype.isCasting = function() {
        return this.casttimer > 0
    }, q.prototype.isOnCooldown = function() {
        return this.cooldowntimer > 0
    }, q.prototype.isChanneling = function() {
        return this.channelTimer > 0
    }, q.prototype.configureUiElements = function(a, b, c) {
        this.uielement = a, this.uielement.attr("src", this.icon), this.uielementOverlay = b, this.uielementCooldown = c, this.uielementOverlay.addClass("skillOverlayDisable"), this.uielementCooldown.css("display", "none")
    }, q.prototype.updateUiElement = function() {
        if (this.uielement) {
            if (this.level > 0) {
                var a = this.isOnCooldown();
                if (this.oldIsOnCooldown != a && (this.oldIsOnCooldown = a, this.uielementOverlay.css("display", a ? "block" : "none"), this.uielementCooldown.css("display", a ? "block" : "none")), a) {
                    var b = this.cooldowntimer < 10 ? ("" + this.cooldowntimer).substring(0, 3) : parseInt(this.cooldowntimer);
                    this.uielementCooldown.html(b)
                }
            }
            if (this.oldCanLevelUp != this.canLevelUp() && (this.oldCanLevelUp = this.canLevelUp(), 1 == this.oldCanLevelUp)) {
                var c = $("#skillLevelButton" + this.slot);
                Bb(c, this.slot), c.fadeIn(1500), c.fadeOut(1500), c.fadeIn(1500), c.fadeOut(1500)
            }
        }
    }, q.prototype.globalCooldown = function(a) {
        this.cooldowntimer = Math.max(this.cooldowntimer, a)
    }, q.prototype.startCast = function() {
        this.casttimer = this.casttime;
        this.parent.state = new v({
            skill: this,
            casttime: this.casttime,
            activeCheck: this.isCasting,
            interrupt: this.interruptCast
        }), ya || (this.removeCastAnimation(), this.addCastAnimation())
    }, q.prototype.startChannel = function() {
        this.parent && (this.channelTimer = this.channelDuration, this.channelIntervalTimer = this.channelInterval, this.parent.state = new v({
            skill: this,
            casttime: this.channelTimer,
            activeCheck: this.isChanneling,
            interrupt: this.interruptChannel
        }), this.channelInstantFirstTick && (this.hasChanneledSpell ? this.channelspell && this.channelspell.effectCallback({
            spell: this.channelspell,
            target: this.channelspell.target
        }) : this.confirmEffect()), ya || (this.removeChannelAnimation(), this.addChannelAnimation(), this.onCastFun && this.onCastFun()))
    }, q.prototype.setInfoPanel = function(a) {
        var b = this;
        wb[a] = function() {
            var a = "<h5 class='skillName'>" + b.name + "<small> " + b.casttype + " cast </small></h5><p class='skillDescription'>" + b.description + "</p><p class='skillLvlInfo'>" + parseInt(100 * b.abilitypower) + "% ability effect <br> Level: " + b.level + " <br>Cost to increase level: " + b.nextLevelCost + " " + vb.goldCoin + "</p>";
            return a
        }
    }, q.prototype.setLevel = function(a) {
        var b = this.level;
        this.level = a, this.nextLevelCost = parseInt(Math.pow((a + 1) * (a + 3), 1.9)), this.abilitypower = this.getAbilityPowerAtLevel(a), ya && this.parent && this.parent.addPersonalMessage("sl", {
            i: this.slot,
            l: this.level
        }), !ya && 0 == b && this.level > 0 && Zb && this.parent == Zb && this.uielementOverlay.removeClass("skillOverlayDisable")
    }, q.prototype.canLevelUp = function() {
        return this.parent.gold >= this.nextLevelCost
    }, q.prototype.tryLevelUp = function() {
        return !!this.parent && void(ya ? this.parent.tryModifyGold(-this.nextLevelCost) && this.setLevel(this.level + 1) : this.parent.serverMsgQueue.lus = this.slot)
    }, q.prototype.getAbilityPowerAtLevel = function(a) {
        return .5 + .1 * a
    }, r.prototype.tick = function(a) {
        ya && (this._invincible = !1, this._incapacitated = !1, this._stunned = !1, this._healmod = 1, this.currenthp < this.maxhp && (this.periodicTickTimer -= a), this.periodicTickTimer <= 0 && (this.hpregen < 1 ? (this.periodicTickTimer = 1 / this.hpregen, this.parent.takeHealing(1)) : (this.periodicTickTimer = 1, this.parent.takeHealing(this.hpregen))));
        for (var b = this.mods.length; b--;) this.mods[b].tick(a, this), this.mods[b].deleteMe && this.mods.splice(b, 1);
        ya && (this.invincible = this._invincible, this.incapacitated = this._incapacitated, this.stunned = this._stunned, this.healmod = this._healmod), ya || this.servermovespeed && (this.movespeed = this.servermovespeed)
    }, r.prototype.canBeAttacked = function(a) {
        return !(this.isDead() || a && a.faction == parent.faction)
    }, r.prototype.isDead = function() {
        return 2 == this.parent.state.id || this.currenthp <= 0
    }, r.prototype.spawn = function() {
        this.currenthp = this.maxhp
    }, r.prototype.clearBuffs = function() {
        for (var a = this.mods.length; a--;) this.mods[a].deleteMe = !0
    }, r.prototype.reset = function() {
        this.currenthp = this.maxhp, this.clearBuffs()
    }, r.prototype.addMod = function(a) {
        if ((1 == a.overwrite || 1 == a.unique) && void 0 !== a.id)
            for (m in this.mods) this.mods.hasOwnProperty(m) && this.mods[m].id == a.id && (a.unique ? this.mods[m].deleteMe = !0 : a.overwrite && this.mods[m].source == a.source && (this.mods[m].deleteMe = !0));
        this.mods.push(a)
    }, r.prototype.queryMod = function(a) {
        for (var b = [], c = this.mods.length; c--;) {
            var d = this.mods[c];
            a.source && d.source != a.source || a.id && d.id != a.id || b.push(d)
        }
        return b
    }, s.prototype.tick = function(a, b) {
        this.timer -= a, this.timer <= 0 && (this.deleteMe = !0), this.effectinterval > 0 && void 0 != this.effectfunction && (this.effecttimer -= a, this.effecttimer <= 0 && (this.effectfunction(), this.effecttimer = this.effectinterval)), this.deleteMe || (ya && (this.invincible && (b._invincible = !0), this.incapacitate && (b._incapacitated = !0), this.stun && (b._stunned = !0), this.healmod && (b._healmod = this.healmod(b._healmod))), this.movespeed && (b.movespeed = this.movespeed(b.movespeed)))
    }, u.prototype = new t, u.prototype.constructor = u, v.prototype = new t, v.prototype.constructor = v, w.prototype = new t, w.prototype.constructor = w, E.prototype.skills = {}, E.prototype.getMaxHp = function() {
        return parseInt(.16 * Math.pow(5 + .23 * this.level, 3.95) + 40)
    }, E.prototype.getDmg = function() {
        return parseInt(Math.pow(1.2 + 1.2 * this.level, 1.5))
    }, E.prototype.getMovespeed = function() {
        return 8
    }, E.prototype.getHpRegen = function() {
        return this.getMaxHp() / 200
    }, E.prototype.getDefense = function() {
        return 1
    }, E.prototype.getScale = function() {
        return 1 + .005 * this.level
    }, E.prototype.globalCooldown = function() {
        for (skill in this.skills) this.skills.hasOwnProperty(skill) && this.skills[skill].globalCooldown(1.2)
    }, E.prototype.tick = function(a) {
        this.ai && this.ai.tick(a);
        for (skill in this.skills) this.skills.hasOwnProperty(skill) && this.skills[skill].tick(a);
        this.update()
    }, E.prototype.update = function() {
        ya && this.checkLevelUp(), this.dmg = this.getDmg(), this.maxhp = this.getMaxHp(), this.movespeed = this.getMovespeed(), this.scale = this.getScale(), this.hpregen = this.getHpRegen(), this.defense = this.getDefense(), this.stats.maxhp = this.maxhp, this.stats.currentdmg = this.dmg, this.stats.movespeed = this.movespeed, this.stats.scale = this.scale, this.stats.hpregen = this.hpregen, this.stats.defense = this.defense
    }, E.prototype.isCasting = function() {
        for (skill in this.skills)
            if (this.skills.hasOwnProperty(skill) && (this.skills[skill].isCasting() || this.skills[skill].isChanneling())) return !0;
        return !1
    }, F.prototype = new E, F.prototype.constructor = F, ya || (E.prototype.initBodyGeometry = function() {
        this.weapon = new THREE.Mesh(Cc.generic_sword.geo, mc.generic_sword), this.weapon.scale.set(Cc.generic_sword.scale[0], Cc.generic_sword.scale[1], Cc.generic_sword.scale[2]), this.weapon.rotation.z = .5, Rb.add(this.weapon), this.weapon.position.set(0, 0, .7), this.chest.add(this.weapon)
    }, E.prototype.tickClassAnimation = function(a, b) {
        switch (a) {
            case "swing_melee":
                var c = Ha.easeInOutQuad(b.timer / b.duration),
                    d = .5 * -Math.PI + Math.PI * c;
                this.weapon.rotation.set(.5 * Math.PI, 0, d), this.weapon.position.set(1.5 * Math.sin(d), 0, 1.5 * -Math.cos(d));
                break;
            case "spin":
                this.weapon.rotation.set(.5 * Math.PI, 0, 0), this.weapon.position.set(0, 0, -2);
                break;
            default:
            case "idle":
                this.weapon.rotation.set(0, 0, .5), this.weapon.position.set(0, 0, .7)
        }
    }), I.prototype = new E, I.prototype.constructor = I, I.prototype.initBodyGeometry = function() {
        this.weapon = new THREE.Mesh(Cc.warrior_sword.geo, mc.warrior_sword), this.weapon.scale.set(Cc.warrior_sword.scale[0], Cc.warrior_sword.scale[1], Cc.warrior_sword.scale[2]), this.weapon.position.y = .5, this.hands.r.add(this.weapon), this.shield = new THREE.Mesh(Cc.warrior_shield.geo, mc.warrior_sword), this.shield.scale.set(Cc.warrior_shield.scale[0], Cc.warrior_shield.scale[1], Cc.warrior_shield.scale[2]), this.shield.position.x = -.5, this.hands.l.add(this.shield)
    }, I.prototype.tickClassAnimation = function(a, b) {
        if (b) var c = Ha.easeInOutQuint(b.timer / b.duration);
        switch (a) {
            case "swing_melee":
                this.hands.r.position.set(-.5 + c, 2 * c - 1, -1), this.hands.r.lookAt(new THREE.Vector3(0, 0, 0)), this.hands.r.rotation.x -= 1.5, this.hands.r.rotation.z -= 3 * c - 1, this.chest.rotation.set(0, 1 - 3 * c, 0);
                break;
            case "spin":
                this.hands.r.rotation.set(-1.5, 0, 0), this.hands.r.position.z -= .3, this.hands.l.position.z += .2;
                break;
            default:
            case "idle":
                this.hands.l.rotation.z -= .1, this.hands.l.position.y += .1, this.hands.r.rotation.x -= .5, this.hands.r.position.y -= .2, this.hands.r.position.x += .1, this.weapon.rotation.set(0, 0, 0), this.weapon.position.set(0, 1, 0)
        }
    }, J.prototype = new E, J.prototype.constructor = J, J.prototype.initBodyGeometry = function() {
        this.weapon = new THREE.Mesh(Cc.mage_staff.geo, mc.mage_staff), this.weapon.scale.set(Cc.mage_staff.scale[0], Cc.mage_staff.scale[1], Cc.mage_staff.scale[2]), this.weapon.rotation.z = .5, this.weapon.position.set(0, 0, .7), this.chest.add(this.weapon), this.shield = new THREE.Mesh(Cc.mage_shield.geo, mc.mage_shield), this.shield.scale.set(Cc.mage_shield.scale[0], Cc.mage_shield.scale[1], Cc.mage_shield.scale[2]), this.shield.position.x = -.4, this.shield.rotation.x = .25 * Math.PI, this.hands.l.add(this.shield)
    }, J.prototype.tickClassAnimation = function(a, b) {
        switch (a) {
            default:
                case "idle":
        }
    }, K.prototype = new E, K.prototype.constructor = K, K.prototype.initBodyGeometry = function() {
        this.bowcontainer = new THREE.Object3D, this.weapon = new THREE.Mesh(Cc.archer_bow.geo, mc.archer_bow), this.weapon.scale.set(2.5, 2.5, 1.9), this.weapon.rotation.z = .32, this.weapon.position.y = -2, this.bowcontainer.add(this.weapon), this.bowendU = new THREE.Mesh(Cc.archer_bow_end.geo, mc.archer_bowend), this.bowendL = new THREE.Mesh(Cc.archer_bow_end.geo, mc.archer_bowend), this.bowendU.position.x = 3.2, this.bowendL.position.x = -3.2, this.bowendU.position.y = -.7, this.bowendL.position.y = -.7, this.bowendL.scale.set(Cc.archer_bow_end.scale[0], Cc.archer_bow_end.scale[1], Cc.archer_bow_end.scale[2]), this.bowendU.scale.set(Cc.archer_bow_end.scale[0], Cc.archer_bow_end.scale[1], Cc.archer_bow_end.scale[2]), this.bowendL.rotation.z = 2.4, this.bowendU.rotation.z = .7, this.bowcontainer.add(this.bowendU), this.bowcontainer.add(this.bowendL), this.bowcontainer.rotation.z = 1.5, this.bowcontainer.rotation.x = 1.6, this.bowcontainer.position.x = 1.1, this.bowcontainer.position.z = -.1, this.hands.l.add(this.bowcontainer), this.ammo = new THREE.Mesh(Cc.archer_ammo.geo, mc.archer_ammo), this.ammo.position.z = .7, this.ammo.rotation.z = -.4, this.ammo.rotation.x = .16, this.ammo.position.y = -.15, this.ammo.scale.set(Cc.archer_ammo.scale[0], Cc.archer_ammo.scale[1], Cc.archer_ammo.scale[2]), this.chest.add(this.ammo), this.ammo2 = new THREE.Mesh(Cc.archer_ammo2.geo, mc.archer_ammo2), this.ammo2.position.y = .8, this.ammo2.scale.set(Cc.archer_ammo2.scale[0], Cc.archer_ammo2.scale[1], Cc.archer_ammo2.scale[2]), this.ammo.add(this.ammo2)
    }, K.prototype.tickClassAnimation = function(a, b) {
        if (b) {
            var c = Ha.easeInOutQuint(b.timer / b.duration);
            Math.sin(3.14 * c)
        }
        switch (a) {
            case "release_spell":
                var d = 1 - Ha.easeInQuint(b.timer / b.duration);
                this.hands.l.rotation.set(1.5, 2 + .4 * d, 1.5), this.hands.l.position.set(-.2, -.4 + .3 * d, -.8 - .8 * d), this.chest.rotation.y = 0, this.chest.rotation.x = -.2 + .2 * d, this.chest.rotation.z = 0, this.chest.position.z = 0, this.hands.r.position.set(.5 + .2 * d, -.2 + .4 * d, -.9 + (1 - b.timer / b.duration));
                break;
            default:
            case "idle":
                var e = Math.sin(this.chest.cycle + .5 * Math.PI),
                    f = Math.sin(this.legs.cycle);
                this.hands.l.rotation.set(-.2 + .1 * e + .1 * f, -1.4 + .15 * e + .1 * f, .3), this.hands.l.position.set(-.15 - .2 * e - .2 * f, -.3 + .1 * e + .1 * f, -.9 + .1 * f), this.chest.rotation.y = .1, this.chest.rotation.x = -.1 + .1 * e, this.chest.position.z = -.1, this.legs.l.position.z -= .3, this.legs.r.position.z += .1
        }
    }, L.prototype = new E, L.prototype.constructor = L, L.prototype.initBodyGeometry = function() {
        this.weapon = new THREE.Mesh(Cc.shaman_mace1.geo, mc.shaman_mace1), this.weapontop = new THREE.Mesh(Cc.shaman_mace2.geo, mc.shaman_mace2), this.weapon.scale.set(Cc.shaman_mace1.scale[0], Cc.shaman_mace1.scale[1], Cc.shaman_mace1.scale[2]), this.weapontop.scale.set(Cc.shaman_mace2.scale[0], Cc.shaman_mace2.scale[1], Cc.shaman_mace2.scale[2]), this.weapon.position.y = -.5, this.weapontop.position.y = .8, this.hands.r.add(this.weapon), this.weapon.add(this.weapontop), this.shield = new THREE.Mesh(Cc.shaman_shield.geo, mc.shaman_shield), this.shield.scale.set(Cc.shaman_shield.scale[0], Cc.shaman_shield.scale[1], Cc.shaman_shield.scale[2]), this.shield.position.z = .6, this.shield.position.y = .1, this.shield.rotation.z = .25 * Math.PI, this.chest.add(this.shield), this.robe = new THREE.Mesh(Cc.shaman_robe.geo, mc.shaman_robe), this.robe.scale.set(Cc.shaman_robe.scale[0], Cc.shaman_robe.scale[1], Cc.shaman_robe.scale[2]), this.robe.position.z = -.5, this.robe.position.y = -.5, this.chest.add(this.robe)
    }, L.prototype.tickClassAnimation = function(a, b) {
        if (b) {
            Ha.easeInOutQuint(b.timer / b.duration)
        }
        switch (a) {
            default:
                case "idle":
                this.hands.l.rotation.z -= .1,
            this.hands.l.position.y += .1,
            this.hands.r.rotation.x -= 1.3,
            this.hands.r.position.y -= .1,
            this.hands.r.position.x += .1,
            this.weapon.rotation.set(0, 0, 0),
            this.weapon.position.set(0, .2, 0)
        }
    }, h.prototype.updateVisual = function(a) {
        switch (a) {
            case "h":
                switch (this.head && (X(this.head), this.chest.remove(this.head), this.head = void 0), this.visuals.h) {
                    default:
                        case 0:
                        break;
                    case 1:
                            this.head = new THREE.Mesh(eb.helmet.children[0].geometry, mc.metal);
                        break;
                    case 2:
                            this.head = new THREE.Mesh(eb.helmet.children[0].geometry, mc.silver);
                        break;
                    case 3:
                            this.head = new THREE.Mesh(eb.helmet.children[0].geometry, mc.gold);
                        break;
                    case 4:
                            this.head = new THREE.Mesh(eb.crown.children[0].geometry, mc.metal);
                        break;
                    case 5:
                            this.head = new THREE.Mesh(eb.crown.children[0].geometry, mc.silver);
                        break;
                    case 6:
                            this.head = new THREE.Mesh(eb.crown.children[0].geometry, mc.gold)
                }
                this.head && (this.head.position.y = .5, this.head.scale.set(.5, .5, .5), this.chest.add(this.head))
        }
    }, h.prototype.tickAnimations = function(a) {
        if (this.dmgShake > 0)
            if (this.dmgShake -= a, this.dmgShake > .4 && (this.dmgShake = .4), this.dmgShake > 0) {
                var b = this.stats.scale + this.dmgShake * Math.sin(50 * this.dmgShake) * .5;
                this.body.scale.set(b, b, b), this.chest.material = mc.damage
            } else this.body.scale.set(this.stats.scale, this.stats.scale, this.stats.scale), this.chest.material = this.class.color;
        if (this.animationQueue.length > 0) {
            var c = this.animationQueue[0];
            c.tick(a), (c.timer <= 0 || 1 == c.deleteMe) && this.animationQueue.shift()
        }
        this.tickBodyPartAnimations(a)
    }, M.prototype.tick = function(a) {
        "timed" != this.type && "loop" != this.type || (this.timer -= a, this.timer <= 0 && "loop" == this.type && (this.timer = this.duration))
    }, h.prototype.tickBodyPartAnimations = function(a) {
        var b, c = void 0;
        this.animationQueue.length > 0 ? (b = this.animationQueue[0].id, c = this.animationQueue[0]) : b = "idle";
        var d = new THREE.Vector3;
        d.subVectors(this.visualPosition, this.legs.lastVisualPos);
        var e = this.stats.movespeed * a;
        switch (this.walkForward == -1 && (e *= 1.3), b) {
            case "cast":
                this.hands.cycle = c.timer / c.duration * xa;
                var f = Math.sin(this.hands.cycle),
                    g = Math.cos(this.hands.cycle);
                this.chest.rotation.y = -1 + .05 * f, this.chest.rotation.x = -.2 + .03 * f, this.chest.rotation.z = .2 + .02 * g, this.chest.position.y = .2 * f + .3, this.chest.position.z = -.2, this.hands.r.rotation.set(.3 + .2 * f, .2 * f, 0), this.hands.l.rotation.set(.3 + .2 * g, .2 * -g, 0), this.hands.r.position.set(.3 + .1 * f, -.3 + .1 * f, -.75), this.hands.l.position.set(-.2 - .1 * f, -.1 + .1 * g, -.75);
                break;
            case "channel":
                this.hands.cycle = c.timer / c.duration * xa;
                var f = Math.sin(this.hands.cycle),
                    g = Math.cos(this.hands.cycle);
                this.chest.rotation.y = -.2 + .01 * f, this.chest.rotation.x = .3 + .01 * f, this.chest.rotation.z = -.5 + .01 * g, this.chest.position.y = .1 * f + .3, this.chest.position.z = -.2, this.hands.r.rotation.set(.3 + .05 * f, .2 * f, 0), this.hands.l.rotation.set(.3 + .05 * g, .2 * -g, 0), this.hands.r.position.set(.5 + .05 * f, .3 + .1 * g, -.6), this.hands.l.position.set(-.5 + .05 * f, 1 + .05 * f, -.6);
                break;
            case "release_spell":
                var h = Ha.easeOutQuint(1 - c.timer / c.duration);
                this.chest.rotation.y = -1 + h, this.chest.rotation.x = -.2 + .2 * h, this.chest.rotation.z = .2 - .2 * h, this.chest.position.y = .3 - .3 * h, this.chest.position.z = -.2 + .2 * h, this.hands.r.rotation.set(.3 - .3 * h, 0, 0), this.hands.l.rotation.set(.3 - .3 * h, 0, 0), this.hands.r.position.set(.35 + .2 * h, 0, -1), this.hands.l.position.set(-.35 - .2 * h, 0, -1);
                break;
            case "release_buff":
                var h = Ha.easeOutQuint(1 - c.timer / c.duration);
                this.chest.rotation.y = 0, this.chest.rotation.x = 0, this.chest.rotation.z = 0, this.hands.r.rotation.set(1.5 * h, 0, 0), this.hands.l.rotation.set(1.5 * h, 0, 0);
                var i = Math.sin(3 * h);
                this.hands.r.position.set(-.12 - .35 * i, -.1 + .8 * h, -.3 - i), this.hands.l.position.set(.12 + .35 * i, 0 + .8 * h, -.3 - i);
                break;
            case "boost":
                var h = Ha.easeInOutQuart(.5 + .5 * Math.sin(c.timer / c.duration * Math.PI * 2));
                this.chest.rotation.x = .4 * h, this.hands.r.rotation.set(0, 0, 0), this.hands.l.rotation.set(0, 0, 0), this.hands.r.position.set(.6 + .2 * h, .8 * h, -.3), this.hands.l.position.set(-.6 - .2 * h, .8 * h, -.3);
                break;
            case "swing_melee":
                this.hands.r.position.copy(this.weapon.position), this.hands.r.position.multiplyScalar(.5), this.chest.rotation.set(0, c.timer / c.duration * .5, 0);
                break;
            case "spin":
                this.body.rotation.y = c.timer / c.duration * Math.PI * 4, this.chest.position.z = .3, this.hands.l.position.set(-.2, 0, -1), this.hands.r.position.set(.2, 0, -1);
                break;
            case "dead":
                this.chest.material = mc.dead, this.body.rotation.x = -(Math.min(this.state.timer, .8) / .8) * Math.PI * .5, this.state.timer > 2 && this.state.timer < 5 && (this.body.position.y -= a);
                break;
            default:
            case "idle":
                if (this.body.position.set(0, 0, 0), this.body.rotation.set(0, 0, 0), this.chest.position.set(0, 0, 0), this.chest.rotation.set(0, 0, 0), this.walkForward || this.walkSideward) {
                    var j = .6;
                    this.walkForward == -1 && (j = .3);
                    var k = Math.sin(this.legs.cycle);
                    this.hands.l.position.set(-.7 + .2 * Math.sin(2 * this.legs.cycle + 5), -.2 + .3 * Math.sin(this.legs.cycle), -.2 + k * j * 1.5), this.hands.r.position.set(.7 - .2 * Math.sin(2 * this.legs.cycle + 5), -.2 + .3 * -Math.sin(this.legs.cycle), -.2 - k * j * 1.5), this.hands.r.rotation.set(0, .5 + .8 * this.hands.l.position.z, 0), this.hands.l.rotation.set(0, -(.5 + .8 * this.hands.r.position.z), 0)
                } else {
                    this.hands.rotation.y = 0;
                    var f = Math.sin(this.chest.cycle + .5 * Math.PI);
                    this.hands.r.rotation.set(0, .43 - .15 * f, -.3), this.hands.l.rotation.set(0, -.43 + .15 * f, .3), this.hands.l.position.set(-.7, -.3 + .08 * f, -.15 + .1 * f), this.hands.r.position.set(.7, -.3 + .08 * f, -.15 + .1 * f)
                }
        }
        switch (this.legs.cycle > xa ? this.legs.cycle -= xa : this.legs.cycle < 0 && (this.legs.cycle += xa), b) {
            case "spin":
                this.legs.cycle += 10 * a;
            default:
            case "idle":
                if (this.walkForward || this.walkSideward) {
                    var l = .8;
                    this.walkForward == -1 && (l = .3), this.legs.rotation.y = -this.rotation + x(new THREE.Vector2(d.x, d.z)), this.legs.cycle += 1.8 * e / this.stats.scale, this.legs.l.position.set(-.3, Math.max(0, .6 * Math.cos(this.legs.cycle)) + .1, Math.sin(-this.legs.cycle) * l), this.legs.r.position.set(.3, Math.max(0, .6 * Math.cos(this.legs.cycle + Math.PI)) + .1, Math.sin(-this.legs.cycle + Math.PI) * l), this.legs.r.rotation.x = .3 * this.legs.l.position.z, this.legs.l.rotation.x = .3 * this.legs.r.position.z, this.chest.position.y = .1 * Math.cos(2 * this.legs.cycle) + 1.1
                } else switch (this.legs.rotation.y = 0, this.legs.r.rotation.x = 0, this.legs.l.rotation.x = 0, this.chest.cycle += 3 * a, this.chest.cycle > xa && (this.chest.cycle -= xa), this.chest.position.y = .1 * Math.cos(this.chest.cycle) + 1.1, b) {
                    case "cast":
                        this.legs.l.position.set(-.4, .1, -.25), this.legs.r.position.set(.35, .1, .1), this.legs.l.rotation.y = 1, this.legs.r.rotation.y = .5;
                    case "channel":
                        this.legs.l.position.set(-.4, .1, -.6);
                        break;
                    case "release_buff":
                        var h = Ha.easeOutQuint(1 - c.timer / c.duration);
                        this.chest.position.y = 1.2 + .2 * Math.sin(3 + 5 * h);
                        break;
                    default:
                        this.legs.l.position.set(-.45, .1, 0), this.legs.r.position.set(.45, .1, 0), this.legs.r.rotation.y = 0, this.legs.l.rotation.y = 0
                }
                this.legs.lastVisualPos.copy(this.visualPosition)
        }
        this.class && this.class.type && this.class.tickClassAnimation.call(this, b, c)
    };
    var $a = function() {
        Tb && (Tb.setSize(window.innerWidth, window.innerHeight), zc()), ca && (ca.width = window.innerWidth, ca.height = window.innerHeight), Wb && (Wb.aspect = window.innerWidth / window.innerHeight, Wb.updateProjectionMatrix()), Xb && (Xb.left = -window.innerWidth / 2, Xb.right = window.innerWidth / 2, Xb.top = window.innerHeight / 2, Xb.bottom = -window.innerHeight / 2, Xb.updateProjectionMatrix())
    };
    window.addEventListener("resize", $a, !1);
    var _a = new THREE.TextureLoader,
        ab = new THREE.XHRLoader,
        bb = new THREE.OBJLoader,
        cb = {},
        db = {},
        eb = {},
        fb = {},
        gb = {};
    gb.promises = [], gb.compute = function(a) {
        return gb.promises.push(new Promise(function(b, c) {
            a(), b()
        })), gb.promises[gb.promises.length - 1]
    }, gb.loadTexture = function(a) {
        return gb.promises.push(new Promise(function(b, c) {
            _a.load(a, function(c) {
                cb[a.substring(a.lastIndexOf("/") + 1, a.length).replace(/\.[^\/.]+$/, "")] = c, b()
            }, function(a) {}, function(a) {})
        })), gb.promises[gb.promises.length - 1]
    }, gb.loadModel = function(a) {
        return gb.promises.push(new Promise(function(b, c) {
            bb.load(a, function(c) {
                eb[a.substring(a.lastIndexOf("/") + 1, a.length).replace(/\.[^\/.]+$/, "")] = c, b()
            })
        })), gb.promises[gb.promises.length - 1]
    }, gb.loadShader = function(a) {
        return gb.promises.push(new Promise(function(b, c) {
            ab.load(a, function(c) {
                db[a.substring(a.lastIndexOf("/") + 1, a.length)] = c, b()
            })
        })), gb.promises[gb.promises.length - 1]
    }, gb.loadJSON = function(a) {
        return gb.promises.push(new Promise(function(b, c) {
            $.getJSON(a, function(c) {
                fb[a.substring(a.lastIndexOf("/") + 1, a.length).replace(/\.[^\/.]+$/, "")] = c, b()
            })
        })), gb.promises[gb.promises.length - 1]
    }, gb.onFinish = function(a) {
        Promise.all(gb.promises).then(function(b) {
            a && a()
        })
    };
    var hb, ib = [{
            value: 1e18,
            symbol: "E"
        }, {
            value: 1e15,
            symbol: "P"
        }, {
            value: 1e12,
            symbol: "T"
        }, {
            value: 1e9,
            symbol: "G"
        }, {
            value: 1e6,
            symbol: "M"
        }, {
            value: 1e3,
            symbol: "k"
        }],
        jb = /\.0+$|(\.[0-9]*[1-9])0+$/,
        kb = function(a) {
            return 1 == a || "true" == a
        },
        lb = function() {
            var a = this,
                b = Math.PI / 2;
            this.locked = !1, this.lmb = !1, this.rmb = !1, this.cameraX = 0, this.cameraY = 0, this.cameraZoom = 8, this.mouse = new THREE.Vector2, this.mouseOld = new THREE.Vector2, this.mouseElement = void 0, this.lmbLastDownTime = 0, this.lastX = 0, this.lastY = 0, this.mouseMove_unlocked = function(b) {
                a.mouseElement = b.target.getAttribute("data-infopanel"), a.mouse.x = b.clientX / window.innerWidth * 2 - 1, a.mouse.y = 2 * -(b.clientY / window.innerHeight) + 1, mb || (a.lastX = b.x, a.lastY = b.y)
            }, this.mouseMove_locked = function(c) {
                c.preventDefault();
                var d = c.movementX || c.mozMovementX || c.webkitMovementX || 0,
                    e = c.movementY || c.mozMovementY || c.webkitMovementY || 0;
                mb ? (d = c.movementX || c.mozMovementX || c.webkitMovementX || 0, e = c.movementY || c.mozMovementY || c.webkitMovementY || 0) : (d = c.x - a.lastX, e = c.y - a.lastY, a.lastX = c.x, a.lastY = c.y), a.cameraY -= .0023 * d, a.cameraX -= .0016 * e, a.cameraX = Math.max(-b, Math.min(b, a.cameraX))
            }, this.onMouseDown = function(b) {
                if (b.target.dataset.mouselock || a.lmb || a.rmb) {
                    switch (b.button) {
                        case 0:
                            a.lmb = !0, this.lmbLastDownTime = performance.now();
                            break;
                        case 2:
                            a.rmb = !0
                    }
                    return Zb && (a.lmb || a.rmb) && a.tryLock(), !1
                }
            }, this.onMouseUp = function(b) {
                switch (b.button) {
                    case 0:
                        a.lmb = !1, performance.now() - this.lmbLastDownTime < 300 && void 0 != oc && void 0 != Zb && (oc.drop ? oc.requestPickUp() : Zb.target = oc);
                        break;
                    case 2:
                        a.rmb = !1
                }
                return a.lmb || a.rmb || a.unLock(), !1
            }, this.mouseWheelEvent = function(b) {
                if (b.target == Tb.domElement || b.target == document.body) {
                    b.preventDefault();
                    var c = b.wheelDelta ? b.wheelDelta : -b.detail;
                    a.cameraZoom -= c > 0 ? 1 : -1, a.cameraZoom = Math.min(30, Math.max(a.cameraZoom, 3))
                }
            }, document.addEventListener("mousemove", this.mouseMove_unlocked, !1), document.addEventListener("mousedown", this.onMouseDown), document.addEventListener("mouseup", this.onMouseUp), document.addEventListener("mousewheel", this.mouseWheelEvent), document.addEventListener("DOMMouseScroll", this.mouseWheelEvent), this.tryLock = function() {
                if (mb) {
                    var a = document.body;
                    a.requestPointerLock = a.requestPointerLock || a.mozRequestPointerLock || a.webkitRequestPointerLock, a.requestPointerLock()
                } else this.locked = !0, document.addEventListener("mousemove", hb.mouseMove_locked, !1), document.removeEventListener("mousemove", hb.mouseMove_unlocked, !1)
            }, this.unLock = function() {
                mb ? (document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock, document.exitPointerLock()) : (this.locked = !1, document.addEventListener("mousemove", hb.mouseMove_unlocked, !1), document.removeEventListener("mousemove", hb.mouseMove_locked, !1))
            }
        };
    window.oncontextmenu = function() {
        return !1
    };
    var mb = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document;
    if (mb) {
        var nb = document.body,
            ob = function(a) {
                document.pointerLockElement === nb || document.mozPointerLockElement === nb || document.webkitPointerLockElement === nb ? (hb.locked = !0, document.addEventListener("mousemove", hb.mouseMove_locked, !1), document.removeEventListener("mousemove", hb.mouseMove_unlocked, !1)) : (hb.locked = !1, document.addEventListener("mousemove", hb.mouseMove_unlocked, !1), document.removeEventListener("mousemove", hb.mouseMove_locked, !1))
            };
        document.addEventListener("pointerlockchange", ob, !1), document.addEventListener("mozpointerlockchange", ob, !1), document.addEventListener("webkitpointerlockchange", ob, !1)
    } else console.log("ERROR: Your browser does seems to not support the pointer lock API.");
    TargetPanel = function(a, b) {
        var c = $("<div/>", {
            class: "panel panel-default targetPanel"
        });
        c.appendTo(a);
        var d = $("<div/>", {
                class: "targetinfo"
            }).appendTo(c),
            e = $("<p/>", {
                class: "targettext targetname",
                text: ""
            }).appendTo(d),
            f = $("<img/>", {
                class: "factionicon",
                src: "data/factionA.png"
            }).prependTo(e),
            g = $("<span/>").appendTo(e),
            h = $("<p/>", {
                class: "targettext targetlevel",
                text: ""
            }).appendTo(d),
            i = $("<span/>").appendTo(h),
            j = $("<img/>", {
                class: "classicon",
                src: "data/warrior.png"
            }).prependTo(h),
            k = $("<div/>", {
                class: "progress hpbarbg"
            }).appendTo(c),
            l = $("<div/>", {
                class: "progress-bar hpbar",
                role: "progressbar"
            }).appendTo(k),
            m = $("<p/>", {
                class: "targettext targethealthtext",
                text: "1321 / 2384"
            }).appendTo(k);
        this.panel = c, this.name = g, this.icon = f, this.class = j, this.level = i, this.hpbar = l, this.hpbarBg = k, this.hptext = m, this.targetmode = b, this.hp = 0, this.maxhp = 1, this.relationship = "ally", this.lasticon = "", this.lastclass = "", this.hidden = !0, this.panel.hide()
    }, TargetPanel.prototype.update = function(a) {
        if (a.hide) return void(this.hidden || (this.panel.hide(), this.hidden = !0));
        this.hidden && (this.panel.show(), this.hidden = !1);
        var b = !1;
        for (param in a)
            if (a.hasOwnProperty(param)) {
                var c = a[param];
                switch (param) {
                    case "name":
                        c != this.oldname && (this.oldname = c, this.name.text(c), this[param].append(" <span class='targetMode'>" + this.targetmode + "</span>"));
                        break;
                    case "level":
                        this.level.text() != c && this.level.text(c);
                        break;
                    case "relationship":
                        a[param] != this.relationship && (this.relationship = c, this.name.attr("class", "targettext targetname " + this.relationship));
                        break;
                    case "hp":
                    case "maxhp":
                        ("hp" == param && c != this.hp || "maxhp" == param && c != this.maxhp) && (b = !0, this[param] = c);
                        break;
                    case "icon":
                        c != this.lasticon && (this.icon.attr("src", "data/" + c + ".png"), this.lasticon = c);
                        break;
                    case "class":
                        c != this.lastclass && (this.class.attr("src", "data/" + c + ".png"), this.lastclass = c)
                }
            }
        b && (this.hptext.text(this.hp + "/" + this.maxhp), this.hpbar.css("width", Math.round(this.hp / this.maxhp * 100) + "%"))
    };
    var pb = void 0,
        qb = !0,
        rb = void 0,
        sb = function() {
            rb = $("#fpsdisplay"), pb = setInterval(function() {
                qb || rb.text((1e3 / qc).toFixed(1) + " fps")
            }, 200), $("#modal-settings").on("hidden.bs.modal", function(a) {
                Gb("show"), qb = !0
            }), $("#modal-settings").on("show.bs.modal", function(a) {
                Gb("hide"), qb = !1
            }), $("#sys-settings").on("click", function() {
                $("#setting-camlock").prop("checked", "true" == sa.get("camlock")), $("#setting-resolution").val(parseInt(sa.get("resolution"))), $("#setting-skillefx").prop("checked", "true" == sa.get("skillefx")), $("#setting-shadows").val(parseInt(sa.get("shadows"))), $("#setting-grass").val(parseInt(sa.get("grass"))), $("#modal-settings").modal("show")
            }), $("#setting-camlock").on("change", function() {
                sa.set("camlock", this.checked + "")
            }), $("#setting-resolution").on("input change", function() {
                sa.set("resolution", this.value + ""), zc()
            }), $("#setting-skillefx").on("change", function() {
                sa.set("skillefx", this.checked + "")
            }), $("#setting-shadows").on("input change", function() {
                sa.set("shadows", this.value + ""), Ac()
            }), $("#setting-grass").on("change", function() {
                sa.set("grass", this.value + ""), f(T(cb.grassmap.image), Kb.geometry)
            });
            var a = $(".chatsettingbutton");
            a.each(function() {
                var a = $(this).data("chat"),
                    b = kb(sa.get(a));
                b || $(this).addClass("chatsettingdisable")
            })
        },
        tb = {},
        ub = {},
        vb = {
            goldCoin: "<img src='data/coin.png' class='goldCoin'></img>",
            faction1: "<img src='data/factionA.png' class='goldCoin'></img>",
            faction2: "<img src='data/factionB.png' class='goldCoin'></img>"
        },
        wb = {},
        xb = void 0,
        yb = void 0,
        zb = !1;
    createUi = function(a) {
        var b = document.createElement("div");
        document.body.appendChild(b), tb.player = new TargetPanel($("#upperLeftContainer"), "You"), tb.target = new TargetPanel($("#upperLeftContainer"), "Target"), ub.resources = $("<div/>", {
            class: "panel panel-default",
            id: "resources"
        }).appendTo($("#upperLeftContainer"));
        var c = $("<p/>", {
            class: "resourcesText"
        }).appendTo(ub.resources);
        c.html(vb.goldCoin + " <span>0</span>"), ub.gold = $(c).find("span");
        var d = document.createElement("div");
        d.id = "infoText", d.dataset.mouselock = !0, d.innerHTML = "<kbd>f1</kbd> Toggle help <br> ", $("#lowerLeftContainer").prepend(d), ub.help = $(d);
        var e = document.createElement("div");
        e.id = "expBarContainer", e.innerHTML = "<div class='progress' id='expbarprogress'><div class=\"progress-bar\" id='expbar' role=\"progressbar\"></div></div>", b.appendChild(e), ub.expbar = $("#expbar"), ub.expbarcontainer = $(e), ub.expbartext = $("<p/>", {
            class: "progressbartext",
            id: "expbartext"
        }), ub.expbartext.insertAfter(expbar);
        var f = document.createElement("div");
        f.innerHTML = "<div id='skillbar'></div>", b.appendChild(f), ub.skillbar = $("#skillbar"), Ab(1, ub.skillbar), Ab(2, ub.skillbar), Ab(3, ub.skillbar), Ab(4, ub.skillbar), castbarcontainer = document.createElement("div"), castbarcontainer.innerHTML = '<div class=\'progress\'><div class="progress-bar" id=\'castbar\' role="progressbar" style="width:0% padding:0px"> </div> </div>', castbarcontainer.id = "castBarContainer", b.appendChild(castbarcontainer), ub.castbar = $("#castbar"), ub.castbarcontainer = $("#castBarContainer"), b.appendChild(a), ub.infoPanel = $("<div/>", {
            class: "panel panel-default",
            id: "infoPanel"
        }).appendTo($("#infoPanelContainer")), ub.infoPanel.hide(), ub.statistics = $("#statistics"), a.id = "renderer", ub.chatboxBody = $("#chatboxBody"), ub.chatboxWrapper = $("#chatboxWrapper"), ub.chatInput = $("#chatInput"), ub.chatbox = $("#chatbox"), ub.ladder = $("#ladder"), ub.ladderBody = $("#ladder-body"), $("#chatInputForm").submit(function(a) {
            a.preventDefault(), ub.chatInput.hide();
            ta(ub.chatInput.val());
            ub.chatInput.val(""), ub.chatInput.blur()
        }), $("#loginform").submit(function(a) {
            a.preventDefault(), Jb()
        }), $("#loginformbutton").on("click", function(a) {
            a.preventDefault(), Jb()
        });
        var g = $("#classSelection .classChoice");
        g.on("click", function() {
            g.removeClass("active"), $(this).addClass("active"), sa.set("class", $(this).data("class"))
        }), ub.classSelection = g;
        var h = $("#factionSelectionPanel .factionSelect");
        h.on("click", function() {
            h.removeClass("active"), $(this).addClass("active"), sa.set("faction", $(this).data("faction"))
        }), ub.factionSelection = h, ub.sysbar = $("#systembar"), $("#sys-user").on("click", function() {
            $("#serverLoginMessage").hide(), $("#modal-user").modal("show")
        }), $("#modal-user").on("hidden.bs.modal", function(a) {
            Gb("show")
        }), $("#modal-user").on("show.bs.modal", function(a) {
            Gb("hide")
        }), $("#switchIdButton").on("click", function() {
            var a = $("#switchIdField").val();
            a != Sc && "" != a && ($("#serverLoginMessage").hide(), dd($("#switchIdField").val()))
        }), $("#respawnButton").on("click", function() {
            $("#deathScreen").hide(), yb = function() {
                Oc && Oc.emit("confrespawn")
            }, ac()
        });
        var i = $(".chatsettingbutton");
        i.on("click", function() {
            var a = $(this).data("chat"),
                b = !kb(sa.get(a));
            sa.set(a, b), b ? $(this).removeClass("chatsettingdisable") : $(this).addClass("chatsettingdisable")
        }), sb();
        var j = sa.get("faction");
        switch (parseInt(j)) {
            case 0:
            case 1:
                ub.factionSelection.eq(j).click()
        }
        var k = sa.get("class");
        switch (k) {
            case "warrior":
                ub.classSelection.eq(0).click();
                break;
            case "mage":
                ub.classSelection.eq(1).click();
                break;
            case "shaman":
                ub.classSelection.eq(2).click();
                break;
            case "archer":
                ub.classSelection.eq(3).click()
        }
        var l = sa.get("name");
        $("#usernameInputField").val(l), $("#usernameInputField").focus(), $("#loginMenu").fadeIn(500, function() {
            Wc || (Wc = !0, (adsbygoogle = window.adsbygoogle || []).push({}), (adsbygoogle = window.adsbygoogle || []).push({}))
        })
    };
    var Ab = function(a, b) {
            var c = "<div data-infopanel='skill" + a + "' class='skill' id='skillButton" + a + "'><img data-infopanel='skill" + a + "' id='skillIcon" + a + "' src='' class='skillIcon'></img><div data-infopanel='skill" + a + "' id='skillOverlay" + a + "' class='skillOverlay'></div><kbd id='skillButtonKbd" + a + "'data-infopanel='skill" + a + "' class='skillHotkey'>" + sa.get("skill" + a) + "</kbd><p data-infopanel='skill" + a + "' id='skillCooldown" + a + "' class='skillCooldown'></p></div>";
            b.append(c);
            var d = $("#skillButton" + a),
                e = $("<button id='skillLevelButton" + a + "' class='btn skillLvlUpButton'><span class='glyphicon glyphicon-plus'></span></button>");
            d.mouseover(function(b) {
                Bb(e, a), e.stop(!0, !0), e.show()
            }), d.mouseout(function(a) {
                e.stop(!0, !0), e.fadeOut(400)
            }), e.hide(), e.click(function(b) {
                Zb && Zb.class && Zb.class.skills[a].tryLevelUp()
            }).appendTo(d)
        },
        Bb = function(a, b) {
            Zb.class.skills[b].canLevelUp() ? a.removeClass("skillButtonDisabled") : a.addClass("skillButtonDisabled")
        },
        Cb = void 0,
        Db = void 0,
        Eb = !0,
        Fb = !0;
    updateUi = function(a) {
        Fb || (Zb ? (tb.player.update({
            name: Zb.name,
            level: Zb.class.level,
            relationship: "ally",
            hp: Zb.stats.currenthp,
            maxhp: Zb.stats.maxhp,
            icon: 0 == Zb.faction ? "factionA" : "factionB",
            class: Zb.class.type
        }), Zb.target ? tb.target.update({
            name: Zb.target.name,
            level: Zb.target.class.level,
            relationship: Zb.target.faction == Zb.faction ? "ally" : "enemy",
            hp: Zb.target.stats.currenthp,
            maxhp: Zb.target.stats.maxhp,
            icon: 0 == Zb.target.faction ? "factionA" : "factionB",
            class: Zb.target.isAi ? "monster" : Zb.target.class.type
        }) : tb.target.update({
            hide: !0
        })) : (tb.player.update({
            hide: !0
        }), tb.target.update({
            hide: !0
        })), hb.mouseElement == Cb && oc == Db || (Cb = hb.mouseElement, Db = oc, null == hb.mouseElement ? void 0 != oc ? (ub.infoPanel.html(oc.getInfoPanelString()), Eb && (ub.infoPanel.stop(!0, !0), ub.infoPanel.show(), Eb = !1)) : Eb || (ub.infoPanel.stop(!0, !0), ub.infoPanel.fadeOut(1e3), Eb = !0) : wb.hasOwnProperty(hb.mouseElement) ? (ub.infoPanel.html(wb[hb.mouseElement]), Eb && (ub.infoPanel.stop(!0, !0), ub.infoPanel.show(), Eb = !1)) : Eb || (ub.infoPanel.stop(!0, !0), ub.infoPanel.fadeOut(1e3), Eb = !0)))
    };
    var Gb = function(a, b) {
            ub.ladder[a](b), ub.chatbox[a](b), ub.expbarcontainer[a](b), ub.infoPanel[a](b), ub.skillbar[a](b), ub.resources[a](b), ub.help[a](b), ub.statistics[a](b), ub.castbarcontainer[a](b), tb.player.panel[a](b), tb.target.panel[a](b), ub.sysbar[a](b)
        },
        Hb = [{}, {}, {}, {}, {}, {}, {}, {}],
        Ib = function(a, b) {
            var c = $("#laddertable").find("tr").eq(a).find("td");
            void 0 !== b.name && (c[0].innerHTML = "<img class='classicon' src='data/" + b.class + ".png'> " + b.name), void 0 !== b.lvl && (c[1].innerHTML = parseInt(b.lvl)), void 0 !== b.fame && (c[2].innerHTML = "<b>" + parseInt(b.fame) + "</b>"), void 0 !== b.horde && c.attr("class", 1 == parseInt(b.horde) ? "factionB" : "factionA")
        },
        Jb = function() {
            $("#loginMenu").fadeOut(300, function() {
                $("#renderer").fadeOut(300, function() {
                    ac()
                })
            })
        };
    S("//api.adinplay.com/player/v2/HRD/hordes.io/player.min.js", R);
    var Kb, Lb, Mb, Nb, Ob, Pb, Qb, Rb, Sb, Tb, Ub, Vb, Wb, Xb, Yb, Zb, $b, _b, ac = function() {
            var a = "true" !== localStorage.hasBeenVisited;
            !a && Date.now() - parseInt(sa.get("lastAd")) > 3e5 ? adplayer.startPreRoll() : yb(), localStorage.setItem("hasBeenVisited", "true")
        },
        bc = 4,
        cc = 60,
        dc = function() {
            ya || (Pb = T(cb.heightmap.image));
            var a = ya ? heightmap.shape[0] : cb.heightmap.image.width,
                b = ya ? heightmap.shape[1] : cb.heightmap.image.height;
            Mb = a * bc, Nb = 3 * a, Qb = Mb / cc, ya || (cb.detail.wrapS = THREE.RepeatWrapping, cb.detail.wrapT = THREE.RepeatWrapping, cb.detail2.wrapS = THREE.RepeatWrapping, cb.detail2.wrapT = THREE.RepeatWrapping, cb.detail_h.wrapS = THREE.RepeatWrapping, cb.detail_h.wrapT = THREE.RepeatWrapping, mc.terrain = new THREE.RawShaderMaterial({
                uniforms: {
                    map: {
                        value: cb.color
                    },
                    detail: {
                        value: cb.detail
                    },
                    detailHeight: {
                        value: cb.detail_h
                    },
                    detail2: {
                        value: cb.detail2
                    },
                    shadow: {
                        value: Vb.shadow.map
                    },
                    ambient: {
                        value: Ub.color
                    },
                    directional: {
                        value: Vb.color
                    },
                    directionalDir: {
                        value: Vb.position
                    },
                    directionalMVP: {
                        value: new THREE.Matrix4
                    },
                    fogColor: {
                        value: Rb.fog.color
                    },
                    fogDensity: {
                        value: Rb.fog.density
                    },
                    targetCircle: {
                        value: new THREE.Vector4(0, 0, 0, 2)
                    },
                    targetCirclePos: {
                        value: new THREE.Vector2(0, 0)
                    },
                    shadowSize: {
                        value: 0
                    }
                },
                vertexShader: db["terrain.vert"],
                fragmentShader: db["terrain.frag"],
                depthTest: !0,
                depthWrite: !0
            })), Lb = new THREE.PlaneBufferGeometry(Mb, Mb, a - 1, b - 1);
            for (var c = 0; c < a; ++c)
                for (var d = 0; d < b; ++d) {
                    var e = Nb * d + 3 * c;
                    Lb.attributes.position.array[e + 0] = c * bc, Lb.attributes.position.array[e + 2] = d * bc, Lb.attributes.position.array[e + 1] = .15 * (V(c + 1, d + 1).r + V(c - 1, d + 1).r + V(c - 1, d - 1).r + .25 * V(c + 1, d - 1).r)
                }
            Lb.computeFaceNormals(), Lb.computeVertexNormals(), Lb.normalsNeedUpdate = !0, Lb.verticesNeedUpdate = !0, Ob = Lb.attributes.position.array.length, Kb = new THREE.Mesh(Lb, ya ? void 0 : mc.terrain), ya || (Kb.receiveShadow = !0, Kb.castShadow = !1, Rb.add(Kb))
        },
        ec = void 0,
        fc = 0,
        gc = function(a) {
            5e-4 * performance.now();
            Kb.material.uniforms.directionalMVP.value = Vb.shadow.matrix, Vb.shadow.map && (Kb.material.uniforms.shadow.value = Vb.shadow.map.texture), fc > 0 && (fc -= fc * a * 15);
            var b = oc && oc.drop ? oc : Zb ? Zb.target : void 0;
            Zb && b ? (ec != b && (fc = 1), ec = b, oc && oc.drop ? (Kb.material.uniforms.targetCirclePos.value = new THREE.Vector2(b.position.x, b.position.z), Kb.material.uniforms.targetCircle.value.w = 1 + fc, Kb.material.uniforms.targetCircle.value.x = .7, Kb.material.uniforms.targetCircle.value.y = .7, Kb.material.uniforms.targetCircle.value.z = .7) : (Kb.material.uniforms.targetCirclePos.value = new THREE.Vector2(b.visualPosition.x, b.visualPosition.z), Kb.material.uniforms.targetCircle.value.w = b.stats.scale + .2 + fc, Kb.material.uniforms.targetCircle.value.x = b.faction == Zb.faction ? 0 : 1, Kb.material.uniforms.targetCircle.value.y = b.faction == Zb.faction ? 1 : 0, Kb.material.uniforms.targetCircle.value.z = 0)) : Kb.material.uniforms.targetCirclePos.value = new THREE.Vector2(0, 0)
        },
        hc = function(a, b) {
            var c = a / bc,
                d = b / bc,
                e = c % 1,
                f = d % 1;
            0 == e && (c += 1e-10), 0 == f && (d += 1e-10);
            var g, h, i;
            if (g = Nb * Math.ceil(d) + 3 * Math.floor(c), h = Nb * Math.floor(d) + 3 * Math.ceil(c), i = e + f > 1 ? Nb * Math.ceil(d) + 3 * Math.ceil(c) : Nb * Math.floor(d) + 3 * Math.floor(c), g < 0 || h < 0 || i < 0 || g >= Ob || h >= Ob || i >= Ob) return 0;
            var j = lc(jc(g), jc(h), jc(i), a, b);
            return j || 0
        },
        ic = function(a, b) {
            var c = a / bc,
                d = b / bc,
                e = c % 1,
                f = d % 1;
            0 == e && (c += 1e-10), 0 == f && (d += 1e-10);
            var g, h, i;
            if (g = Nb * Math.ceil(d) + 3 * Math.floor(c), h = Nb * Math.floor(d) + 3 * Math.ceil(c), i = e + f > 1 ? Nb * Math.ceil(d) + 3 * Math.ceil(c) : Nb * Math.floor(d) + 3 * Math.floor(c), g < 0 || h < 0 || i < 0 || g >= Ob || h >= Ob || i >= Ob) return 0;
            var j = new THREE.Triangle(kc(g), kc(h), kc(i));
            return j.normal()
        },
        jc = function(a) {
            return {
                x: Lb.attributes.position.array[a],
                y: Lb.attributes.position.array[a + 1],
                z: Lb.attributes.position.array[a + 2]
            }
        },
        kc = function(a) {
            return new THREE.Vector3(Lb.attributes.position.array[a], Lb.attributes.position.array[a + 1], Lb.attributes.position.array[a + 2])
        },
        lc = function(a, b, c, d, e) {
            var f = (b.z - c.z) * (a.x - c.x) + (c.x - b.x) * (a.z - c.z),
                g = ((b.z - c.z) * (d - c.x) + (c.x - b.x) * (e - c.z)) / f,
                h = ((c.z - a.z) * (d - c.x) + (a.x - c.x) * (e - c.z)) / f,
                i = 1 - g - h;
            return g * a.y + h * b.y + i * c.y
        },
        mc = {},
        nc = [],
        oc = void 0,
        pc = 0,
        qc = 0,
        rc = 10,
        sc = function() {
            na(Tb.domElement), hb = new lb, Rb = new THREE.Scene, Sb = new THREE.Scene, Yb = new THREE.Raycaster, Rb.fog = new THREE.FogExp2(6664656, .008), Tb.setClearColor(9561076), Wb = new THREE.PerspectiveCamera(75, 0, .1, 1e3), Rb.add(Wb), Xb = new THREE.OrthographicCamera(1, 1, 1, 1, 1, 10), Xb.position.z = 10, Ub = new THREE.AmbientLight(5012622), Rb.add(Ub), Vb = new THREE.DirectionalLight(10855818, .5), Rb.add(Vb), dc(), f(T(cb.grassmap.image), Kb.geometry), Ac(), $a(), $("#upperLeftContainer").fadeIn(), $("#renderer").fadeIn(1e3), pc = performance.now();
            var a = function() {
                var b = performance.now();
                qc += (b - pc - qc) / rc;
                var c = Math.min((b - pc) / 1e3, .1);
                pc = b, requestAnimationFrame(a), Ra(), Ic = [], Jc = [], _b = [];
                for (var d in $b) _b.push($b[d]);
                void 0 !== Zb && (Zb.playertick(c), Zb.clienttick(c));
                for (var d in $b) $b.hasOwnProperty(d) && void 0 != $b[d] && $b[d] != Zb && $b[d].clienttick(c);
                Rc(), wc(), Za(c), Ma(c), g(c), gc(c), Ec(c), updateUi(c), void 0 == Zb && yc(c), Tb.clear(), Tb.render(Rb, Wb), Tb.clearDepth(), Tb.render(Sb, Xb)
            };
            a()
        },
        tc = function() {
            var a = {
                w: cb.items.image.width,
                h: cb.items.image.height
            };
            Cc.items = {};
            for (var b in fb.items.frames) {
                var c = fb.items.frames[b].frame,
                    d = (c.rotated ? c.h : c.w) / a.w,
                    e = (c.rotated ? c.w : c.h) / a.h,
                    f = d / 2,
                    g = c.x / a.w,
                    h = 1 - c.y / a.h - e;
                Cc.items[b] = new THREE.PlaneBufferGeometry(1, 1, 2, 1), Cc.items[b].attributes.uv.array[0] = g, Cc.items[b].attributes.uv.array[1] = h + e, Cc.items[b].attributes.uv.array[2] = g + f, Cc.items[b].attributes.uv.array[3] = h + e, Cc.items[b].attributes.uv.array[4] = g + d, Cc.items[b].attributes.uv.array[5] = h + e, Cc.items[b].attributes.uv.array[6] = g, Cc.items[b].attributes.uv.array[7] = h, Cc.items[b].attributes.uv.array[8] = g + f, Cc.items[b].attributes.uv.array[9] = h, Cc.items[b].attributes.uv.array[10] = g + d, Cc.items[b].attributes.uv.array[11] = h;
                var i = c.w / 35,
                    j = c.h / 35,
                    k = 0;
                switch (b.replace(/[0-9]/g, "")) {
                    default:
                        case "gold":
                        case "bow":
                        k = 0;
                    break;
                    case "sword":
                            k = .2;
                        break;
                    case "armor":
                            case "staff":
                            k = .3
                }
                k *= i, Cc.items[b].sh_w = i + .5, Cc.items[b].sh_h = j + .5, Cc.items[b].attributes.position.array[0] = -i, Cc.items[b].attributes.position.array[1] = j, Cc.items[b].attributes.position.array[3] = 0, Cc.items[b].attributes.position.array[4] = j, Cc.items[b].attributes.position.array[5] = k, Cc.items[b].attributes.position.array[6] = i, Cc.items[b].attributes.position.array[7] = j, Cc.items[b].attributes.position.array[9] = -i, Cc.items[b].attributes.position.array[10] = -j, Cc.items[b].attributes.position.array[12] = 0, Cc.items[b].attributes.position.array[13] = -j, Cc.items[b].attributes.position.array[14] = k, Cc.items[b].attributes.position.array[15] = i, Cc.items[b].attributes.position.array[16] = -j, Cc.items[b].computeFaceNormals(), Cc.items[b].computeVertexNormals(), Cc.items[b].normalsNeedUpdate = !0, Cc.items[b].verticesNeedUpdate = !0
            }
        },
        uc = function() {
            cb.hpbarbg.minFilter = THREE.LinearFilter, cb.hpbarfg.minFilter = THREE.LinearFilter, cb.hpbarbg.magFilter = THREE.LinearFilter, cb.hpbarfg.magFilter = THREE.LinearFilter, cb.items.minFilter = THREE.LinearMipMapLinearFilter, cb.items.magFilter = THREE.LinearMipMapLinearFilter, mc.item = new THREE.MeshBasicMaterial({
                map: cb.items,
                lightMap: cb.items,
                transparent: !0,
                alphaTest: .5,
                color: 6710886,
                side: THREE.DoubleSide,
                shininess: .6,
                specular: 16777215,
                emissive: 1118481
            }), mc.shadow = new THREE.MeshBasicMaterial({
                map: cb.shadow,
                transparent: !0
            }), mc.hpbarbg = new THREE.SpriteMaterial({
                map: cb.hpbarbg,
                color: 16777215
            }), mc.hpbarfriendly = new THREE.SpriteMaterial({
                map: cb.hpbarfg,
                color: 65280
            }), mc.hpbarenemy = new THREE.SpriteMaterial({
                map: cb.hpbarfg,
                color: 16711680
            }), mc.hpbarmob = new THREE.SpriteMaterial({
                map: cb.hpbarfg,
                color: 16147241
            }), mc.factionA = new THREE.SpriteMaterial({
                map: cb.factionA,
                color: 16777215
            }), mc.factionB = new THREE.SpriteMaterial({
                map: cb.factionB,
                color: 16777215
            }), mc.hpbarcantfight = new THREE.SpriteMaterial({
                map: cb.hpbarfg,
                color: 6710886
            }), mc.hpbarbgTransparent = new THREE.SpriteMaterial({
                map: cb.hpbarbg,
                color: 16777215
            }), mc.hpbarfriendlyTransparent = new THREE.SpriteMaterial({
                map: cb.hpbarfg,
                color: 65280
            }), mc.hpbarenemyTransparent = new THREE.SpriteMaterial({
                map: cb.hpbarfg,
                color: 16711680
            }), mc.hpbarmobTransparent = new THREE.SpriteMaterial({
                map: cb.hpbarfg,
                color: 16147241
            }), mc.hpbarcantfightTransparent = new THREE.SpriteMaterial({
                map: cb.hpbarfg,
                color: 6710886
            }), mc.hpbarcantfightTransparent.transparent = !0, mc.hpbarbgTransparent.transparent = !0, mc.hpbarfriendlyTransparent.transparent = !0, mc.hpbarenemyTransparent.transparent = !0, mc.hpbarmobTransparent.transparent = !0, mc.hpbarcantfightTransparent.opacity = .9, mc.hpbarbgTransparent.opacity = .1, mc.hpbarfriendlyTransparent.opacity = .9, mc.hpbarenemyTransparent.opacity = .9, mc.hpbarmobTransparent.opacity = .9, mc.f_vg1 = new THREE.SpriteMaterial({
                map: cb.vg1
            }), mc.f_vg2 = new THREE.SpriteMaterial({
                map: cb.vg2
            }), mc.f_vg3 = new THREE.SpriteMaterial({
                map: cb.vg3
            }), mc.f_bl1 = new THREE.SpriteMaterial({
                map: cb.bl1
            }), mc.f_bl2 = new THREE.SpriteMaterial({
                map: cb.bl2
            }), mc.f_bl3 = new THREE.SpriteMaterial({
                map: cb.bl3
            }), mc.hitbox = new THREE.MeshBasicMaterial({
                visible: !1
            }), mc.ribbon_arrow = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                alphaMap: cb.gradient,
                transparent: !0,
                alphaTest: .15
            }), mc.ribbon_heal = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                map: cb.heal_color,
                alphaMap: cb.heal_alpha,
                transparent: !0,
                alphaTest: .05
            }), mc.ribbon_decay = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                map: cb.decay_color,
                alphaMap: cb.decay_alpha,
                transparent: !0,
                alphaTest: .05
            }), mc.ribbon_leech = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                map: cb.leech_color,
                alphaMap: cb.heal_alpha,
                transparent: !0,
                alphaTest: .2
            }), mc.ribbon_whirlwind = new THREE.MeshBasicMaterial({
                side: THREE.DoubleSide,
                map: cb.swingtest,
                alphaMap: cb.alpha,
                transparent: !0,
                alphaTest: .2
            })
        };
    $(document).ready(function() {
        Tb = new THREE.WebGLRenderer({
            antialias: !0
        }), Tb.autoClear = !1, Tb.domElement.dataset.mouselock = !0, document.body.appendChild(Tb.domElement), createUi(Tb.domElement), Gb("hide"), $("#renderer").hide(), gb.loadTexture("../data/hpbarbg.png"), gb.loadTexture("../data/hpbarfg.png"), gb.loadTexture("../data/efx/gradient.jpg"), gb.loadTexture("../data/efx/heal_alpha.jpg"), gb.loadTexture("../data/efx/heal_color.jpg"), gb.loadTexture("../data/efx/leech_color.jpg"), gb.loadTexture("../data/efx/decay_alpha.jpg"), gb.loadTexture("../data/efx/decay_color.jpg"), gb.loadTexture("../data/efx/swingtest.jpg"), gb.loadTexture("../data/efx/alpha.jpg"), gb.loadTexture("../data/terrain/color.jpg"), gb.loadTexture("../data/terrain/heightmap.jpg"), gb.loadTexture("../data/terrain/grassmap.png"), gb.loadTexture("../data/factionA.png"), gb.loadTexture("../data/factionB.png"), gb.loadTexture("../data/terrain/grass.png"), gb.loadTexture("../data/terrain/detail.jpg"), gb.loadTexture("../data/terrain/detail2.jpg"), gb.loadTexture("../data/terrain/detail_h.jpg"), gb.loadTexture("../data/items/items.png"), gb.loadTexture("../data/efx/shadow.png"), gb.loadShader("script/shader/grass.vert"), gb.loadShader("script/shader/grass.frag"), gb.loadShader("script/shader/terrain.vert"), gb.loadShader("script/shader/terrain.frag"), gb.loadModel("../data/model/crown.obj"), gb.loadModel("../data/model/helmet.obj"), gb.loadJSON("../data/items/items.json"), gb.onFinish(function() {
            uc(), tc(), sc()
        })
    });
    var vc = 0,
        wc = function() {
            if (vc++, null == hb.mouseElement && (vc > 20 || hb.mouseOld.x != hb.mouse.x || hb.mouseOld.y != hb.mouse.y)) {
                vc = 0, hb.mouseOld.copy(hb.mouse), Yb.setFromCamera(hb.mouse, Wb);
                var a = Yb.intersectObjects(nc);
                a.length > 0 ? (oc = a[0].object.entity, document.body.style.cursor = "pointer") : (oc = void 0, document.body.style.cursor = "default"), nc = []
            }
        },
        xc = 0,
        yc = function(a) {
            xc += a;
            var b = new THREE.Vector3(.5 * Mb + Math.sin(.003 * xc) * Mb * .25, 0, .5 * Mb + Math.cos(.003 * xc) * Mb * .25);
            b.y = hc(b.x, b.z) + 2, Wb.position.copy(b), Vb.position.copy(b)
        },
        zc = function() {
            var a = parseInt(sa.get("resolution"));
            "number" == typeof a && (a = Math.max(.1, Math.min(1, .1 * a)), Tb.setPixelRatio(a))
        },
        Ac = function() {
            if ("0" != sa.get("shadows")) {
                Tb.shadowMap.enabled = !0, Tb.shadowMap.type = THREE.PCFSoftShadowMap, Vb.castShadow = !0, Vb.shadow && delete Vb.shadow, Vb.shadow = new THREE.LightShadow(new THREE.OrthographicCamera(-80, 80, 60, -60, .1, 1e5)), Vb.shadow.bias = 1e-4;
                var a = 64;
                switch (parseInt(sa.get("shadows"))) {
                    default:
                        case 1:
                        a = 128;
                    break;
                    case 2:
                            a = 256;
                        break;
                    case 3:
                            a = 512;
                        break;
                    case 3:
                            a = 1024;
                        break;
                    case 4:
                            a = 2048
                }
                Vb.shadow.mapSize.width = a, Vb.shadow.mapSize.height = a, Kb && (Kb.material.uniforms.shadowSize.value = a, Kb.material.uniforms.shadow.value = Vb.shadow.map), mc.foliage && (mc.foliage.uniforms.shadowSize.value = a, mc.foliage.uniforms.shadow.value = Vb.shadow.map)
            } else Tb.shadowMap.enabled = !1, Vb.castShadow = !1, Kb && (Kb.material.uniforms.shadowSize.value = 0, Kb.material.uniforms.shadow.value = void 0), mc.foliage && (mc.foliage.uniforms.shadowSize.value = 0, mc.foliage.uniforms.shadow.value = void 0)
        };
    navigator.sayswho = function() {
        var a, b = navigator.userAgent,
            c = b.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
        return /trident/i.test(c[1]) ? (a = /\brv[ :]+(\d+)/g.exec(b) || [], "IE " + (a[1] || "")) : "Chrome" === c[1] && (a = b.match(/\b(OPR|Edge)\/(\d+)/), null != a) ? a.slice(1).join(" ").replace("OPR", "Opera") : (c = c[2] ? [c[1], c[2]] : [navigator.appName, navigator.appVersion, "-?"], null != (a = b.match(/version\/(\d+)/i)) && c.splice(1, 1, a[1]), c.join(" "))
    }();
    var Bc = {
            box: new THREE.BoxBufferGeometry(1, 1, 1),
            icebolt: new THREE.SphereBufferGeometry(.3, 4, 3),
            frostcall: new THREE.CylinderBufferGeometry(12, 12, 1, 20, 1),
            frostblizz: new THREE.SphereBufferGeometry(.3, 3, 2),
            iceblock: new THREE.SphereBufferGeometry(3, 4, 5),
            bow: new THREE.TorusBufferGeometry(1.3, .15, 3, 4, 2.5),
            shadow: new THREE.PlaneBufferGeometry(2, 2)
        },
        Cc = {};
    Cc.chest = {
        geo: Bc.box,
        scale: [1, 1, 1]
    }, Cc.leg = {
        geo: Bc.box,
        scale: [.4, .4, .4]
    }, Cc.hand = {
        geo: Bc.box,
        scale: [.45, .4, .4]
    }, Cc.hitbox = {
        geo: Bc.box,
        scale: [1.4, 2.2, 1.4]
    }, Cc.mage_staff = {
        geo: Bc.box,
        scale: [.2, 1.8, .2]
    }, Cc.mage_shield = {
        geo: Bc.box,
        scale: [.4, 2.4, 2.4]
    }, Cc.icebolt = {
        geo: Bc.icebolt
    }, Cc.frostcall = {
        geo: Bc.frostcall
    }, Cc.frostcallblizz = {
        geo: Bc.frostblizz
    }, Cc.iceblock = {
        geo: Bc.iceblock
    }, Cc.shaman_mace1 = {
        geo: Bc.box,
        scale: [.6, 2, .6]
    }, Cc.shaman_mace2 = {
        geo: Bc.box,
        scale: [1.8, .8, 2.7]
    }, Cc.shaman_robe = {
        geo: Bc.box,
        scale: [.5, .8, .1]
    }, Cc.shaman_shield = {
        geo: Bc.box,
        scale: [1, 1, .2]
    }, Cc.equilibrate = {
        geo: Bc.box,
        scale: [.5, .5, .5]
    }, Cc.warrior_sword = {
        geo: Bc.box,
        scale: [.9, 4.2, .5]
    }, Cc.warrior_shield = {
        geo: Bc.box,
        scale: [.5, 3.5, 3.5]
    }, Cc.archer_bow = {
        geo: Bc.bow
    }, Cc.archer_bow_end = {
        geo: Bc.box,
        scale: [1, .6, .5]
    }, Cc.archer_ammo = {
        geo: Bc.box,
        scale: [.27, .5, .27]
    }, Cc.archer_ammo2 = {
        geo: Bc.box,
        scale: [1.2, .8, 1.2]
    }, Cc.archer_arrow = {
        geo: Bc.box,
        scale: [.1, .1, .8]
    }, Cc.generic_sword = {
        geo: Bc.box,
        scale: [.3, 1.3, .15]
    }, Cc.shadow = {
        geo: Bc.shadow
    }, mc.monster = new THREE.MeshLambertMaterial({
        color: 8286051,
        shading: THREE.FlatShading
    }), mc.shaman = new THREE.MeshLambertMaterial({
        color: 3687924,
        shading: THREE.FlatShading
    }), mc.warrior = new THREE.MeshLambertMaterial({
        color: 15172191,
        shading: THREE.FlatShading
    }), mc.archer = new THREE.MeshLambertMaterial({
        color: 10471258,
        shading: THREE.FlatShading
    }), mc.mage = new THREE.MeshLambertMaterial({
        color: 6607340,
        shading: THREE.FlatShading
    }), mc.warden = new THREE.MeshLambertMaterial({
        color: 14755623,
        shading: THREE.FlatShading
    }), mc.damage = new THREE.MeshLambertMaterial({
        color: 13382451,
        emissive: 4393996
    }), mc.dead = new THREE.MeshBasicMaterial({
        color: 2236962,
        shading: THREE.FlatShading
    }), mc.leg = new THREE.MeshLambertMaterial({
        color: 3451301,
        shading: THREE.FlatShading
    }), mc.generic_sword = new THREE.MeshLambertMaterial({
        color: 16711680,
        shading: THREE.FlatShading
    }), mc.warrior_sword = new THREE.MeshStandardMaterial({
        color: 14736861,
        shading: THREE.FlatShading
    }), mc.warrior_shield = new THREE.MeshStandardMaterial({
        color: 11243674,
        shading: THREE.FlatShading
    }), mc.mage_ice = new THREE.MeshBasicMaterial({
        color: 14540287
    }), mc.mage_frost = new THREE.MeshBasicMaterial({
        color: 13434879,
        transparent: !0,
        opacity: .6
    }), mc.mage_staff = new THREE.MeshLambertMaterial({
        color: 8937028,
        shading: THREE.FlatShading
    }), mc.mage_shield = new THREE.MeshLambertMaterial({
        color: 14544367,
        shading: THREE.FlatShading
    }), mc.equilibrate = new THREE.MeshLambertMaterial({
        color: 11364178,
        shading: THREE.FlatShading
    }), mc.shaman_mace1 = new THREE.MeshLambertMaterial({
        color: 12283747,
        shading: THREE.FlatShading
    }), mc.shaman_mace2 = new THREE.MeshLambertMaterial({
        color: 11643819,
        shading: THREE.FlatShading
    }), mc.shaman_robe = new THREE.MeshLambertMaterial({
        color: 16777215,
        shading: THREE.FlatShading
    }), mc.shaman_shield = new THREE.MeshLambertMaterial({
        color: 16777215,
        shading: THREE.FlatShading
    }), mc.archer_bow = new THREE.MeshLambertMaterial({
        color: 8937028,
        shading: THREE.FlatShading
    }), mc.archer_bowend = new THREE.MeshLambertMaterial({
        color: 10913898,
        shading: THREE.FlatShading
    }), mc.archer_ammo = new THREE.MeshLambertMaterial({
        color: 14795173,
        shading: THREE.FlatShading
    }), mc.archer_ammo2 = new THREE.MeshLambertMaterial({
        color: 16312288,
        shading: THREE.FlatShading
    }), mc.archer_arrow = new THREE.MeshBasicMaterial({
        color: 9002834
    }), mc.gold = new THREE.MeshStandardMaterial({
        color: 16440582,
        emissive: 16740864,
        metalness: .5,
        roughness: .4
    }), mc.metal = new THREE.MeshStandardMaterial({
        color: 11582396,
        emissive: 3158071,
        metalness: .55,
        roughness: .4
    }), mc.silver = new THREE.MeshStandardMaterial({
        color: 13891577,
        emissive: 5994641,
        metalness: .58,
        roughness: .4
    });
    var Dc = [],
        Ec = function(a) {
            for (var b = Dc.length; b--;) {
                var c = Dc[b];
                c.tick(a), c.deleteMe && (c.remove(), Dc.splice(b, 1))
            }
        },
        Fc = function(a) {
            if (!ya && "false" != sa.get("skillefx")) {
                var b = new W(a);
                return Dc.push(b), b
            }
        };
    W.prototype.tick = function(a) {
        this.stepIntervalTimer -= a, this.stepIntervalTimer <= 0 ? (this.stepIntervalTimer = this.stepInterval, this.step()) : "glue" == this.headType && (this.at[this.steps - 1].copy(this.a.getWorldPosition()), this.bt[this.steps - 1].copy(this.b.getWorldPosition()), this.updateVertice(this.steps - 1)), "compress" == this.tailType && (this.uvStepSize = 1 / Math.min(this.steps, this.stepsDone - this.stepIntervalTimer / this.stepInterval)), this.uvShift = this.uvStepSize * (this.stepIntervalTimer / this.stepInterval);
        for (var b = 0; b < this.steps; b++) this.updateUV(b);
        this.timeout && (this.timer -= a, this.timer < 0 && (this.deleteMe = !0))
    }, W.prototype.step = function(a, b) {
        ++this.stepsDone;
        var c = a || this.a.getWorldPosition(),
            d = b || this.b.getWorldPosition();
        this.at.shift(), this.bt.shift(), this.at.push(c), this.bt.push(d);
        for (var e = 0; e < this.steps; e++) this.updateVertice(e)
    }, W.prototype.updateVertice = function(a) {
        this.geom.vertices[2 * a].copy(this.at[a]), this.geom.vertices[2 * a + 1].copy(this.bt[a]), this.geom.verticesNeedUpdate = !0, this.geom.normalsNeedUpdate = !0
    }, W.prototype.updateUV = function(a) {
        if (a < this.steps - 1) {
            var b = (this.steps - a - 1) * this.uvStepSize - this.uvShift,
                c = (this.steps - a - 2) * this.uvStepSize - this.uvShift;
            this.geom.faceVertexUvs[0][2 * a][0].y = b, this.geom.faceVertexUvs[0][2 * a][1].y = c, this.geom.faceVertexUvs[0][2 * a][2].y = b, this.geom.faceVertexUvs[0][2 * a + 1][0].y = c, this.geom.faceVertexUvs[0][2 * a + 1][1].y = c, this.geom.faceVertexUvs[0][2 * a + 1][2].y = b, this.geom.uvsNeedUpdate = !0
        }
    }, W.prototype.remove = function() {
        Rb.remove(this.mesh), Rb.remove(this.a), Rb.remove(this.b), this.geom.dispose()
    }, h.prototype.timeSinceLastUpdate = 0, h.prototype.initPlayer = function(a, b) {
        this.id = a, this.geometry = new THREE.Object3D, Rb.add(this.geometry), this.body = new THREE.Group, Rb.add(this.body), this.geometry.add(this.body), this.chest = new THREE.Mesh(Cc.chest.geo, mc.monster), this.chest.scale.set(Cc.chest.scale[0], Cc.chest.scale[1], Cc.chest.scale[2]), this.chest.castShadow = !0, this.chest.rotation.order = "YXZ", this.chest.cycle = 0, this.body.add(this.chest);
        var c = new THREE.Mesh(Cc.leg.geo, mc.leg);
        c.scale.set(Cc.leg.scale[0], Cc.leg.scale[1], Cc.leg.scale[2]), Rb.add(c);
        var d = new THREE.Mesh(Cc.leg.geo, mc.leg);
        d.scale.set(Cc.leg.scale[0], Cc.leg.scale[1], Cc.leg.scale[2]), Rb.add(d), this.legs = new THREE.Group, Rb.add(d), this.body.add(this.legs), this.legs.add(d), this.legs.add(c), this.legs.l = c, this.legs.r = d, this.legs.cycle = 0, this.legs.lastVisualPos = new THREE.Vector3;
        var e = new THREE.Mesh(Cc.hand.geo, mc.leg);
        e.scale.set(Cc.hand.scale[0], Cc.hand.scale[1], Cc.hand.scale[2]), Rb.add(e);
        var f = new THREE.Mesh(Cc.hand.geo, mc.leg);
        f.scale.set(Cc.hand.scale[0], Cc.hand.scale[1], Cc.hand.scale[2]), Rb.add(f), this.hands = new THREE.Group, this.hands.cycle = 0, Rb.add(f), this.chest.add(this.hands), this.hands.add(f), this.hands.add(e), this.hands.l = e, this.hands.r = f, this.hitbox = new THREE.Mesh(Cc.hitbox.geo, mc.hitbox), this.hitbox.scale.set(Cc.hitbox.scale[0], Cc.hitbox.scale[1], Cc.hitbox.scale[2]), this.body.add(this.hitbox), this.hitbox.position.y = 1, this.hitbox.entity = this, this.visualPosition = new THREE.Vector3, b && (this.isPlayer = !0, Zb = this, this.outofpositioncounter = 0, Rb.remove(Wb), Wb.position.x = 0, Wb.position.z = 8, Wb.position.y = 1.5, this.camPivot = new THREE.Object3D, this.camPivot.rotation.order = "YXZ", Rb.add(this.camPivot), this.camPivot.add(Wb), this.serverpos = new THREE.Vector3, this.ignoreInput = 0, Vb.target = this.geometry, Vb.position.set(3e3, 5e3, 0)), this.visualRotationSpeed = 0, this.visualRotationLast = 0, this.visualRotation = 0, this.dmgSprites = new Array, "true" == sa.get("nameplates") && (this.namesprite = new ba("", {
            align: ed.center,
            font: "bold 16px 'Helvetica Neue',Helvetica,Arial,sans-serif",
            fillStyle: "#FFFFFF",
            outlineSize: 5,
            outlineStyle: "black",
            antialias: !0
        }), Sb.add(this.namesprite), this.namesprite.position.set(0, 30, 0), this.namesprite.scale.set(1, 1, 1)), this.levelsprite = new ba("5", {
            align: ed.center,
            font: "bold 16px 'Helvetica Neue',Helvetica,Arial,sans-serif",
            fillStyle: "#FFFFFF",
            outlineSize: 5,
            outlineStyle: "black",
            antialias: !0
        }), Sb.add(this.levelsprite), this.levelsprite.position.set(0, 0, 0), this.levelsprite.scale.set(1, 1, 1), this.hpbar = new Object, this.hpbar.bg = new THREE.Sprite(mc.hpbarbg), Sb.add(this.hpbar.bg), this.hpbar.fg = new THREE.Sprite(mc.hpbarfriendly), Sb.add(this.hpbar.fg), this.factionIcon = new THREE.Sprite(mc.factionA), this.factionIcon.position.set(0, 0, 0), this.factionIcon.scale.set(1, 1, 1), Sb.add(this.factionIcon)
    }, h.prototype.playertick = function(a) {
        if (this != Zb) return void(this.isPlayer = !1);
        if (this.ignoreInput -= a, this.ignoreInput < 0 && (this.ignoreInput = 0), this.stats && !this.stats.isDead() && !this.stats.incapacitated && this.ignoreInput <= 0 && (this.walkForward = 0, this.walkSideward = 0, la && (hb.cameraY -= 2.3 * a), ma && (hb.cameraY += 2.3 * a), this.camPivot.rotation.x = hb.cameraX, this.camPivot.rotation.y = hb.cameraY, (hb.rmb || la || ma || "true" == sa.get("camlock")) && (this.geometry.rotation.y = hb.cameraY), (ja || hb.lmb && hb.rmb) && (this.walkForward = 1), ka && (this.walkForward = -1), ia && (this.walkSideward = 1), ha && (this.walkSideward = -1), this.rotation = this.geometry.rotation.y, 0 != ja && !hb.lmb && !hb.rmb && "true" != sa.get("camlock"))) {
            var b = y(hb.cameraY, this.geometry.rotation.y) * a * 2;
            Math.abs(b) > .03 * a ? (b = b > 0 ? Math.max(b, .6 * a) : Math.min(b, -.6 * a), hb.cameraY += b) : hb.cameraY = this.geometry.rotation.y
        }
        this.camPivot.scale.set(this.stats.scale, this.stats.scale, this.stats.scale), Wb.position.z = hb.cameraZoom
    }, h.prototype.clienttick = function(a) {
        if (this.tick(a), !this.stats.isDead())
            if (this.isPlayer) {
                if (!this.stats.incapacitated) {
                    var b = Math.abs(this.serverpos.x - this.position.x),
                        c = Math.abs(this.serverpos.z - this.position.z);
                    b > 10 || c > 10 ? (this.outofpositioncounter += a, (this.outofpositioncounter > 3 || b > 50 || c > 50) && (this.position.x = this.serverpos.x, this.position.z = this.serverpos.z, this.outofpositioncounter = 0)) : this.outofpositioncounter = 0
                }
                this.geometry.position.x = this.position.x, this.geometry.position.z = this.position.z, this.geometry.position.y = hc(this.geometry.position.x, this.geometry.position.z), this.visualPosition.copy(this.position), this.geometry.rotation.y = this.rotation
            } else {
                this.next.position.x += this.velocity.x * a * this.stats.movespeed, this.next.position.z += this.velocity.z * a * this.stats.movespeed;
                var d = new THREE.Vector3;
                d.subVectors(this.position, this.visualPosition);
                var e = 0 != d.x || 0 != d.z ? d.length() : 0;
                if (e > .8 * this.stats.movespeed ? (this.visualPosition.copy(this.position), d.x = 0, d.z = 0) : e > .1 * this.stats.movespeed ? d.setLength(a * this.stats.movespeed) : (this.position != this.next.position && (this.position.x = this.next.position.x, this.position.z = this.next.position.z), d.multiplyScalar(10 * a)), this.visualPosition.add(d), this.geometry.position.x = this.visualPosition.x, this.geometry.position.z = this.visualPosition.z, this.geometry.position.y = hc(this.geometry.position.x, this.geometry.position.z), this.visualRotationLast != this.rotation && (this.visualRotationLast - this.rotation > Math.PI ? this.visualRotationSpeed = 10 * (this.rotation + xa - this.visualRotation) * a : this.visualRotationLast - this.rotation < -Math.PI ? this.visualRotationSpeed = 10 * (this.rotation - xa - this.visualRotation) * a : this.visualRotationSpeed = 10 * (this.rotation - this.visualRotation) * a, this.visualRotationLast = this.rotation), Math.abs(this.rotation - this.visualRotation) > Math.abs(this.visualRotationSpeed)) {
                    for (this.visualRotation += this.visualRotationSpeed; this.visualRotation < 0;) this.visualRotation += xa, this.visualRotationLast = this.visualRotation;
                    for (; this.visualRotation > xa;) this.visualRotation -= xa, this.visualRotationLast = this.visualRotation
                }
                this.geometry.rotation.y = this.visualRotation, nc.push(this.hitbox), void 0 !== this.desiredTarget && "" != this.desiredTarget && ca.entities.hasOwnProperty(this.desiredTarget) && (this.target = ca.entities[this.desiredTarget], this.desiredTarget = "")
            }
        if (this.tickAnimations(a), this != Zb ? (this.timeSinceLastUpdate += a, this.timeSinceLastUpdate > 3 && fa(this.id)) : (this.camPivot.position.copy(this.geometry.position), this.camPivot.updateMatrixWorld(), Wb.updateMatrixWorld()), this.stats.scale != this.last.stats.scale) {
            this.last.stats.scale = this.stats.scale;
            var f = Math.max(1, 2 / this.stats.scale);
            this.hitbox.scale.set(f, f, f)
        }
        this.hpbar && this.tickHud(a)
    }, h.prototype.destroyBody = function() {
        this.namesprite && this.namesprite.finalCleanUp(), this.levelsprite.finalCleanUp(), Sb.remove(this.namesprite), Sb.remove(this.hpbar.fg), Sb.remove(this.hpbar.bg), Sb.remove(this.levelsprite), Sb.remove(this.factionIcon), delete this.namesprite, delete this.levelsprite, delete this.hpbar.fg, delete this.hpbar.bg, delete this.factionIcon, this.isPlayer && Rb.remove(this.camPivot);
        for (var a = this.dmgSprites.length; a--;) Sb.remove(this.dmgSprites[a]), this.dmgSprites[a].finalCleanUp(), this.dmgSprites.splice(a, 1);
        X(this.geometry), Rb.remove(this.geometry), delete this.geometry
    }, h.prototype.takeDamage = function(a) {
        this.stats.invincible || (this.dmgShake = .2)
    }, h.prototype.takeHealing = function(a) {}, h.prototype.updateFaction = function(a, b) {
        if (this.faction = a, !b) {
            var c;
            switch (a) {
                case 0:
                    c = mc.factionA;
                    break;
                case 1:
                    c = mc.factionB;
                    break;
                case 2:
                    return
            }
            this.factionIcon.material = c
        }
        if (Zb && (2 == this.faction ? this.hpbar.fg.material = mc.hpbarmob : this.hpbar.fg.material = this.faction == Zb.faction ? mc.hpbarfriendly : mc.hpbarenemy, this.hpbar.fg.materialNeedsUpdate = !0, this == Zb))
            for (var d in $b) $b.hasOwnProperty(d) && void 0 !== $b[d] && $b[d] != this && $b[d].updateFaction($b[d].faction, !0)
    }, h.prototype.getInfoPanelString = function() {
        if (!Zb) return "";
        var a = this.faction == Zb.faction ? "Friendly" : "Hostile",
            b = this.faction == Zb.faction ? "ally" : "enemy",
            c = this.isAi ? "monster" : "player";
        return "<div class='targetinfo targettext " + b + "'><span class='targetname'>" + this.name + "</span> <span class='targetlevel'>" + this.class.level + "</span></div> " + a + " " + c
    };
    var Gc = function() {
            for (e in ca.entities) ca.entities[e] && ca.entities[e] != Zb && (ca.entities[e].canFightPlayer = Ta(ca.entities[e], Zb).canFight())
        },
        Hc = new THREE.Vector2(100, 20),
        Ic = [],
        Jc = [],
        Kc = void 0,
        Lc = void 0,
        Mc = .996,
        Nc = .8;
    h.prototype.tickHud = function(a) {
        if (this.geometry) {
            var b = new THREE.Vector3;
            b.copy(this.geometry.position), b.y += Math.max(.5, this.stats.scale + 1), b = Y(b, Wb);
            var c = (Mc - b.z) * (1 / (Mc - Nc)),
                d = Zb && this != Zb ? Ta(Zb, this).distance() : 1,
                e = !0;
            if (this != Zb && d < 50 && b.z > Nc && b.z < 1 && Math.abs(b.x) < .5 * ca.width && Math.abs(b.y) < .5 * ca.height) {
                var f = Zb && this == Zb.target || this == Zb,
                    g = f ? 1.1 : Math.min(1.5, .4 + 12 * c);
                f && (b.z = 5), b.y += 8;
                var h = b.y + 15 * g;
                this.levelsprite.position.set(b.x + .5 * Hc.x * g, b.y, b.z + 3e-5);
                var i = Hc.x * Math.max(0, Math.min(1, this.stats.currenthp / this.stats.maxhp));
                this.hpbar.bg.position.set(b.x, b.y, b.z + 1e-5), this.hpbar.fg.position.set(b.x + (.5 * i - .5 * Hc.x) * g, b.y, b.z + 2e-5), this.factionIcon.position.set(b.x - 55 * g, b.y, b.z + 3e-5), this.hpbar.bg.scale.set((Hc.x + 4) * g, (Hc.y + 4) * g, 1), this.hpbar.fg.scale.set(i * g, Hc.y * g, 1), this.levelsprite.scale.set(g, g, 1), this.factionIcon.scale.set(20 * g, 20 * g, 1), this.hpbar.fg.material = Zb && this.faction == Zb.faction ? f ? mc.hpbarfriendly : mc.hpbarfriendlyTransparent : f ? 2 == this.faction ? mc.hpbarmob : this.canFightPlayer ? mc.hpbarenemy : mc.hpbarcantfight : 2 == this.faction ? mc.hpbarmobTransparent : this.canFightPlayer ? mc.hpbarenemyTransparent : mc.hpbarcantfightTransparent, this.hpbar.bg.material = f ? mc.hpbarbg : mc.hpbarbgTransparent, this.levelsprite.material.opacity = f ? 1 : .2, Zb && !this.stats.isDead() && (this.faction != Zb.faction ? Ic.push({
                    entity: this,
                    z: d
                }) : Jc.push({
                    entity: this,
                    z: d
                })), this.hpbar.fg.visible = !0, this.hpbar.bg.visible = !0, this.levelsprite.visible = !0, this.factionIcon.visible = 2 != this.faction, this.namesprite && (this.namesprite.visible = !0, this.namesprite.position.set(b.x, h, b.z + 3e-5), this.namesprite.material.opacity = f ? 1 : .2, this.namesprite.scale.set(g, g, 1)), e = !0
            } else this.hpbar.fg.visible = !1, this.hpbar.bg.visible = !1, this != Zb && this.namesprite && (this.namesprite.visible = !1), this.levelsprite.visible = !1, this.factionIcon.visible = !1;
            this == Zb && P();
            for (var j = this.dmgSprites.length; j--;) {
                var k = this.dmgSprites[j];
                if (k.timer += a, k.timer > 1) Sb.remove(k), k.finalCleanUp(), this.dmgSprites.splice(j, 1);
                else if (e) {
                    var l = Math.max(.8, 1.5 - 3 * k.timer);
                    k.scale.set(l, l, 1), k.origin.y += k.yvel * a, k.yvel -= 3 * a;
                    var b = Y(k.origin, Wb);
                    k.position.set(b.x + k.xoffset, b.y + 30, 6), k.isVisible = !0
                } else k.isVisible = !1
            }
        }
    }, h.prototype.createCombatText = function(a, b, c) {
        if (!Zb || this.faction == Zb.faction || !c) {
            var d = new THREE.Vector3(this.geometry.position.x, this.geometry.position.y + this.stats.scale + 1.2, this.geometry.position.z),
                e = Y(d, Wb);
            if (e.z > Nc && e.z < 1 && Math.abs(e.x) < .5 * ca.width && Math.abs(e.y) < .5 * ca.height) {
                var f = this.faction == (Zb ? Zb.faction : 0) ? c ? "#59DD36" : "#FF0000" : "#FFFF00",
                    g = new ba(a, {
                        align: ed.center,
                        font: "bold 30px 'Helvetica Neue',Helvetica,Arial,sans-serif",
                        fillStyle: f,
                        antialias: !0
                    });
                Sb.add(g), g.origin = d, g.xoffset = (10 * Math.random() - 5) * this.dmgSprites.length, g.yvel = 3 + 10 * Math.min(b / this.stats.maxhp, .3), g.timer = 0, this.dmgSprites.push(g)
            }
        }
    };
    var Oc, Pc, Qc, Rc = function() {
            if (Kc = void 0, Lc = void 0, Ic.sort(function(a, b) {
                    return a.z - b.z
                }), Jc.sort(function(a, b) {
                    return a.z - b.z
                }), Zb && Zb.target) {
                for (var a = 0, b = Ic.length; a < b; ++a) Zb.target == Ic[a].entity && (Kc = Ic[a + 1] ? Ic[a + 1].entity : Ic[0].entity);
                for (var a = 0, b = Jc.length; a < b; ++a) Zb.target == Jc[a].entity && (Lc = Jc[a + 1] ? Jc[a + 1].entity : Jc[0].entity)
            }
            void 0 == Kc && Ic.length > 0 && (Kc = Ic[0].entity), void 0 == Lc && Jc.length > 0 && (Lc = Jc[0].entity)
        },
        Sc = void 0,
        Tc = 0,
        Uc = void 0,
        Vc = void 0,
        Wc = !1,
        Xc = ["Alpheos", "Balius", "Charon", "Deimos", "Ether", "Fates", "Garrosh", "Helios", "Iris"],
        Yc = void 0,
        Zc = void 0,
        $c = void 0;
    $(document).ready(function() {
        _c(), $(window).on("beforeunload", function() {
            Oc.close()
        })
    });
    var _c = function() {
            Pc = "localhost" == document.location.hostname ? io("localhost:8123") : io(za + ":80"), Pc.on("d", function(a) {
                void 0 !== a.address && (Uc = a.address), void 0 !== a.id && (Vc = a.id), Uc = Uc.replace("127.0.0.1", "localhost"), a.sc === !0 && ad(Uc)
            }), Pc.on("m", function(a) {
                if (a) {
                    if (a.m)
                        for (var b in a.m) a.m.hasOwnProperty(b) && (a.m[b].hasOwnProperty("dps") && $("#" + b + "dps").html(N(parseInt(a.m[b].dps), 1) + " dps"), a.m[b].hasOwnProperty("pc") && $("#" + b + "players").html(parseInt(a.m[b].pc) + " players"), a.m[b].hasOwnProperty("kh") && $("#" + b + "king").html("King: " + parseInt(a.m[b].kh) + "%"), a.m[b].hasOwnProperty("g") && $("#" + b + "gold").html(N(parseInt(a.m[b].g), 1)));
                    if (a.l)
                        for (m in a.l) void 0 !== a.l[m].c && (Hb[m].class = a.l[m].c), void 0 !== a.l[m].n && (Hb[m].name = a.l[m].n), void 0 !== a.l[m].l && (Hb[m].level = a.l[m].l), void 0 !== a.l[m].f && (Hb[m].fame = a.l[m].f), void 0 !== a.l[m].h && (Hb[m].horde = a.l[m].h), Ib(parseInt(m) + 1, {
                            class: Hb[m].class,
                            name: Hb[m].name,
                            fame: Hb[m].fame,
                            lvl: Hb[m].level,
                            horde: Hb[m].horde
                        });
                    if (void 0 !== a.s && "object" == typeof a.s) {
                        $("#channelname").html((Xc.length - 1 > Vc ? Xc[Vc] + (Xc.length - 1 > Vc ? " (" + a.s[Vc] + ")" : "") : "Channel") + " <span class='caret'>");
                        var c = $("#serverselectionlist");
                        c.empty();
                        for (var d = 0; d < parseInt(a.s.length); ++d) {
                            var e = $("<li/>").appendTo(c),
                                f = $("<a/>").text(Xc[d] + ("" != a.s[d] ? " (" + a.s[d] + ")" : "")).appendTo(e).data("sr", d);
                            d == Vc && f.css("font-weight", 800), f.on("click", function(a) {
                                Pc.emit("sr", parseInt($(this).data("sr")))
                            })
                        }
                    }
                }
            }), Pc.on("c", function(a) {
                a.m && a.i && Q({
                    msg: a.m,
                    src: a.i,
                    name: a.n
                })
            }), Pc.on("gm", function(a) {
                switch (a.t) {
                    case "pk":
                        Q({
                            msg: "$" + a.f + a.a + " killed $" + (0 == a.f ? 1 : 0) + a.b + " and stole " + a.fa + " fame and " + a.g + " $g",
                            src: "playerkill"
                        })
                }
            })
        },
        ad = function(b) {
            if (void 0 !== b) {
                void 0 != Oc && (Oc.disconnect(), delete Oc), void 0 !== $c && (clearInterval($c), $c = void 0), void 0 !== Zc && (clearInterval(Zc), Zc = void 0), void 0 !== Yc && (clearInterval(Yc), Yc = void 0), Oc = io(b), Oc.on("handshake", function(a) {
                    Qc = a.playerid, void 0 !== Sc ? dd(Sc) : bd(), $("#loginMenu").remove()
                });
                var c = [],
                    d = 5,
                    e = function(a) {
                        var b = a.e;
                        for (var e in b)
                            if (b.hasOwnProperty(e) && ($b.hasOwnProperty(e) && void 0 != $b[e] || ($b[e] = new h(0), $b[e].initPlayer(e, e == Qc), e == Qc && b[e].r && (hb.cameraY = parseFloat(b[e].r), hb.cameraX = -.5))), ea(e, b[e]), void 0 === $b[e].class.type) c.indexOf(e) < 0 && c.push(e + "");
                            else {
                                var f = c.indexOf(e);
                                f > -1 && c.splice(f, 1)
                            }
                        if (d++, d >= 10 && c.length > 0 && (d = 0, Oc.emit("ref", c), c = []), a.pr)
                            for (var e in a.pr) a.pr.hasOwnProperty(e) && $b.hasOwnProperty(e) && ea(e, a.pr[e]);
                        if (a.i)
                            for (var g in a.i) a.i.hasOwnProperty(g) && (void 0 !== a.i[g].r ? void 0 !== Ka[g] && Ka[g].destroy() : void 0 === Ka[g] && (a.i[g].i = g, Ka[g] = new n(a.i[g])))
                    };
                Oc.on("e", e), Oc.on("c", function(a) {
                    a.m && a.i && Q({
                        msg: a.m,
                        src: a.i,
                        name: a.n
                    })
                }), Oc.on("spawn", function(b) {
                    if (e(b.m), b.dbid && ($("#charIdDisplay").text(b.dbid), Sc = b.dbid, Pc.emit("a", b.dbid)), Zb && b.abl)
                        for (a in b.abl) Zb.class.skills[parseInt(a)].setLevel(b.abl[a]);
                    var c = sa.get("name");
                    c && Oc.emit("namechange", c), tb.player.panel.hide(), $("#renderer").fadeIn(300, function() {
                        Gb("fadeIn", 300), tb.target.panel.hide(), Fb = !1, da._registered_combos[0].on_keydown()
                    })
                }), Oc.on("del", function(a) {
                    fa(a)
                }), Oc.on("disconnect", function() {
                    ga(), Gb("fadeOut", 500), Rb.add(Wb)
                }), Oc.on("lm", function(a) {
                    $("#serverLoginMessage").text(a), $("#serverLoginMessage").fadeIn()
                }), Oc.on("inv", function(a) {
                    Oa(a)
                }), Yc = setInterval(function() {
                    if (!document.hidden && performance.now() - pc < 1e3 && Zb) {
                        var a = Zb.getDeltaMsg();
                        a !== !1 && Oc.emit("u", a)
                    }
                }, Aa);
                var f;
                Zc = setInterval(function() {
                    document.hidden || (f = performance.now(), Oc.emit("pi"))
                }, 2e3), Oc.on("po", function(a) {
                    Tc = Math.max(0, (2 * Tc + (performance.now() - f)) / 3)
                });
                var g = 1,
                    i = function() {
                        document.hidden || isNaN(Tc) || isNaN(qc) || (Oc.emit("pd", {
                            c: g,
                            p: parseInt(Tc),
                            fps: parseInt(1e3 / qc),
                            sh: sa.get("shadows"),
                            gr: sa.get("grass"),
                            res: sa.get("resolution"),
                            fx: sa.get("skillefx"),
                            br: navigator.sayswho
                        }), ++g, g > 5 && void 0 !== $c && clearInterval($c))
                    };
                i(), $c = setInterval(i, 6e4)
            }
        },
        bd = function() {
            cd($("#usernameInputField").val()), Oc.emit("requestSpawn", {
                name: sa.get("name"),
                class: sa.get("class"),
                faction: sa.get("faction")
            })
        },
        cd = function(a) {
            void 0 != a && "string" == typeof a || (a = ""), sa.set("name", a)
        },
        dd = function(a) {
            Oc.emit("requestSpawn", {
                id: a
            })
        },
        ed = {
            center: new THREE.Vector2(0, 0),
            left: new THREE.Vector2(1, 0),
            topLeft: new THREE.Vector2(1, -1),
            topRight: new THREE.Vector2(-1, -1),
            right: new THREE.Vector2(-1, 0),
            bottomLeft: new THREE.Vector2(1, 1),
            bottomRight: new THREE.Vector2(-1, 1)
        };
    const fd = {};
    aa.prototype.width = function() {
        return this.canvas.width
    }, aa.prototype.height = function() {
        return this.canvas.height
    }, aa.prototype.drawText = function(a, b) {
        return this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.ctx.font = b.font, this.textWidth = Math.max(1, Math.ceil(this.ctx.measureText(a).width)), this.textHeight = _(this.ctx.font), this.canvas.width = THREE.Math.nextPowerOfTwo(this.textWidth), this.canvas.height = THREE.Math.nextPowerOfTwo(this.textHeight), this.ctx.font = b.font, this.ctx.fillStyle = b.fillStyle, this.ctx.textAlign = "center", this.ctx.textBaseline = "middle", this.ctx.strokeStyle = b.outlineStyle, this.ctx.miterLimit = 2, this.ctx.lineJoin = "circle", b.outlineSize > 0 && (this.ctx.lineWidth = b.outlineSize, this.ctx.strokeText(a, .5 * this.canvas.width, .5 * this.canvas.height)), this.ctx.lineWidth = 1, this.ctx.fillText(a, .5 * this.canvas.width, .5 * this.canvas.height), this.canvas
    }, ba.prototype = new THREE.Object3D, ba.prototype.constructor = ba, ba.prototype.width = function() {
        return this.canvas.textWidth
    }, ba.prototype.height = function() {
        return this.canvas.textHeight
    }, ba.prototype.getText = function() {
        return this._text
    }, ba.prototype.setText = function(a) {
        this._text !== a && (this._text = a, this.updateText())
    }, ba.prototype.getFont = function() {
        return this._font
    }, ba.prototype.setFont = function(a) {
        this._font !== a && (this._font = a, this.updateText())
    }, ba.prototype.getFillStyle = function() {
        return this._fillStyle
    }, ba.prototype.setFillStyle = function(a) {
        this._fillStyle !== a && (this._fillStyle = a, this.updateText())
    }, ba.prototype.updateText = function() {
        this.canvas.drawText(this._text, {
            font: this._font,
            fillStyle: this._fillStyle,
            outlineStyle: this._outlineStyle,
            outlineSize: this._outlineSize
        }), this.cleanUp(), this.texture = new THREE.Texture(this.canvas.canvas), this.texture.needsUpdate = !0, this.applyAntiAlias(), this.material ? this.material.map = this.texture : this.material = new THREE.SpriteMaterial({
            map: this.texture
        }), this.sprite || (this.sprite = new THREE.Sprite(this.material), this.add(this.sprite)), this.sprite.scale.set(this.canvas.width(), this.canvas.height(), 1)
    }, ba.prototype.cleanUp = function() {
        this.texture && this.texture.dispose()
    }, ba.prototype.finalCleanUp = function() {
        this.cleanUp(), this.material && this.material.dispose(), this.sprite && (this.remove(this.sprite), this.sprite = void 0)
    }, ba.prototype.applyAntiAlias = function() {
        this.antialias === !1 && (this.texture.magFilter = THREE.NearestFilter, this.texture.minFilter = THREE.LinearMipMapLinearFilter)
    }
}(window, document);
